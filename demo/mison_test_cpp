#include "../src/RecordLoader.h"
#include "../src/BitmapIterator.h"
#include "../src/BitmapConstructor.h"
#include "test_queries.h"
#include "parallel_query.h"
#include <sys/time.h>
#include <sys/file.h>
#include <unordered_set>
using namespace std;

void testMisonSmallRecords(char* file_path, query_callback qry = NULL, int num_step = 5, int level = MAX_LEVEL, bool support_array = true, bool print = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* recs = loader.loadRecords();;
    if (recs == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        string output;
        output_size = 0;
        // visit each record sequentially
        long start_idx = 0;
        long end_idx = recs->num_records;
        while (start_idx < end_idx) {
            Bitmap* bm = BitmapConstructor::constructMison(recs, start_idx, num_step, level, support_array);
            if (qry != NULL) {
                BitmapIterator* iter = BitmapConstructor::getIterator(bm);
                qry(iter, output, output_size);
                delete iter;
            }
            delete bm;
            ++start_idx;
        }
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        exe_time.push_back(time);
        // printf("The duration of small records processing is %lf\n",duration/1000000);
        //if (qry != NULL)
        //    cout<<"the total number of output matches is "<<output_size<<endl;
    }
    if (print == true) {
        double sum_exe_time = 0.0;
        for (int i = 0; i < num_iterations; ++i) {
            sum_exe_time += exe_time[i];
        }
        double avg_exe_time = sum_exe_time / (double)num_iterations;
        cout<<"[Performance Result]: total execution time is "<<avg_exe_time<<" seconds (avg. of 10 runs)"<<endl;
        if (qry != NULL) {
            cout<<"[Number of Matches]: "<<output_size<<endl;
        }
    }
    delete recs;
}

// records in National Statistics Postcode Lookup (NSPL) dataset contain both object records and array records, which are different
// from other datasets. Current BitmapConstructor::getIterator function generates leveled colon bitmaps for the first level of the
// record by default. In fact, if the record type is not matched, BitmapConstructor::getIterator function can be skipped, so that
// the performance can be further improved.
void testMisonSmallRecordsSpecial(char* file_path, query_callback qry = NULL, int num_step = 5, int level = MAX_LEVEL, bool support_array = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* recs = loader.loadRecords();;
    if (recs == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        string output;
        output_size = 0;
        // visit each record sequentially
        long start_idx = 0;
        long end_idx = recs->num_records;
        while (start_idx < end_idx) {
            Bitmap* bm = BitmapConstructor::constructMison(recs, start_idx, num_step, level, support_array);
            if (qry != NULL) {
                // check whether the first non-empty character is '{'
                char* record = recs->text + recs->rec_start_pos[start_idx];
                int idx = 0;
                while (record[idx] == ' ') ++idx;
                if (record[idx++] != '{') {
                    delete bm;
                    ++start_idx;
                    continue;
                }
                BitmapIterator* iter = BitmapConstructor::getIterator(bm);
                qry(iter, output, output_size);
                delete iter;
            }
            delete bm;
            ++start_idx;
        }
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        exe_time.push_back(time);
    }
    double sum_exe_time = 0.0;
    for (int i = 0; i < num_iterations; ++i) {
        sum_exe_time += exe_time[i];
    }
    double avg_exe_time = sum_exe_time / (double)num_iterations;
    cout<<"[Performance Result]: total execution time is "<<avg_exe_time<<" seconds (avg. of 10 runs)"<<endl;
    if (qry != NULL)
        cout<<"[Number of Matches]: "<<output_size<<endl;
    delete recs;
}

void testMison(char* file_path, query_callback qry = NULL, int num_step = 5, int level = MAX_LEVEL, bool support_array = true, bool print = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* records = loader.loadSingleRecord();
    if (records == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> idx_construction_time;
    vector<double> query_exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        Bitmap* bm = BitmapConstructor::constructMison(records, 0, num_step, level, support_array);
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        idx_construction_time.push_back(time);
        //printf("The duration of index construction is %lf\n",duration/1000000);
        if (qry != NULL) {
            gettimeofday(&begin,NULL);
            BitmapIterator* iter = BitmapConstructor::getIterator(bm);
            // query execution
            string output;
            output_size = 0;
            qry(iter, output, output_size);
            //cout<<"the total number of output matches is "<<output_size<<endl;
            delete iter;
            gettimeofday(&end,NULL);
            duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
            time = duration / (double) 1000000;
            query_exe_time.push_back(time);
        }
        //printf("The duration of query execution is %lf\n",duration/1000000);
        delete bm;
    }
    if (print == true) {
        double sum_idx_time = 0.0;
        double sum_query_time = 0.0;
        for (int i = 0; i < num_iterations; ++i) {
            sum_idx_time += idx_construction_time[i];
            if (qry != NULL) sum_query_time += query_exe_time[i];
        }
        double avg_idx_time = sum_idx_time / (double)num_iterations;
        cout<<"[Performance Result]: index construction time is "<<avg_idx_time<<" seconds (avg. of 10 runs)"<<endl;
        double avg_query_time = 0.0;
        if (qry != NULL) {
            avg_query_time = sum_query_time / (double)num_iterations;
            cout<<"[Performance Result]: query evaluation time is "<<avg_query_time<<" seconds (avg. of 10 runs)"<<endl;
            cout<<"[Number of Matches]: "<<output_size<<endl;
        }
        double avg_tot_time = avg_idx_time + avg_query_time;
        cout<<"[Performance Result]: total execution time is "<<avg_tot_time<<" seconds (avg. of 10 runs)"<<endl;
    }
    delete records;
}

// following two functions are used for collecting the evaluation data in Figure 12, Figure 13
void testMisonSmallRecordsIndexConstructionTimeBreakdown(char* file_path) {
    cout<<"------Index Construction Time Breakdown (Mison, Small Records) Begin------"<<endl;
    for (int num_step = 1; num_step <= 5; ++num_step) {
        cout<<"step 1 to step "<<num_step<<" starts"<<endl;
        testMisonSmallRecords(file_path, NULL, num_step);
        cout<<"done"<<endl;
    }
    cout<<"------Index Construction Time Breakdown (Mison, Small Records) End------"<<endl;
}

void testMisonIndexConstructionTimeBreakdown(char* file_path) {
    cout<<"------Index Construction Time Breakdown (Mison, Large Record) Begin------"<<endl;
    for (int num_step = 1; num_step <= 5; ++num_step) {
        cout<<"step 1 to step "<<num_step<<" starts"<<endl;
        testMison(file_path, NULL, num_step);
        cout<<"done"<<endl;
    }
    cout<<"------Index Construction Time Breakdown (Mison, Large Record) End------"<<endl;
}

// following two functions are used for comparing the performance of Mison with Pikkr. Both of
// them don't support arrays.
void testMisonSmallRecordsNoArray(char* file_path) {
    testMisonSmallRecords(file_path, NULL, 5, MAX_LEVEL, false);
}

void testMisonNoArray(char* file_path) {
    testMison(file_path, NULL, 5, MAX_LEVEL, false);
}

int main(int argc, char** argv) {
    if (argc < 4) {
        printf("the number of input arguments should be at least three: file_path, input_type(small (for small records), large (for large record)), query_id used in Pison paper\n");
        return -1;
    }
    char* file_path = argv[1];
    char* input_type = argv[2];
    string query_id(argv[3]);
    int thread_num = 1;
    cout<<endl;
    cout<<"------------------------------------------------------------------------------------------"<<endl;
    cout<<"[Start Evaluation]: "<<query_id<<" on file "<<file_path<<endl;

    //cout<<"warming up CPU"<<endl;
    if (strcmp(input_type, "small") == 0) {
        testMisonSmallRecords(file_path, NULL, 5, MAX_LEVEL, true, false);
    } else {
        testMison(file_path, NULL, 5, MAX_LEVEL, true, false);
    }
    //cout<<"finish warming up CPU"<<endl;
    if (strcmp(input_type, "small") == 0) {
        if (query_id == "TT0") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 0, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt0_small, 5, 0, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT1") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt1_small, 5, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT2") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt2_small, 5, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT3") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt3_small, 5, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT4") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt4_small, 5, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT5") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt5_small, 5, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT6") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt6_small, 5, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT7") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 3);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt7_small, 5, 3);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT8") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt8_small, 5, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT9") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 3);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_tt9_small, 5, 3);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "BB") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 2);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_bb1_small, 5, 2);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "GMD") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 7);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_gmd1_small, 5, 7);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "NSPL") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecordsSpecial(file_path, query_nspl1_small, 5, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "WM") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_wm1_small, 5, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "WP") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testMisonSmallRecords(file_path, NULL, 5, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testMisonSmallRecords(file_path, query_wp1_small, 5, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else {
            //cout<<"getting the execution time of structural index construction"<<endl;
            testMisonSmallRecords(file_path);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
        }
    } else if (strcmp(input_type, "large") == 0) {
        if (query_id == "TT0") {
            testMison(file_path, query_tt0_large, 5, 1);
        } else if (query_id == "TT1") {
            testMison(file_path, query_tt1_large, 5, 2);
        } else if (query_id == "TT2") {
            testMison(file_path, query_tt2_large, 5, 2);
        } else if (query_id == "TT3") {
            testMison(file_path, query_tt3_large, 5, 2);
        } else if (query_id == "TT4") {
            testMison(file_path, query_tt4_large, 5, 2);
        } else if (query_id == "TT5") {
            testMison(file_path, query_tt5_large, 5, 2);
        } else if (query_id == "TT6") {
            testMison(file_path, query_tt6_large, 5, 2);
        } else if (query_id == "TT7") {
            testMison(file_path, query_tt7_large, 5, 4);
        } else if (query_id == "TT8") {
            testMison(file_path, query_tt8_large, 5, 5);
        } else if (query_id == "TT9") {
            testMison(file_path, query_tt9_large, 5, 4);
        } else if (query_id == "BB") {
            testMison(file_path, query_bb1_large, 5, 4);
        } else if (query_id == "GMD") {
            testMison(file_path, query_gmd1_large, 5, 8);
        } else if (query_id == "NSPL") {
            testMison(file_path, query_nspl1_large, 5, 4);
        } else if (query_id == "WM") {
            testMison(file_path, query_wm1_large, 5, 3);
        } else if (query_id == "WP") {
            testMison(file_path, query_wp1_large, 5, 5);
        } else {
            testMison(file_path);
        }
    }
    cout<<"[End Evaluation]: "<<query_id<<" on file "<<file_path<<endl;
    cout<<"------------------------------------------------------------------------------------------"<<endl;
    return 0;
}
