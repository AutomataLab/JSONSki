#include "../src/RecordLoader.h"
#include "../src/BitmapIterator.h"
#include "../src/BitmapConstructor.h"
#include "test_queries.h"
#include "parallel_query.h"
#include <sys/time.h>
#include <sys/file.h>
#include <unordered_set>
using namespace std;

void testSbSPisonSmallRecords(char* file_path, query_callback qry = NULL, int num_step = 5, int level = MAX_LEVEL, bool support_array = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* recs = loader.loadRecords();;
    if (recs == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        string output;
        output_size = 0;
        // visit each record sequentially
        long start_idx = 0;
        long end_idx = recs->num_records;
        while (start_idx < end_idx) {
            Bitmap* bm = BitmapConstructor::constructSbSPison(recs, start_idx, num_step, level, support_array);
            if (qry != NULL) {
                BitmapIterator* iter = BitmapConstructor::getIterator(bm);
                qry(iter, output, output_size);
                delete iter;
            }
            delete bm;
            ++start_idx;
        }
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        exe_time.push_back(time);
        // printf("The duration of small records processing is %lf\n",duration/1000000);
        //if (qry != NULL)
        //    cout<<"the total number of output matches is "<<output_size<<endl;
    }
    double sum_exe_time = 0.0;
    for (int i = 0; i < num_iterations; ++i) {
        sum_exe_time += exe_time[i];
    }
    double avg_exe_time = sum_exe_time / (double)num_iterations;
    cout<<"[Performance Result]: total execution time is "<<avg_exe_time<<" seconds (avg. of 10 runs)"<<endl;
    if (qry != NULL)
        cout<<"[Number of Matches]: "<<output_size<<endl;
    delete recs;
}

struct GlobalThreadInfo {
    pthread_t threads[MAX_THREAD];
    ThreadMetaData th[MAX_THREAD];
    TaskQueue tq;
    Records* recs;
    char* text;
};

GlobalThreadInfo gti;

void* main_thread(void* arg) {
    ThreadMetaData md = (ThreadMetaData)(*(ThreadMetaData*)arg);
    int thread_id = md.thread_id;
    // cout<<thread_id<<"th thread starts querying sub-records."<<endl;
    // bind CPU
    cpu_set_t mask;
    cpu_set_t get;
    CPU_ZERO(&mask);
    CPU_SET(thread_id, &mask);
    if(pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
        cout<<"CPU binding failed for thread "<<thread_id<<endl;
    struct timeval begin,end;
    double duration;
       gettimeofday(&begin,NULL);
        while(1)
        {
            gettimeofday(&end,NULL);
            duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
            if(duration>3000000) break;
        }
    gettimeofday(&begin,NULL);
    Records* recs = gti.recs;
    SerialBitmap* bitmap =  new SerialBitmap(recs->text, 2, false);
    /// SerialBitmap* bitmap = md.bitmap;
    //BitmapIterator* iter = md.iter;
    // cout<<"thread "<<thread_id<<endl;
    long start_idx = 0, end_idx = 0;//272499/16;
    while (next_batch(gti.tq, start_idx, end_idx)) {
       ///cout<<"start index "<<start_idx<<" end index "<<end_idx<<" thread "<<thread_id<<endl;
       //end_idx = gq.tq.end_idx;
       while (start_idx < end_idx) {
           /*iter->moveToIndex(start_idx);
           if (iter->down()) {
               execute_query(iter, *gq.th[thread_id].output, gq.th[thread_id].output_size);
               iter->up();
           }*/
           char* record = recs->text + recs->rec_start_pos[start_idx];
           long length = recs->rec_length[start_idx];
           bitmap->setRecord(record);
           bitmap->setRecordLength(length);
           //++bitmap->mOutputSize;
          /// cout<<"before record "<<length<<endl;
           bitmap->indexConstruction(); 
         ///  cout<<"after record "<<endl;
           ++start_idx;
       }
    }
    //gq.th[thread_id].output = md.output;
    gti.th[thread_id].output_size = bitmap->mOutputSize;
  //  delete iter;
    delete bitmap;
    //cout<<thread_id<<"th thread finishes querying sub-records"<<endl;
    gettimeofday(&end,NULL);
    duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
    printf("The duration of query execution is %lf\n",duration/1000000);
    return NULL;
}

void testPisonSmallRecords(char* file_path, query_callback qry = NULL, int level = MAX_LEVEL, bool support_array = true, bool print = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* recs = loader.loadRecords();;
    if (recs == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        string output;
        output_size = 0;
        // visit each record sequentially
        long start_idx = 0;
        long end_idx = recs->num_records;
        gti.tq.batch_size = get_batch_size(recs->num_records);
        cout<<"batch size"<<gti.tq.batch_size<<endl;
        ThreadMetaData md;
        int thread_num = 16;
        for (int i = 0; i < thread_num; ++i) {
            gti.th[i].thread_id = i;
            // gti.th[i].output = &output[i];
            gti.th[i].output_size = 0;
            cout<<"thread "<<i<<endl;
            /// SerialBitmap* tempbitmap = new SerialBitmap(recs->text, level, support_array);
            /// gti.th[i].bitmap = new SerialBitmap(recs->text, level, support_array);
            cout<<"thread "<<i<<" before initialize "<<endl;
           /// gti.th[i].bitmap->smallRecordInitialize(); 
            cout<<"thread "<<i<<" after initialize "<<endl;
            gti.text = recs->text;
        }
        gti.recs = recs;
        gti.tq.start_idx = 0;
        gti.tq.end_idx = end_idx;
        pthread_mutex_init(&gti.tq.mutex, NULL);
        cout<<"before creating threads"<<endl;
        for (int i = 0; i < thread_num; ++i) {
            int rc = pthread_create(&gti.threads[i], NULL, main_thread, &gti.th[i]);
            if (rc)
            {
                cout<<"Thread Error; return code is "<<rc<<endl;
                return;
            }
        }
        for(int i = 0;i < thread_num;i++)
        {
            int rc = pthread_join(gti.threads[i], NULL);
            if (rc)
            {
                cout<<"Thread Error; return code is "<<rc<<endl;
                return;
            }
        }
        for (int i = 0; i < thread_num; ++i) {
//        cout<<"thread i "<<output[i]<<endl;
        //output[i] = gq.th[i].output;
            output_size += gti.th[i].output_size;
        //delete gq.th[i].iter;
        }
        // gq.tq.start_idx = 0;
        // gq.tq.end_idx = num_recs;
      /*  SerialBitmap* bitmap = new SerialBitmap(recs->text, level, support_array);
        bitmap->smallRecordInitialize();
        while (start_idx < end_idx) {
            //cout<<"start "<<start_idx<<" end "<<end_idx<<endl;
            char* record = recs->text + recs->rec_start_pos[start_idx];
            long length = recs->rec_length[start_idx];
            ///SerialBitmap* bitmap = new SerialBitmap(recs->text, level, support_array);
            ///bitmap->smallRecordInitialize();
            bitmap->setRecord(record);
            bitmap->setRecordLength(length);
            bitmap->indexConstruction();
           // Bitmap* bm = BitmapConstructor::construct(recs, start_idx, level, support_array);
          //  delete bm;
          ///  delete bitmap;
            ++start_idx;
         ///   output_size += bitmap->mOutputSize;
        }*/
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        exe_time.push_back(time);
        printf("The duration of small records processing is %lf %lf\n",duration/1000000, time);
        cout<<"output size is "<<output_size<<endl;
     ////   cout<<"output size is "<<bitmap->mOutputSize<<endl;
///        delete bitmap;
        /*if (qry != NULL)
            cout<<"the total number of output matches is "<<output_size<<endl;*/
    }
    if (print == true) {
        double sum_exe_time = 0.0;
        for (int i = 0; i < num_iterations; ++i) {
            sum_exe_time += exe_time[i];
            //cout<<"exe time "<<exe_time[i]<<" "<<sum_exe_time<<endl;
        }
        //cout<<"sum exe time "<<sum_exe_time<<" iterations "<<num_iterations<<endl;
        double avg_exe_time = sum_exe_time / (double)num_iterations;
        cout<<"[Performance Result]: total execution time is "<<avg_exe_time<<" seconds (avg. of 10 runs)"<<endl;
        if (qry != NULL)
            cout<<"[Number of Matches]: "<<output_size<<endl;
    }
    delete recs;
}

// records in National Statistics Postcode Lookup (NSPL) dataset contain both object records and array records, which are different
// from other datasets. Current BitmapConstructor::getIterator function generates leveled colon bitmaps for the first level of the
// record by default. In fact, if the record type is not matched, BitmapConstructor::getIterator function can be skipped, so that
// the performance can be further improved.
void testPisonSmallRecordsSpecial(char* file_path, query_callback qry = NULL, int level = MAX_LEVEL, bool support_array = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* recs = loader.loadRecords();;
    if (recs == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        string output;
        output_size = 0;
        // visit each record sequentially
        long start_idx = 0;
        long end_idx = recs->num_records;
        while (start_idx < end_idx) {
            Bitmap* bm = BitmapConstructor::construct(recs, start_idx, level, support_array);
            if (qry != NULL) {
                // check whether the first non-empty character is '{'
                char* record = recs->text + recs->rec_start_pos[start_idx];
                int idx = 0;
                while (record[idx] == ' ') ++idx;
                if (record[idx++] != '{') {
                    delete bm;
                    ++start_idx;
                    continue;
                }
                BitmapIterator* iter = BitmapConstructor::getIterator(bm);
                qry(iter, output, output_size);
                delete iter;
            }
            delete bm;
            ++start_idx;
        }
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        exe_time.push_back(time);
    }
    double sum_exe_time = 0.0;
    for (int i = 0; i < num_iterations; ++i) {
        sum_exe_time += exe_time[i];
    }
    double avg_exe_time = sum_exe_time / (double)num_iterations;
    cout<<"[Performance Result]: total execution time is "<<avg_exe_time<<" seconds (avg. of 10 runs)"<<endl;
    if (qry != NULL)
        cout<<"[Number of Matches]: "<<output_size<<endl;
    delete recs;
}

void testSbSPison(char* file_path, query_callback qry = NULL, int num_step = 5, int level = MAX_LEVEL, bool support_array = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* records = loader.loadSingleRecord();
    if (records == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> idx_construction_time;
    vector<double> query_exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        Bitmap* bm = BitmapConstructor::constructSbSPison(records, 0, num_step, level, support_array);
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        idx_construction_time.push_back(time);
        if (qry != NULL) {
            gettimeofday(&begin,NULL); 
            BitmapIterator* iter = BitmapConstructor::getIterator(bm);
            // query execution
            string output;
            output_size = 0;
            qry(iter, output, output_size);
            //cout<<"the total number of output matches is "<<output_size<<endl;
            delete iter;
            gettimeofday(&end,NULL);
            duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
            time = duration / (double) 1000000;
            query_exe_time.push_back(time);
        }
        //printf("The duration of query execution is %lf\n",duration/1000000);
        delete bm;
    }
    double sum_idx_time = 0.0;
    double sum_query_time = 0.0;
    for (int i = 0; i < num_iterations; ++i) {
        sum_idx_time += idx_construction_time[i];
        if (qry != NULL) sum_query_time += query_exe_time[i];
    }
    double avg_idx_time = sum_idx_time / (double)num_iterations;
    cout<<"[Performance Result]: index construction time is "<<avg_idx_time<<" seconds (avg. of 10 runs)"<<endl;
    double avg_query_time = 0.0;
    if (qry != NULL) {
        avg_query_time = sum_query_time / (double)num_iterations;
        cout<<"[Performance Result]: query evaluation time is "<<avg_query_time<<" seconds (avg. of 10 runs)"<<endl;
        cout<<"[Number of Matches]: "<<output_size<<endl;
    }
    double avg_tot_time = avg_idx_time + avg_query_time;
    cout<<"[Performance Result]: total execution time is "<<avg_tot_time<<" seconds (avg. of 10 runs)"<<endl;
    delete records;
}

void testPison(char* file_path, query_callback qry = NULL, int level = MAX_LEVEL, bool support_array = true, bool print = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* records = loader.loadSingleRecord();
    if (records == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 20;
    vector<double> idx_construction_time;
    vector<double> query_exe_time;
    long output_size = 0;
    for (int i = 0; i < num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        Bitmap* bm = BitmapConstructor::construct(records, 0, level, support_array);
        SerialBitmap* bitmap = (SerialBitmap*)bm;
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        cout<<"[Check] index construction time "<<time<<endl;
        cout<<"output size is "<<bitmap->mOutputSize<<endl;
        // if(i <= num_iterations) 
        idx_construction_time.push_back(time); 
        /*if (qry != NULL) {
            gettimeofday(&begin,NULL);
            BitmapIterator* iter = BitmapConstructor::getIterator(bm); //cout<<"2"<<endl;
            // query execution
            string output;
            output_size = 0;
            qry(iter, output, output_size);
            //cout<<"the total number of output matches is "<<output_size<<endl;
            delete iter;
            gettimeofday(&end,NULL);
            duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
            time = duration / (double) 1000000;
            query_exe_time.push_back(time);
        }*/
        delete bm;
        qry = NULL;
    }
    cout<<"going to print"<<endl;
    if (print == true) {
        double sum_idx_time = 0.0;
        double sum_query_time = 0.0;
        for (int i = 0; i < num_iterations; ++i) {
            sum_idx_time += idx_construction_time[i];
            if (qry != NULL) sum_query_time += query_exe_time[i];
        }
        double avg_idx_time = sum_idx_time / (double)(num_iterations);
        cout<<"[Performance Result]: index construction time is "<<avg_idx_time<<" seconds (avg. of 10 runs)"<<endl;
        double avg_query_time = 0.0;
        if (qry != NULL) {
            avg_query_time = sum_query_time / (double)num_iterations;
            cout<<"[Performance Result]: query evaluation time is "<<avg_query_time<<" seconds (avg. of 10 runs)"<<endl;
            cout<<"[Number of Matches]: "<<output_size<<endl;
        }
        double avg_tot_time = avg_idx_time + avg_query_time;
        cout<<"[Performance Result]: total execution time is "<<avg_tot_time<<" seconds (avg. of 10 runs)"<<endl;
    }
    cout<<"finished printing"<<endl;
    delete records;
    cout<<"deleted records "<<endl;
}

void testPisonParallel(char* file_path, int thread_num, parallel_query_callback qry = NULL, int level = MAX_LEVEL, bool support_array = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* records = loader.loadSingleRecord();
    if (records == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 20;
    vector<double> idx_construction_time;
    vector<double> query_exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        cout<<"bitmap constructor"<<endl;
        Bitmap* bm = BitmapConstructor::construct(records, 0, thread_num, level, support_array);
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        // cout<<"finish index construction "<<endl;
        double time = duration / (double) 1000000;
        idx_construction_time.push_back(time);
        if (qry != NULL) {
            gettimeofday(&begin,NULL);
            BitmapIterator* iter = BitmapConstructor::getIterator(bm);
            // query execution
            string output[MAX_THREAD];
            output_size = 0;
            qry(iter, output, output_size, thread_num);
            // cout<<"the total number of output matches is "<<output_size<<endl;
            delete iter;
            gettimeofday(&end,NULL);
            duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
            time = duration / (double) 1000000;
            if (i > 10) query_exe_time.push_back(time);
        }
        delete bm;
    }
    double sum_idx_time = 0.0;
    double sum_query_time = 0.0;
    for (int i = 0; i < num_iterations; ++i) {
        sum_idx_time += idx_construction_time[i];
        if (qry != NULL) sum_query_time += query_exe_time[i];
    }
    double avg_idx_time = sum_idx_time / (double)num_iterations;
    cout<<"[Performance Result]: index construction time is "<<avg_idx_time<<" seconds (avg. of 10 runs)"<<endl;
    double avg_query_time = 0.0;
    if (qry != NULL) {
        avg_query_time = sum_query_time / (double)num_iterations;
        cout<<"[Performance Result]: query evaluation time is "<<avg_query_time<<" seconds (avg. of 10 runs)"<<endl;
        cout<<"[Number of Matches]: "<<output_size<<endl;
    }
    double avg_tot_time = avg_idx_time + avg_query_time;
    cout<<"[Performance Result]: total execution time is "<<avg_tot_time<<" seconds (avg. of 10 runs)"<<endl;
    delete records;
}

// following functions are used for collecting the evaluation data in Figure 12, Figure 13 and Figure 15
void testSbSPisonSmallRecordsIndexConstructionTimeBreakdown(char* file_path) {
    cout<<"------Index Construction Time Breakdown (SbS Pison, Small Records) Begin------"<<endl;
    for (int num_step = 1; num_step <= 5; ++num_step) {
        cout<<"step 1 to step "<<num_step<<" starts"<<endl;
        testSbSPisonSmallRecords(file_path, NULL, num_step);
        cout<<"done"<<endl;
    }
    cout<<"------Index Construction Time Breakdown (SbS Pison, Small Records) End------"<<endl;
}

void testSbSPisonIndexConstructionTimeBreakdown(char* file_path) {
    cout<<"------Index Construction Time Breakdown (SbS Pison, Large Record) Begin------"<<endl;
    for (int num_step = 1; num_step <= 5; ++num_step) {
        cout<<"step 1 to step "<<num_step<<" starts"<<endl;
        testSbSPison(file_path, NULL, num_step);
        cout<<"done"<<endl;
    }
    cout<<"------Index Construction Time Breakdown (SbS Pison, Large Record) End------"<<endl;
}

void testPisonSmallRecordsIndexConstructionTime(char* file_path) {
    cout<<"------Index Construction Time Breakdown (Pison, Small Records) Begin------"<<endl;
    testPisonSmallRecords(file_path);
    cout<<"------Index Construction Time Breakdown (Pison, Small Records) End------"<<endl;
}

void testPisonIndexConstructionTime(char* file_path) {
    cout<<"------Index Construction Time Breakdown (Pison, Large Record) Begin------"<<endl;
    testPison(file_path); 
    cout<<"------Index Construction Time Breakdown (Pison, Large Record) End------"<<endl;
}

void testPisonParallelIndexConstruction(char* file_path, int thread_num) {
    cout<<"------evaluating parallel index construction on "<<file_path<<"------"<<endl;
    testPisonParallel(file_path, thread_num);
    cout<<"------finish evalating parallel index construction------"<<endl;
}

int main(int argc, char** argv) {
    if (argc < 4) {
        printf("the number of input arguments should be at least three: file_path, input_type(small (for small records), large (for large record)), query_id used in Pison paper\n");
        return -1;
    }
    char* file_path = argv[1];
    char* input_type = argv[2];
    string query_id(argv[3]);
    int thread_num = 1;
    cout<<endl;
    cout<<"------------------------------------------------------------------------------------------"<<endl;
    cout<<"[Start Evaluation]: "<<query_id<<" on file "<<file_path<<endl;
    if (strcmp(input_type, "large") == 0) {
        if (argc < 5) {
            printf("please input the number of threads for large record processing\n");
            return -1;
        }
        thread_num = atoi(argv[4]);
        // cout<<"the number of threads used for large record processing is "<<thread_num<<endl;
    }
   /* if (thread_num == 1) {
        //cout<<"warming up CPU"<<endl;
        if (strcmp(input_type, "small") == 0) {
            testPisonSmallRecords(file_path, NULL, MAX_LEVEL, true, false);
        } else {
            if (thread_num == 1)
                testPison(file_path, NULL, MAX_LEVEL, true, false);
        }
        //cout<<"finish warming up CPU"<<endl;
    }*/
    if (strcmp(input_type, "small") == 0) {
        if (query_id == "TT0") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 0, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl; 
            testPisonSmallRecords(file_path, query_tt0_small, 0, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT1") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt1_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT2") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt2_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT3") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt3_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT4") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt4_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT5") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt5_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT6") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt6_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT7") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 3);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt7_small, 3);
            //cout<<"finish query execution for small records processing"<<endl; 
        } else if (query_id == "TT8") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt8_small, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT9") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 3);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt9_small, 3);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "BB") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 2);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_bb1_small, 2);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "GMD") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 7);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_gmd1_small, 7);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "NSPL") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecordsSpecial(file_path, NULL, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecordsSpecial(file_path, query_nspl1_small, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "WM") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_wm1_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "WP") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_wp1_small, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else {
            //cout<<"getting the execution time of structural index construction"<<endl; 
            testPisonSmallRecords(file_path);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
        }
    } else if (strcmp(input_type, "large") == 0) {
        if (query_id == "TT0") {
            if (thread_num == 1)
                testPison(file_path, query_tt0_large, 1);
            else testPisonParallel(file_path, thread_num, query_tt0_large_parallel, 1);
        } else if (query_id == "TT1") {
            if (thread_num == 1)
                testPison(file_path, query_tt1_large, 2);
            else testPisonParallel(file_path, thread_num, query_tt1_large_parallel, 2);
        } else if (query_id == "TT2") {
            if (thread_num == 1)
                testPison(file_path, query_tt2_large, 2);
            else testPisonParallel(file_path, thread_num, query_tt2_large_parallel, 2);
        } else if (query_id == "TT3") {
            if (thread_num == 1)
                testPison(file_path, query_tt3_large, 2);
            else testPisonParallel(file_path, thread_num, query_tt3_large_parallel, 2);
        } else if (query_id == "TT4") {
            if (thread_num == 1)
                testPison(file_path, query_tt4_large, 2);
            else testPisonParallel(file_path, thread_num, query_tt4_large_parallel, 2);
        } else if (query_id == "TT5") {
            if (thread_num == 1)
                testPison(file_path, query_tt5_large);
            else testPisonParallel(file_path, thread_num, query_tt5_large_parallel, 2);
        } else if (query_id == "TT6") {
            if (thread_num == 1)
                testPison(file_path, query_tt6_large, 2);
            else testPisonParallel(file_path, thread_num, query_tt6_large_parallel, 2);
        } else if (query_id == "TT7") {
            if (thread_num == 1)
                testPison(file_path, query_tt7_large, 4);
            else testPisonParallel(file_path, thread_num, query_tt7_large_parallel, 4);
        } else if (query_id == "TT8") {
            if (thread_num == 1)
                testPison(file_path, query_tt8_large, 5);
            else testPisonParallel(file_path, thread_num, query_tt8_large_parallel, 5);
        } else if (query_id == "TT9") {
            if (thread_num == 1)
                testPison(file_path, query_tt9_large, 4);
            else testPisonParallel(file_path, thread_num, query_tt9_large_parallel, 4);
        } else if (query_id == "BB") {
            if (thread_num == 1)
                testPison(file_path, query_bb1_large, 4);
            else testPisonParallel(file_path, thread_num, query_bb1_large_parallel, 4);
        } else if (query_id == "GMD") {
            if (thread_num == 1)
                testPison(file_path, query_gmd1_large, 8);
            else testPisonParallel(file_path, thread_num, query_gmd1_large_parallel, 8);
        } else if (query_id == "NSPL") {
            if (thread_num == 1)
                testPison(file_path, query_nspl1_large, 4);
            else testPisonParallel(file_path, thread_num, query_nspl1_large_parallel, 4);
        } else if (query_id == "WM") {
            if (thread_num == 1)
                testPison(file_path, query_wm1_large, 3);
            else testPisonParallel(file_path, thread_num, query_wm1_large_parallel, 3);
        } else if (query_id == "WP") {
            if (thread_num == 1)
                testPison(file_path, query_wp1_large, 5);
            else testPisonParallel(file_path, thread_num, query_wp1_large_parallel, 5);
        } else {
            if (thread_num == 1)
                testPison(file_path);
            else testPisonParallel(file_path, thread_num);
        }
    }
    cout<<"[End Evaluation]: "<<query_id<<" on file "<<file_path<<endl;
    cout<<"------------------------------------------------------------------------------------------"<<endl;
    return 0;
}
