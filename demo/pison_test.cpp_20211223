#include "../src/RecordLoader.h"
#include "../src/BitmapIterator.h"
#include "../src/BitmapConstructor.h"
#include "test_queries.h"
#include "parallel_query.h"
//#include "../src/rdtsc.h"
#include <sys/time.h>
#include <sys/file.h>
#include <unordered_set>
using namespace std;

void testPisonSmallRecordsSeq(char* file_path, query_callback qry = NULL, int level = MAX_LEVEL, bool support_array = true, bool print = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* recs = loader.loadRecords();;
    if (recs == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> exe_time;
    long output_size = 0;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        string output;
        output_size = 0;
        // visit each record sequentially
        long start_idx = 0;
        long end_idx = recs->num_records;//1000;//recs->num_records;
        ///end_idx = 25;//1000;
        SerialBitmap* bitmap = new SerialBitmap(recs->text, level, support_array);
        bitmap->smallRecordInitialize();
        gettimeofday(&begin,NULL);
     ///   long start = rdtsc();
        while (start_idx < end_idx) {
            //cout<<"start "<<start_idx<<" end "<<end_idx<<endl;
            char* record = recs->text + recs->rec_start_pos[start_idx];
            long length = recs->rec_length[start_idx];
            bitmap->setRecord(record);
            bitmap->setRecordLength(length);
            bitmap->indexConstruction();
            ++start_idx;
        }
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        exe_time.push_back(time);
        printf("The duration of small records processing is %lf %lf\n",duration/1000000, time);
        cout<<"output size is "<<bitmap->mOutputSize<<" passed "<<bitmap->mPassed<<endl;
        delete bitmap;
    }
    if (print == true) {
        double sum_exe_time = 0.0;
        for (int i = 0; i < num_iterations; ++i) {
            sum_exe_time += exe_time[i];
            //cout<<"exe time "<<exe_time[i]<<" "<<sum_exe_time<<endl;
        }
        //cout<<"sum exe time "<<sum_exe_time<<" iterations "<<num_iterations<<endl;
        double avg_exe_time = sum_exe_time / (double)num_iterations;
        cout<<"[Performance Result]: total execution time is "<<avg_exe_time<<" seconds (avg. of 10 runs)"<<endl;
        if (qry != NULL)
            cout<<"[Number of Matches]: "<<output_size<<endl;
    }
    delete recs;
}

struct GlobalThreadInfo {
    pthread_t threads[MAX_THREAD];
    ThreadMetaData th[MAX_THREAD];
    // TaskQueue tq;
    Records* recs;
};

GlobalThreadInfo gti;

void* main_thread(void* arg) {
    // needs start_idx, end_idx, recs, thread_id
    ThreadMetaData md = (ThreadMetaData)(*(ThreadMetaData*)arg);
    int thread_id = md.thread_id;
    // bind CPU
    cpu_set_t mask;
    cpu_set_t get;
    CPU_ZERO(&mask);
    CPU_SET(thread_id, &mask);
    if(pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
        cout<<"CPU binding failed for thread "<<thread_id<<endl;
    struct timeval begin,end;
    double duration;
    // CPU warmup
    gettimeofday(&begin,NULL);
    while(1)
    {
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        if(duration>3000000) break;
    }
    gettimeofday(&begin,NULL);
    int start_idx = md.start_idx;
    int end_idx = md.end_idx;
    // cout<<"thread "<<thread_id<<" start_idx "<<start_idx<<" end_idx "<<end_idx<<endl;
    // TODO: remove level, support array
    int level = 100;
    bool support_array = true;
    SerialBitmap* bitmap = new SerialBitmap(gti.recs->text, level, support_array);
    // bitmap->smallRecordInitialize();
    gettimeofday(&begin,NULL);
    while (start_idx < end_idx) {
        // cout<<"thread "<<thread_id<<" start "<<start_idx<<" end "<<end_idx<<endl;
        char* record = gti.recs->text + gti.recs->rec_start_pos[start_idx];
        long length = gti.recs->rec_length[start_idx];
        bitmap->setRecord(record);
        bitmap->setRecordLength(length);
        bitmap->indexConstruction();
        ++start_idx;
    }
    gettimeofday(&end,NULL);
    duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
    double time = duration / (double) 1000000;
    printf("The duration of small records processing on %dth thread is %lf %lf\n", thread_id, duration/1000000, time);
    cout<<"output size is "<<bitmap->mOutputSize<<" passed "<<bitmap->mPassed<<endl;
    // pass the output size to the main_thread
    gti.th[thread_id].output_size = bitmap->mOutputSize;
    delete bitmap; 
    return NULL;
}

void testPisonSmallRecords(char* file_path, query_callback qry = NULL, int level = MAX_LEVEL, bool support_array = true, bool print = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* recs = loader.loadRecords();
    if (recs == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 10;
    vector<double> exe_time;
    long output_size = 0;
    int thread_num = 16;
    for (int i = 1; i <= num_iterations; ++i) {
        gettimeofday(&begin,NULL);
        string output;
        output_size = 0;
        // parallel version
        int total_rec = recs->num_records;
        int start_idx = 0;
        for (int i = 0; i < thread_num; ++i) {
            gti.th[i].thread_id = i;
            gti.th[i].start_idx = start_idx;
            if (i < thread_num - 1) {
                int next_idx = start_idx + total_rec / thread_num;
                gti.th[i].end_idx = next_idx;
                start_idx = next_idx;
            } else {
                gti.th[i].end_idx = total_rec;
            }
            cout<<i<<"th thread: start_idx "<<gti.th[i].start_idx<<" end_idx: "<<gti.th[i].end_idx<<endl;
        }
        gti.recs = recs;
        for (int i = 0; i < thread_num; ++i) {
            int rc = pthread_create(&gti.threads[i], NULL, main_thread, &gti.th[i]);
            if (rc)
            {
                cout<<"Thread Error; return code is "<<rc<<endl;
                return;
            }
        }
        for (int i = 0;i < thread_num; ++i)
        {
            int rc = pthread_join(gti.threads[i], NULL);
            if (rc)
            {
                cout<<"Thread Error; return code is "<<rc<<endl;
                return;
            }
        }
        for (int i = 0; i < thread_num; ++i) {
//        cout<<"thread i "<<output[i]<<endl;
        //output[i] = gq.th[i].output;
            output_size += gti.th[i].output_size;
        //delete gq.th[i].iter;
        }
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        cout<<"total time "<<time<<endl;
        // visit each record sequentially
        /*long start_idx = 0;
        long end_idx = recs->num_records;//1000;//recs->num_records;
        ///end_idx = 25;//1000;
        SerialBitmap* bitmap = new SerialBitmap(recs->text, level, support_array);
        bitmap->smallRecordInitialize();
        gettimeofday(&begin,NULL);
     ///   long start = rdtsc();
        while (start_idx < end_idx) {
            //cout<<"start "<<start_idx<<" end "<<end_idx<<endl;
            char* record = recs->text + recs->rec_start_pos[start_idx];
            long length = recs->rec_length[start_idx];
            bitmap->setRecord(record);
            bitmap->setRecordLength(length);
            bitmap->indexConstruction();
            ++start_idx;
        }
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        exe_time.push_back(time);
        printf("The duration of small records processing is %lf %lf\n",duration/1000000, time);
        cout<<"output size is "<<bitmap->mOutputSize<<" passed "<<bitmap->mPassed<<endl;
        delete bitmap;*/
        cout<<"final output size "<<output_size<<endl;
    }
    if (print == true) {
        double sum_exe_time = 0.0;
        for (int i = 0; i < num_iterations; ++i) {
            sum_exe_time += exe_time[i];
            //cout<<"exe time "<<exe_time[i]<<" "<<sum_exe_time<<endl;
        }
        //cout<<"sum exe time "<<sum_exe_time<<" iterations "<<num_iterations<<endl;
        double avg_exe_time = sum_exe_time / (double)num_iterations;
        cout<<"[Performance Result]: total execution time is "<<avg_exe_time<<" seconds (avg. of 10 runs)"<<endl;
        if (qry != NULL)
            cout<<"[Number of Matches]: "<<output_size<<endl;
    }
    delete recs;
}

void testPison(char* file_path, query_callback qry = NULL, int level = MAX_LEVEL, bool support_array = true, bool print = true) {
    struct timeval begin,end;
    double duration;
    RecordLoader loader(file_path);
    Records* records = loader.loadSingleRecord();
    if (records == NULL) {
        cout<<"record loading fails."<<endl;
        return;
    }
    int num_iterations = 20;
    vector<double> idx_construction_time;
    vector<double> query_exe_time;
    long output_size = 0;
    for (int i = 0; i < num_iterations; ++i) {
        char* record = records->text + records->rec_start_pos[0];
        SerialBitmap* bitmap = new SerialBitmap(record, level, support_array);
        bitmap->setRecordLength(strlen(record));
        gettimeofday(&begin,NULL);
        bitmap->indexConstruction();
        /*Bitmap* bm = BitmapConstructor::construct(records, 0, level, support_array);
        SerialBitmap* bitmap = (SerialBitmap*)bm;*/
        /*char* record = records->text + records->rec_start_pos[0];
        long length = records->rec_length[0];
        /// SerialBitmap* bm = new SerialBitmap(record, level, support_array);
        SerialBitmap bm;//(record, level, support_array)
        bm.setData(record, level);
        bm.setRecordLength(length);

        bm.indexConstruction();*/
        gettimeofday(&end,NULL);
        duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
        double time = duration / (double) 1000000;
        cout<<"[Check] index construction time "<<time<<endl;
        cout<<"output size is "<<bitmap->mOutputSize<<endl;
        // if(i <= num_iterations) 
        idx_construction_time.push_back(time); 
        /*if (qry != NULL) {
            gettimeofday(&begin,NULL);
            BitmapIterator* iter = BitmapConstructor::getIterator(bm); //cout<<"2"<<endl;
            // query execution
            string output;
            output_size = 0;
            qry(iter, output, output_size);
            //cout<<"the total number of output matches is "<<output_size<<endl;
            delete iter;
            gettimeofday(&end,NULL);
            duration=1000000*(end.tv_sec-begin.tv_sec)+end.tv_usec-begin.tv_usec;
            time = duration / (double) 1000000;
            query_exe_time.push_back(time);
        }*/
        delete bitmap;
        qry = NULL;
    }
    cout<<"going to print"<<endl;
    if (print == true) {
        double sum_idx_time = 0.0;
        double sum_query_time = 0.0;
        for (int i = 0; i < num_iterations; ++i) {
            sum_idx_time += idx_construction_time[i];
            if (qry != NULL) sum_query_time += query_exe_time[i];
        }
        double avg_idx_time = sum_idx_time / (double)(num_iterations);
        cout<<"[Performance Result]: index construction time is "<<avg_idx_time<<" seconds (avg. of 10 runs)"<<endl;
        double avg_query_time = 0.0;
        if (qry != NULL) {
            avg_query_time = sum_query_time / (double)num_iterations;
            cout<<"[Performance Result]: query evaluation time is "<<avg_query_time<<" seconds (avg. of 10 runs)"<<endl;
            cout<<"[Number of Matches]: "<<output_size<<endl;
        }
        double avg_tot_time = avg_idx_time + avg_query_time;
        cout<<"[Performance Result]: total execution time is "<<avg_tot_time<<" seconds (avg. of 10 runs)"<<endl;
    }
    cout<<"finished printing"<<endl;
    delete records;
    cout<<"deleted records "<<endl;
}

int main(int argc, char** argv) {
    if (argc < 4) {
        printf("the number of input arguments should be at least three: file_path, input_type(small (for small records), large (for large record)), query_id used in Pison paper\n");
        return -1;
    }
    char* file_path = argv[1];
    char* input_type = argv[2];
    string query_id(argv[3]);
    int thread_num = 1;
    cout<<endl;
    cout<<"------------------------------------------------------------------------------------------"<<endl;
    cout<<"[Start Evaluation]: "<<query_id<<" on file "<<file_path<<endl;
    if (strcmp(input_type, "large") == 0) {
        if (argc < 5) {
            printf("please input the number of threads for large record processing\n");
            return -1;
        }
        thread_num = atoi(argv[4]);
        // cout<<"the number of threads used for large record processing is "<<thread_num<<endl;
    }
   /* if (thread_num == 1) {
        //cout<<"warming up CPU"<<endl;
        if (strcmp(input_type, "small") == 0) {
            testPisonSmallRecords(file_path, NULL, MAX_LEVEL, true, false);
        } else {
            if (thread_num == 1)
                testPison(file_path, NULL, MAX_LEVEL, true, false);
        }
        //cout<<"finish warming up CPU"<<endl;
    }*/
    if (strcmp(input_type, "small") == 0) {
        if (query_id == "TT0") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 0, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl; 
            testPisonSmallRecords(file_path, query_tt0_small, 0, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT1") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt1_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT2") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt2_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT3") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt3_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT4") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt4_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT5") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt5_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT6") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt6_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT7") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 3);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt7_small, 3);
            //cout<<"finish query execution for small records processing"<<endl; 
        } else if (query_id == "TT8") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt8_small, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "TT9") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 3);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_tt9_small, 3);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "BB") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 2);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_bb1_small, 2);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "GMD") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 7);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_gmd1_small, 7);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "NSPL") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecordsSpecial(file_path, NULL, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_nspl1_small, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "WM") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 1, false);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_wm1_small, 1, false);
            //cout<<"finish query execution for small records processing"<<endl;
        } else if (query_id == "WP") {
            //cout<<"getting the execution time of structural index construction"<<endl;
            //testPisonSmallRecords(file_path, NULL, 4);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
            //cout<<"starting query execution for small records processing"<<endl;
            testPisonSmallRecords(file_path, query_wp1_small, 4);
            //cout<<"finish query execution for small records processing"<<endl;
        } else {
            //cout<<"getting the execution time of structural index construction"<<endl; 
            testPisonSmallRecords(file_path);
            //cout<<"finish getting the execution time of structural index construction"<<endl;
        }
    } else if (strcmp(input_type, "large") == 0) {
        if (query_id == "TT0") {
            if (thread_num == 1)
                testPison(file_path, query_tt0_large, 1);
        } else if (query_id == "TT1") {
            if (thread_num == 1)
                testPison(file_path, query_tt1_large, 2);
        } else if (query_id == "TT2") {
            if (thread_num == 1)
                testPison(file_path, query_tt2_large, 2);
        } else if (query_id == "TT3") {
            if (thread_num == 1)
                testPison(file_path, query_tt3_large, 2);
        } else if (query_id == "TT4") {
            if (thread_num == 1)
                testPison(file_path, query_tt4_large, 2);
        } else if (query_id == "TT5") {
            if (thread_num == 1)
                testPison(file_path, query_tt5_large);
        } else if (query_id == "TT6") {
            if (thread_num == 1)
                testPison(file_path, query_tt6_large, 2);
        } else if (query_id == "TT7") {
            if (thread_num == 1)
                testPison(file_path, query_tt7_large, 4);
        } else if (query_id == "TT8") {
            if (thread_num == 1)
                testPison(file_path, query_tt8_large, 5);
        } else if (query_id == "TT9") {
            if (thread_num == 1)
                testPison(file_path, query_tt9_large, 4);
        } else if (query_id == "BB") {
            if (thread_num == 1)
                testPison(file_path, query_bb1_large, 4);
        } else if (query_id == "GMD") {
            if (thread_num == 1)
                testPison(file_path, query_gmd1_large, 8);
        } else if (query_id == "NSPL") {
            if (thread_num == 1)
                testPison(file_path, query_nspl1_large, 4);
        } else if (query_id == "WM") {
            if (thread_num == 1)
                testPison(file_path, query_wm1_large, 3);
        } else if (query_id == "WP") {
            if (thread_num == 1)
                testPison(file_path, query_wp1_large, 5);
        } else {
            if (thread_num == 1)
                testPison(file_path);
        }
    }
    cout<<"[End Evaluation]: "<<query_id<<" on file "<<file_path<<endl;
    cout<<"------------------------------------------------------------------------------------------"<<endl;
    return 0;
}
