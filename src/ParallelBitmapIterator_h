#ifndef PARALLELBITMAPITERATOR_H
#define PARALLELBITMAPITERATOR_H

#include "ParallelBitmapConstructor.h"
#include "BitmapIterator.h"
#include <string.h>
#include <unordered_set>
using namespace std;

#define MAX_RECORD_SIZE 1000000

class ParallelBitmapIterator : public BitmapIterator {
  private:
    ParallelBitmap* mParallelBitmap;
    IterCtxInfo mCtxInfo[MAX_LEVEL];
    bool mPosArrAlloc[MAX_LEVEL];
    int mCurLevel;
    int mTopLevel;
    char mKey[MAX_FIELD_SIZE];
    unsigned long* quotes[MAX_THREAD];
    // improve the performance when iterating leveled bitmap generated by multiple threads
    // mPrevThreadId: thread which generates leveled bitmap indexes for the previous word
    int mPrevThreadId;
    // TODO: remove this member variable and parallelize dominating array automatically
    bool mParallelDomArray;
    bool mCopiedIterator;
//    int mPrevStartId;
//    int mPrevEndId;
    
  public:
    ParallelBitmapIterator() {}
    
    ParallelBitmapIterator(ParallelBitmap* pbm) {
        mParallelBitmap = pbm;
        mCurLevel = -1;
        mTopLevel = -1;
        mPrevThreadId = 0;
        mParallelDomArray = false;
        mCopiedIterator = false;
        for (int i = 0; i < MAX_LEVEL; ++i) {
            mPosArrAlloc[i] = false;
        }
        //mPrevStartId = -1;
        //mPrevEndId = -1;
        gatherParallelBitmapInfo();
        // initially, iterator points to the first level of the record
        down(); 
    }

    ~ParallelBitmapIterator() {
        //cout<<"copied iterator "<<mCopiedIterator<<endl;
        //if (mCopiedIterator == false) cout<<"***not copied iterator"<<endl;
        /*if (mCtxInfo[mTopLevel + 1].positions) {
            cout<<"mtop level release "<<mTopLevel<<endl;
            free(mCtxInfo[mTopLevel + 1].positions);
            mCtxInfo[mTopLevel + 1].positions = NULL;
        }*/
        for (int i = mTopLevel + 1; i < MAX_LEVEL; ++i) {
            if (mPosArrAlloc[i] == true) {
                // cout<<" release level "<<i<<" copied iterator "<<mCopiedIterator<<endl;
                free(mCtxInfo[i].positions);
                // cout<<" release level okay "<<i<<endl;
                mCtxInfo[i].positions = NULL;
            } else {
                break;
            }
        }
        //cout<<"release all"<<endl;
    }

    // Creates a copy of iterator. Often used for parallel querying.
    ParallelBitmapIterator* copyIterator();
    // Moves back to the object or array which contains the current nested record.
    // Often used when the current nested record has been processed.
    // Valid except for the first level of the record.
    bool up();
    // Moves to the start of the nested object or array.
    // Gets all colon or comma positions from leveled bitmap indexes for current nested record.
    // Valid if we are at { or [.
    bool down();
    // Whether the iterator points to an object.
    bool isObject();
    // Whether the iterator points to an array.
    bool isArray();
    // Moves iterator to the next array item.
    bool moveNext();
    // Returns the size of the current key field.
    int keySize();
    // Gets the content of the current key field.
    char* getKey();
    // Moves to the corresponding key field inside the current object.
    bool moveToKey(char* key);
    // Moves to the corresponding key fields inside the current object, returns the current key name.
    // After this operation, the current key field will be removed from key_set.
    char* moveToKey(unordered_set<char*>& key_set);
    // Returns the number of elements inside current array.
    int numArrayElements();
    // If the current record is an array, moves to an item based on index.
    // Returns false if the index is out of the boundary.
    bool moveToIndex(int index);
    // Gets the content of the current value inside an object or array.
    char* getValue();
    // TODO: remove this member function and parallelize dominating array automatically
    bool parallelDomArrayFlag(bool flag) {
        mParallelDomArray = flag;
        //if (flag == true) cout<<"&& set flag "<<endl;
    }
  
  private:
    // this operation can further improve the performance.
    void gatherParallelBitmapInfo();
    // get positions of all colons between start_idx and end_idx from input stream
    // prev_thread_id: thread which generates leveled bitmap indexes for the previous word
    void generateColonPositions(long start_pos, long end_pos, int level, long* colon_positions, long& top_colon_positions);
    // get positions of all commas between start_idx and end_idx from input stream
    // prev_thread_id: thread which generates leveled bitmap indexes for the previous word
    void generateCommaPositions(long start_pos, long end_pos, int level, long* comma_positions, long& top_comma_positions);
    // generate comma positions in parallel (used for generating positions of dominating array)
    void generateCommaPositionsParallel(long start_pos, long end_pos, int level, long* comma_positions, long& top_comma_positions);
    // prev_thread_id: thread which generates leveled bitmap indexes for the previous word 
    bool findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos);
};
#endif
