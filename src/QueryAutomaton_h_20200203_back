#include <string.h>
using namespace std;

#define MAX_STATES 100
#define MAX_STACK_DEPTH 100
#define MAX_TRANS_STRING 50

#define OBJECT 1
#define ARRAY 2
#define KEY_OBJECT 3
#define KEY_ARRAY 4
#define KEY 5
#define OUTPUT_CANDIDATE 6
#define GENERAL_OUTPUT 7
#define INVALID -1

typedef struct TransStrInfo {
    char* key;
    int key_len;
    int type;
    int next_state;
} TransStrInfo;

typedef struct StateTransEle {
    TransStrInfo t_str_info[MAX_TRANS_STRING];
    int num_trans_str;
    bool matched_state;
} StateTransEle;
    
typedef struct DFA {
    StateTransEle trans_ele[MAX_STATES];
} DFA;

typedef struct Stack {
    int stack[MAX_STACK_DEPTH];
    int num_stack_ele;
} Stack;

class QueryAutomaton {
  public:
    QueryAutomaton() {
        mStack.num_stack_ele = 0;
        mCurState = 1;
    }

    void init() {
        mStack.num_stack_ele = 0;
        mCurState = 1; 
    }

    void addTransEle(int start_state, char* key, int type, int next_state, bool matched_state) {
        int start_idx = start_state - 1;
        int next_idx = next_state - 1;
        TransStrInfo t_str_info;
        t_str_info.key = key;
        t_str_info.key_len = strlen(key);
        t_str_info.type = type;
        t_str_info.next_state = next_state;
        int num_trans_str = mDfa.trans_ele[start_idx].num_trans_str;
        mDfa.trans_ele[start_idx].t_str_info[num_trans_str++] = t_str_info;
        mDfa.trans_ele[start_idx].num_trans_str = num_trans_str;
        // mDfa.trans_ele[start_idx].next_state = next_state;
        mDfa.trans_ele[start_idx].matched_state = matched_state;
    }

    bool hasMatchedKeyType(int type) {
//        cout<<"check type "<<type<<" state "<<mCurState<<endl;
        int cur_idx = mCurState - 1;
        StateTransEle trans_ele = mDfa.trans_ele[cur_idx];
        int num_trans_str = trans_ele.num_trans_str;
        int i = 0;
        int next_state = 0;
        while (i < num_trans_str) {
            if (trans_ele.t_str_info[i].type == type) {
    //            cout<<"matched type "<<type<<endl;
                return true;
            }
            ++i;
        }
        return false; 
    }

    bool hasMatchedKeyLen(int key_len) {
        int cur_idx = mCurState - 1;
        StateTransEle trans_ele = mDfa.trans_ele[cur_idx];
        int num_trans_str = trans_ele.num_trans_str;
        int i = 0;
        int next_state = 0;
        while (i < num_trans_str) {
            if (trans_ele.t_str_info[i].key_len == key_len) {
                return true;
            }
            ++i;
        }
        return false;
    }

    int getNextState(char *key, int key_len, int type) {
    //    cout<<"check next state "<<key<<" "<<key_len<<" "<<type<<endl;
        int cur_idx = mCurState - 1;
        StateTransEle trans_ele = mDfa.trans_ele[cur_idx];
        int num_trans_str = trans_ele.num_trans_str;
        int i = 0;
        int next_state = 0;
        while (i < num_trans_str) {
            if (trans_ele.t_str_info[i].type == type 
                && trans_ele.t_str_info[i].key_len == key_len 
                && memcmp(trans_ele.t_str_info[i].key, key, key_len) == 0) {
                next_state = trans_ele.t_str_info[i].next_state;
                return next_state;
            }
            ++i;
        }
        return next_state;
    }

    int getNextStateNoKey(int type) {
  //      cout<<"check next state no key "<<type<<endl;
        int cur_idx = mCurState - 1;
        StateTransEle trans_ele = mDfa.trans_ele[cur_idx];
        int num_trans_str = trans_ele.num_trans_str;
        int i = 0;
        int next_state = 0;
        while (i < num_trans_str) {
            if (trans_ele.t_str_info[i].type == type) {
                next_state = trans_ele.t_str_info[i].next_state;
                return next_state;
            }
            ++i;
        }
        return next_state;
    }

    void setCurState(int cur_state) {
        mCurState = cur_state;
    }

    int getType(int state) {
        if (state > 0 && mDfa.trans_ele[state - 1].matched_state == true)
            return OUTPUT_CANDIDATE;
        return GENERAL_OUTPUT;
    }

    void pushStack(int next_state) {
        //if (mStack.num_stack_ele < MAX_STACK_DEPTH)
            mStack.stack[mStack.num_stack_ele++] = mCurState;
//        cout<<"push state "<<mCurState<<endl;
        mCurState = next_state;
    }

    int popStack() {
//        cout<<"pop stack "<<mCurState<<" "<<mStack.stack[mStack.num_stack_ele]<<endl;
        //if (mStack.num_stack_ele > 0)
        mCurState = mStack.stack[--mStack.num_stack_ele];
        return mCurState;
        //`return INVALID;
    }

    int getStackSize() {
        return mStack.num_stack_ele;
    }
   
  public:
    DFA mDfa;
    int mCurState;
    Stack mStack;
};
