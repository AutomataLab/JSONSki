#include "SerialBitmap.h"
#include <immintrin.h>

#include <emmintrin.h>
#include <string.h>

#include <sys/time.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <pthread.h>
#include <malloc.h>
#include <sys/time.h>
#include <sys/file.h>
#include <unistd.h>
#include <sched.h>
#include <unordered_map>
//#include "QueryAutomaton.h"
//#include "query_automaton.h"
//#include "lexing.h"
// #include "streaming_automaton.h"

using namespace std;

SerialBitmap::SerialBitmap() {

}

SerialBitmap::SerialBitmap(char* record, int depth, bool array_supported) {
    //this->mMap[10] = 0;
    //this->map[10] = 0;
    this->mRecord = record;
    this->mDepth = depth;
    this->mQuoteBitmap = NULL;
    /*this->mEscapeBitmap = NULL;
    this->mColonBitmap = NULL;
    this->mCommaBitmap = NULL;
    this->mStrBitmap = NULL;
    this->mLbraceBitmap = NULL;
    this->mRbraceBitmap = NULL;
    this->mLbracketBitmap = NULL;
    this->mRbracketBitmap = NULL;*/
    /*for (int i = 0; i <= depth; ++i) {
        this->mLevColonBitmap[i] = NULL;
        this->mLevCommaBitmap[i] = NULL;
    }
    this->mArraySupported = array_supported;*/
    this->mOutputSize = 0;
    qa.init();
    generateAutomaton(qa);
//    qa.generateAutomaton();
    mText = new char[90000];
}

void SerialBitmap::freeMemory()
{
    /*for(int m = 0; m <= mDepth; m++){
        if (mLevColonBitmap[m]) {
            free(mLevColonBitmap[m]);
            mLevColonBitmap[m] = NULL;
        }
        if (mLevCommaBitmap[m]) {
            free(mLevCommaBitmap[m]);
            mLevCommaBitmap[m] = NULL;
        }
    }*/
    /*if (mQuoteBitmap) {
        free(mQuoteBitmap);
        mQuoteBitmap = NULL;
//        cout<<"freed quote bitmap"<<endl;
    }*/
    if (mText) {
        free(mText);
        mText = NULL;
    }
   // cout<<"quote"<<endl;
    /*if (mEscapeBitmap) {
        free(mEscapeBitmap);
        mEscapeBitmap = NULL;
    }
   // cout<<"escape"<<endl;
    if (mStrBitmap) {
        free(mStrBitmap);
        mStrBitmap = NULL;
    }
   // cout<<"str"<<endl;
    if (mColonBitmap) {
        free(mColonBitmap);
        mColonBitmap = NULL;
    }
   // cout<<"colon"<<endl;
    if (mCommaBitmap) {
        free(mCommaBitmap);
        mCommaBitmap = NULL;
    }
   // cout<<"comma"<<endl;
    if (mLbraceBitmap) {
        free(mLbraceBitmap);
        mLbraceBitmap = NULL;
    }
   // cout<<"left brace"<<endl;
    if (mRbraceBitmap) {
        free(mRbraceBitmap);
        mRbraceBitmap = NULL;
    }
   // cout<<"right brace"<<endl;
    if (mLbracketBitmap) {
        free(mLbracketBitmap);
        mLbracketBitmap = NULL;
    }
   // cout<<"left bracket "<<endl;
    if (mRbracketBitmap) {
        free(mRbracketBitmap);
        mRbracketBitmap = NULL;
    }*/
   // cout<<"right bracket"<<endl;
}

SerialBitmap::~SerialBitmap()
{
    freeMemory();
   /// cout<<"memory released "<<endl;
}

void SerialBitmap::setRecord(char* record) {
    mRecord = record;
}

void SerialBitmap::smallRecordInitialize() {
    /*int max_size = 1000000;
    if (!mQuoteBitmap) {
        //mQuoteBitmap = (unsigned long*)malloc(2 * sizeof(unsigned long));
        mQuoteBitmap = (unsigned long*)malloc(max_size * sizeof(unsigned long)); 
    }*/
}

void SerialBitmap::setRecordLength(long length) {
    this->mRecordLength = length;
    this->mNumTmpWords = length / 32;
    this->mNumWords = length / 64;
    //this->mQuoteBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    // allocate memory space for saving temporary results
    /*if (!mQuoteBitmap) {
        //mQuoteBitmap = (unsigned long*)malloc(2 * sizeof(unsigned long));
        mQuoteBitmap = (unsigned long*)malloc(16 * mNumWords * sizeof(unsigned long));
    }*/
    /*if (!mColonBitmap) {
        mColonBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }
    if (!mCommaBitmap) {
        mCommaBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }
    if (!mEscapeBitmap) {
        mEscapeBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }
    if (!mStrBitmap) {
        mStrBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }
    if (!mLbraceBitmap) {
        mLbraceBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }
    if (!mRbraceBitmap) {
        mRbraceBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }
    if (!mLbracketBitmap) {
        mLbracketBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }
    if (!mRbracketBitmap) {
        mRbracketBitmap = (unsigned long*)malloc((mNumWords) * sizeof(unsigned long));
    }*/
}

__attribute__((always_inline)) bool SerialBitmap::findFieldQuotePos2(long colon_pos, long& start_pos, long& end_pos) {
    end_pos = colon_pos - 1;
    while (mRecord[end_pos] == ' ') --end_pos;
    //cout<<"end quote pos "<<end_pos<<" "<<mRecord[end_pos]<<endl;
    long w_id = end_pos / 64;
    start_pos = 0;
    int offset = end_pos % 64;
    unsigned long mask = (1UL << offset);
    unsigned long mask1 = ~mask;
    mask = mask ^ (mask - 1);
    mask = mask & mask1;
    unsigned long cur_quote_bit = this->mQuoteBitmap[w_id] & mask;
    if (!cur_quote_bit) {
        cur_quote_bit = this->mQuoteBitmap[w_id - 1];
        --w_id;
    }
    int first_lead_zero = __builtin_clzll(cur_quote_bit);
    offset = 64 - first_lead_zero;
    start_pos = w_id * 64 + offset - 1;
    return true;
}

bool SerialBitmap::findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos, unsigned long& quote_bit) {
    end_pos = colon_pos - 1;
    while (mRecord[end_pos] == ' ') --end_pos;
    long w_id = colon_pos / 64;
    start_pos = 0;
    unsigned long cur_quote_bit = quote_bit;
    if (!quote_bit) {
        cur_quote_bit = this->mQuoteBitmap[w_id - 1];
        --w_id;
    }
    int first_lead_zero = __builtin_clzll(cur_quote_bit);
    int offset = 64 - first_lead_zero;
    start_pos = w_id * 64 + offset - 1;
  //  cout<<"start pos "<<start_pos<<" end pos "<<end_pos<<endl;
 /*   long w_id = colon_pos/64;
   // long offset = colon_pos%64;
   // long start_quote = 0;
  //  long end_quote = 0;
    start_pos = 0; end_pos = 0;
    // long cur_w_id = w_id;
    if (quote_bit) {
        unsigned long cur_quote_bit = quote_bit;
        int first_lead_zero = __builtin_clzll(cur_quote_bit);
        int offset = 64 - first_lead_zero;
        end_pos = w_id * 64 + offset - 1;
        if (first_lead_zero >= 63) cur_quote_bit = 0;
        else cur_quote_bit = cur_quote_bit <<(1 + first_lead_zero);
        if (cur_quote_bit != 0) {
            int next_offset = 64 - __builtin_clzll(cur_quote_bit) - first_lead_zero - 1;
            start_pos = w_id * 64 + next_offset - 1;
  //          bitset<64> testt(cur_quote_bit);
  //          cout<<"same word for start pos "<<testt<<" "<<first_lead_zero<<endl;
        } else {
            unsigned long prev_quote_bit = this->mQuoteBitmap[w_id - 1];
            first_lead_zero = __builtin_clzll(prev_quote_bit);
            offset = 64 - first_lead_zero;
            start_pos = (w_id - 1) * 64 + offset - 1;
      //      cout<<"prev word for start "<<endl; 
        }
    } else {
        // get start and end quote from previous word
        unsigned long prev_quote_bit = this->mQuoteBitmap[w_id - 1];
        int first_lead_zero = __builtin_clzll(prev_quote_bit);
        int offset = 64 - first_lead_zero;
        end_pos = (w_id - 1) * 64 + offset - 1;
        prev_quote_bit = prev_quote_bit << (1 + first_lead_zero);
        int next_offset = 64 - __builtin_clzll(prev_quote_bit) - first_lead_zero - 1;  
        start_pos = (w_id - 1) * 64 + next_offset - 1; 
   //     cout<<"previous for all "<<endl;
    }*/
//    bitset<64> test(1<<64);
 //   cout<<"test "<<test<<endl;
//    cout<<"w_id "<<w_id<<"start pos "<<start_pos<<" "<<end_pos<<" "<<substring_200(mRecord + start_pos + 1, 0, end_pos - start_pos - 1)<<endl;
///    cout<<"function :"<<endl;
   /* while (cur_w_id >= 0)
    {
        unsigned long quotebit = this->mQuoteBitmap[cur_w_id];
        if (cur_w_id == w_id) {
            quotebit = quotebit & (colon_bit ^ (colonbit - 1));
        }
        unsigned long offset = w_id * 64 + __builtin_ctzll(quotebit);
        while (quotebit && offset < colon_pos)
        {
            if (end_pos != 0)
            {
                start_quote = offset;
   ///             cout<<"again "<<offset<<endl;
            }
            else if(start_quote == 0)
            {
                start_quote = offset;
            }
            else if(end_quote == 0)
            {
                end_quote = offset;
            }
            else
            {
                start_quote = end_quote;
                end_quote = offset;
            }
            quotebit = quotebit & (quotebit - 1);
            offset = w_id * 64 + __builtin_ctzll(quotebit); 
        }
        if(start_quote != 0 && end_quote == 0)
        {
            end_quote = start_quote;
            start_quote = 0;
            end_pos = end_quote;
        }
        else if(start_quote != 0 && end_quote != 0)
        {
            start_pos = start_quote;
            end_pos = end_quote;
            // bitset<64> tempbit(quotebit);
            // cout<<"temp bit "<<tempbit<<endl;
           // this->mQuoteBitmap[w_id] = this->mQuoteBitmap[w_id] & (~(quotebit ^ (quotebit - 1)));
            return true;
        }
        --cur_w_id;
      ///  cout<<"w id "<<endl;
    }*/
    return true;
}

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "routes", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "bounds", KEY_OBJECT, 16, false);
    qa.addTransEle(16, "northeast", KEY_OBJECT, 27, false);
    //qa.addTransEle(16, "southwest", KEY_OBJECT, 32, false);
    qa.addTransEle(27, "lat", KEY, 28, false);
    qa.addTransEle(28, "", OUTPUT_CANDIDATE, 28, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "entities", KEY_OBJECT, 4, false);
    qa.addTransEle(3, "fake1", KEY, 5, false);
    qa.addTransEle(3, "fake2", KEY, 6, false);
    qa.addTransEle(3, "fake3", KEY, 7, false);
    qa.addTransEle(3, "fake4", KEY, 8, false);
    qa.addTransEle(3, "fake5", KEY, 9, false);
    qa.addTransEle(3, "id", KEY, 10, false);
    qa.addTransEle(3, "id_str", KEY, 11, false);
    qa.addTransEle(3, "favourites_count", KEY, 12, false);
    qa.addTransEle(4, "urls", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "url", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(10, "", OUTPUT_CANDIDATE, 10, true);
    qa.addTransEle(11, "", OUTPUT_CANDIDATE, 11, true);
    qa.addTransEle(12, "", OUTPUT_CANDIDATE, 12, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "fcategoryPath", KEY_ARRAY, 5, false);
    qa.addTransEle(4, "orderable", KEY, 9, false);
    qa.addTransEle(4, "fdepartmentId", KEY, 10, false);
    qa.addTransEle(4, "furl", KEY, 11, false);
    qa.addTransEle(4, "fsecondaryMarket", KEY, 12, false);
    qa.addTransEle(4, "fshortDescription", KEY, 13, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "", OBJECT, 6, false);
    //qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(6, "name", KEY, 8, false);
    qa.addTransEle(6, "same", KEY, 15, false);
    qa.addTransEle(6, "same1", KEY, 16, false);
    // qa.addTransEle(6, "same2", KEY, 17, false)
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(8, "", OUTPUT_CANDIDATE, 8, true);
    qa.addTransEle(9, "", OUTPUT_CANDIDATE, 9, true);
    qa.addTransEle(10, "", OUTPUT_CANDIDATE, 10, true);
    qa.addTransEle(11, "", OUTPUT_CANDIDATE, 11, true);
    qa.addTransEle(12, "", OUTPUT_CANDIDATE, 12, true);
    qa.addTransEle(13, "", OUTPUT_CANDIDATE, 13, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "routes", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "fake1", KEY, 15, false);
    qa.addTransEle(5, "bounds", KEY_OBJECT, 16, false);
    qa.addTransEle(5, "fake3", KEY_ARRAY, 17, false);
    qa.addTransEle(5, "fake4", KEY_ARRAY, 18, false);
    qa.addTransEle(5, "fake5", KEY_ARRAY, 19, false);
    qa.addTransEle(5, "fake6", KEY_ARRAY, 20, false);

    qa.addTransEle(5, "legs", KEY_ARRAY, 6, false);
    qa.addTransEle(6, "", OBJECT, 7, false);
    qa.addTransEle(7, "distance", KEY_OBJECT, 29, false);
    qa.addTransEle(7, "steps", KEY_ARRAY, 8, false);
    qa.addTransEle(8, "", OBJECT, 9, false);
    qa.addTransEle(9, "distance", KEY_OBJECT, 10, false);
    qa.addTransEle(9, "fake1", KEY, 21, false);
    qa.addTransEle(9, "fake2", KEY_ARRAY, 22, false);
    qa.addTransEle(9, "fake3", KEY, 23, false);
    qa.addTransEle(9, "fake1", KEY, 24, false);
    qa.addTransEle(9, "fake2", KEY_ARRAY, 25, false);
    qa.addTransEle(9, "fake3", KEY, 26, false);

    qa.addTransEle(10, "text", KEY, 11, false);
    qa.addTransEle(10, "value", KEY, 12, false);
    qa.addTransEle(11, "", OUTPUT_CANDIDATE, 11, true);
    qa.addTransEle(12, "", OUTPUT_CANDIDATE, 12, true);
    qa.addTransEle(16, "northeast", KEY_OBJECT, 27, false);
    qa.addTransEle(16, "southwest", KEY_OBJECT, 32, false);
    qa.addTransEle(27, "lat", KEY, 28, false);
    qa.addTransEle(28, "", OUTPUT_CANDIDATE, 28, true);
    qa.addTransEle(29, "distance", KEY_OBJECT, 30, false);
    qa.addTransEle(30, "text", KEY, 31, false);
    qa.addTransEle(31, "", OUTPUT_CANDIDATE, 31, true);
    qa.addTransEle(32, "lng", KEY, 33, false);
    qa.addTransEle(33, "", OUTPUT_CANDIDATE, 33, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "entities", KEY_OBJECT, 4, false);
    qa.addTransEle(3, "id", KEY, 8, false);
    qa.addTransEle(4, "urls", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "indices", KEY_ARRAY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(8, "", OUTPUT_CANDIDATE, 8, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "entities", KEY_OBJECT, 3, false);
    qa.addTransEle(2, "id", KEY, 7, false);
    qa.addTransEle(3, "urls", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "indices", KEY_ARRAY, 6, false);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    // qa.addTransEle(2, "entities", KEY_OBJECT, 3, false);
    qa.addTransEle(2, "id", KEY, 6, false);
    qa.addTransEle(2, "text", KEY, 7, false);
    qa.addTransEle(3, "urls", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "indices", KEY_ARRAY, 6, false);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
  //  qa.addTransEle(3, "id", KEY, 8, false);
    qa.addTransEle(3, "favorite_count", KEY, 8, false);
    qa.addTransEle(3, "entities", KEY_OBJECT, 4, false);
  //  qa.addTransEle(3, "favorite_count", KEY, 8, false);
    qa.addTransEle(4, "urls", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "url", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(8, "", OUTPUT_CANDIDATE, 8, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
  //  qa.addTransEle(3, "id", KEY, 8, false);
    ///qa.addTransEle(3, "favorite_count", KEY, 8, false);
    qa.addTransEle(3, "user", KEY_OBJECT, 4, false);
  //  qa.addTransEle(3, "favorite_count", KEY, 8, false);
    qa.addTransEle(4, "id", KEY, 5, false);
    qa.addTransEle(4, "lang", KEY, 6, false);
   // qa.addTransEle(6, "url", KEY, 7, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "entities", KEY_OBJECT, 3, false);
    qa.addTransEle(2, "id", KEY, 7, false);
    qa.addTransEle(3, "urls", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "url", KEY, 6, false);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "entities", KEY_OBJECT, 4, false);
    qa.addTransEle(3, "user", KEY_OBJECT, 8, true);
    qa.addTransEle(3, "user_mentions", KEY_ARRAY, 10, true);
    qa.addTransEle(4, "urls", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "url", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(8, "id", KEY, 9, true);
    qa.addTransEle(9, "", OUTPUT_CANDIDATE, 9, true);
    qa.addTransEle(10, "", OBJECT, 11, false);
    qa.addTransEle(11, "fake", KEY, 11, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "validFrom", KEY, 5, false);
//    qa.addBestSubkey(4, 0, "Fr"); 
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "affiliateUrl", KEY, 5, false);
///    qa.addBestSubkey(4, 0, "Tota");
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "shortDescription", KEY, 5, false);
///    qa.addBestSubkey(4, 0, "Tota");
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "monthlyRecurringChargeGrandTotal", KEY, 5, false);
///    qa.addBestSubkey(4, 0, "Tota");
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "monthlyRecurringChargeGrandTotal", KEY, 3, false);
///    qa.addBestSubkey(4, 0, "Tota");
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "shortDescription", KEY, 3, false);
///    qa.addBestSubkey(4, 0, "Tota");
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "validFrom", KEY, 3, false);
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
//   qa.addBestSubkey(2, 0, "From"); 
/////     qa.initExpectedKeysInfo(2);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
 //   qa.addTransEle(1, "", OBJECT, 2, false);
 //   qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "monthlyRecurringChargeGrandTotal", KEY, 3, false);
    qa.addBestSubkey(2, 0, "Tot");
    // qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
 //   qa.addTransEle(6, "id", KEY, 7, false);
   ///  qa.initExpectedKeysInfo(2);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "categoryPath", KEY_ARRAY, 5, false);
    qa.addTransEle(4, "orderable", KEY, 9, false);
    qa.addTransEle(4, "departmentId", KEY, 10, false);
    qa.addTransEle(4, "url", KEY, 11, false);
    qa.addTransEle(4, "secondaryMarket", KEY, 12, false);
    qa.addTransEle(4, "shortDescription", KEY, 13, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "", OBJECT, 6, false);
    //qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(6, "name", KEY, 8, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(8, "", OUTPUT_CANDIDATE, 8, true);
    qa.addTransEle(9, "", OUTPUT_CANDIDATE, 9, true);
    qa.addTransEle(10, "", OUTPUT_CANDIDATE, 10, true);
    qa.addTransEle(11, "", OUTPUT_CANDIDATE, 11, true);
    qa.addTransEle(12, "", OUTPUT_CANDIDATE, 12, true);
    qa.addTransEle(13, "", OUTPUT_CANDIDATE, 13, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "categoryPath", KEY_ARRAY, 3, false);
    qa.addTransEle(2, "orderable", KEY, 7, false);
    qa.addTransEle(2, "departmentId", KEY, 8, false);
    qa.addTransEle(2, "url", KEY, 9, false);
    qa.addTransEle(2, "secondaryMarket", KEY, 10, false);
    qa.addTransEle(2, "shortDescription", KEY, 11, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "", OBJECT, 4, false);
    //qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "id", KEY, 5, false);
    qa.addTransEle(4, "name", KEY, 6, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(8, "", OUTPUT_CANDIDATE, 8, true);
    qa.addTransEle(9, "", OUTPUT_CANDIDATE, 9, true);
    qa.addTransEle(10, "", OUTPUT_CANDIDATE, 10, true);
    qa.addTransEle(11, "", OUTPUT_CANDIDATE, 11, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    ///qa.addTransEle(1, "items", OBJECT, 2, false, ARRAY);
    ////qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(1, "name", OBJECT, 4, false, PRIMITIVE);
   /// qa.addTransEle(1, "bestMarketplacePrice", OBJECT, 2, false, OBJECT);
  ///  qa.addIndexConstraints(3, 5000, 10000);
    qa.addTransEle(2, "price", OBJECT, 3, false, PRIMITIVE);
    qa.addTransEle(3, "", PRIMITIVE, 3, true);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    ///qa.addTransEle(1, "items", OBJECT, 2, false, ARRAY);
    ////qa.addTransEle(2, "", ARRAY, 3, false);
   /// qa.addTransEle(1, "name", OBJECT, 4, false, PRIMITIVE);
    qa.addTransEle(1, "bestMarketplacePrice", OBJECT, 2, false, OBJECT);
  ///  qa.addIndexConstraints(3, 5000, 10000);
    qa.addTransEle(2, "price", OBJECT, 3, false, PRIMITIVE);
    qa.addTransEle(3, "", PRIMITIVE, 3, true);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "items", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    /// qa.addTransEle(3, "name", OBJECT, 6, false, PRIMITIVE); 
    qa.addTransEle(3, "bestMarketplacePrice", OBJECT, 4, false, OBJECT);
    // qa.addIndexConstraints(3, 5000, 10000);
    qa.addTransEle(4, "price", OBJECT, 5, false, PRIMITIVE);
    qa.addTransEle(5, "", PRIMITIVE, 5, true);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    ///qa.addTransEle(1, "items", OBJECT, 2, false, ARRAY);
    ////qa.addTransEle(2, "", ARRAY, 3, false);
    // qa.addTransEle(1, "name", OBJECT, 4, false, PRIMITIVE);
    qa.addTransEle(1, "bestMarketplacePrice", OBJECT, 2, false, OBJECT);
  ///  qa.addIndexConstraints(3, 5000, 10000);
    qa.addTransEle(2, "price", OBJECT, 3, false, PRIMITIVE);
    qa.addTransEle(3, "", PRIMITIVE, 4, true);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "items", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    /// qa.addIndexConstraints(2, 8000, 10000);
    qa.addTransEle(3, "bestMarketplacePrice", OBJECT, 4, false, OBJECT);
    /// qa.addIndexConstraints(3, 5000, 10000);
    qa.addTransEle(4, "price", OBJECT, 5, false, PRIMITIVE);
    qa.addTransEle(5, "", PRIMITIVE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "items", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "bestMarketplacePrice", OBJECT, 4, false, OBJECT);
    qa.addTransEle(4, "price", OBJECT, 5, false, PRIMITIVE);
    qa.addTransEle(5, "", PRIMITIVE, 5, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    /// qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(1, "data", OBJECT, 2, false, ARRAY);
    //qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(1, "", ARRAY, 2, false);
   // qa.addTransEle(2, "", ARRAY, 3, false);
    /// qa.addIndexConstraints(2, 1, 3);
    qa.addTransEle(2, "", PRIMITIVE, 2, true, PRIMITIVE);
    qa.addIndexConstraints(2, 1, 3);
    /// qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
 }*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    /// qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "data", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "", ARRAY, 4, false);
   // qa.addTransEle(2, "", ARRAY, 3, false);
   ///  qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(4, "", PRIMITIVE, 4, true, PRIMITIVE);
 //   qa.addIndexConstraints(4, 1, 3);
    /// qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
 }*/


// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    /// qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(1, "data", OBJECT, 2, false, ARRAY);
    //qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", ARRAY, 3, false);
    /// qa.addIndexConstraints(2, 1, 3);
    qa.addTransEle(3, "", PRIMITIVE, 3, true, PRIMITIVE);
   qa.addIndexConstraints(3, 2, 4);
    /// qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
 }*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    /// qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "data", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "", ARRAY, 4, false);
    qa.addTransEle(4, "", ARRAY, 5, false);
 ///   qa.addIndexConstraints(3, 100, 100000);
    qa.addTransEle(5, "", PRIMITIVE, 5, true, PRIMITIVE);
    qa.addIndexConstraints(5, 2, 4);
    /// qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
 }*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    /// qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "data", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "", ARRAY, 4, false);
    qa.addTransEle(4, "", ARRAY, 5, false);
 ///   qa.addIndexConstraints(3, 100, 100000);
    qa.addTransEle(5, "", PRIMITIVE, 5, true, PRIMITIVE);
    qa.addIndexConstraints(5, 1, 3);
    /// qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
 }*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    /// qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "data", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "", ARRAY, 4, false);
    qa.addIndexConstraints(3, 100, 100000);
    qa.addTransEle(4, "", PRIMITIVE, 4, true, PRIMITIVE);
 ///   qa.addIndexConstraints(4, 0, 3); 
    /// qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
 }*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "meta", OBJECT, 2, false, OBJECT);
    qa.addTransEle(2, "view", OBJECT, 3, false, OBJECT);
    qa.addTransEle(3, "columns", OBJECT, 4, false, ARRAY);
    qa.addTransEle(4, "", ARRAY, 5, false);
    qa.addTransEle(5, "name", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    // qa.addTransEle(1, "", ARRAY, 2, false);
    // qa.addTransEle(1, "id", OBJECT, 2, false, PRIMITIVE);
    qa.addTransEle(1, "text", OBJECT, 3, false, PRIMITIVE);
    qa.addTransEle(2, "", PRIMITIVE, 2, true);
    qa.addTransEle(3, "", PRIMITIVE, 3, true);
}*/

void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    ///qa.addTransEle(2, "id", OBJECT, 3, false, PRIMITIVE);
    qa.addTransEle(2, "text", OBJECT, 4, false, PRIMITIVE);
    qa.addTransEle(3, "", PRIMITIVE, 3, true);
    qa.addTransEle(4, "", PRIMITIVE, 4, true); 
}

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    // qa.addTransEle(1, "", ARRAY, 2, false);
    /// qa.addTransEle(1, "id", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(1, "entities", OBJECT, 2, false, OBJECT);
    qa.addTransEle(2, "urls", OBJECT, 3, false, ARRAY);
    qa.addTransEle(3, "", ARRAY, 4, false);
    qa.addTransEle(4, "url", OBJECT, 5, false, PRIMITIVE);
    qa.addTransEle(5, "", PRIMITIVE, 5, true);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    /// qa.addTransEle(2, "id", OBJECT, 7, false, PRIMITIVE); 
    qa.addTransEle(2, "entities", OBJECT, 3, false, OBJECT);
    qa.addTransEle(3, "urls", OBJECT, 4, false, ARRAY);
    qa.addTransEle(4, "", ARRAY, 5, false);
    qa.addTransEle(5, "url", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
    qa.addTransEle(7, "", PRIMITIVE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "entities", OBJECT, 3, false, OBJECT);
    qa.addTransEle(3, "urls", OBJECT, 4, false, ARRAY);
    qa.addTransEle(4, "", ARRAY, 5, false);
    qa.addTransEle(5, "url", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "items", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "itemId", OBJECT, 4, false, PRIMITIVE);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    ///qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "shortDescription", OBJECT, 4, false, PRIMITIVE);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
   // qa.addTransEle(1, "", OBJECT, 2, false);
   //  qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
   // qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(1, "videoChapters", OBJECT, 2, false, ARRAY);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(2, "", ARRAY, 3, false);
 //   qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "chapter", OBJECT, 4, false, PRIMITIVE);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
   // qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
     qa.addTransEle(3, "monthlyRecurringChargeGrandTotal", OBJECT, 4, false, PRIMITIVE);
    ///qa.addTransEle(3, "validFrom", OBJECT, 4, false, PRIMITIVE);
    // qa.addIndexConstraints(5, 1, 3);
    //qa.addTransEle(4, "", ARRAY, 5, false);
 //   qa.addIndexConstraints(5, 1, 3);
    //qa.addTransEle(5, "chapter", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
   // qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "videoChapters", OBJECT, 4, false, ARRAY);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "", ARRAY, 5, false);
 //   qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "chapter", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    ///qa.addTransEle(1, "", OBJECT, 2, false);
   // qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
 //   qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(1, "categoryPath", OBJECT, 2, false, ARRAY);
///    qa.addIndexConstraints(3, 50003, 100010);
   ///  qa.addIndexConstraints(3, 3, 10);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(2, "", ARRAY, 3, false);
    ///qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "id", OBJECT, 4, false, PRIMITIVE);
    qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    ///qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "categoryPath", OBJECT, 4, false, ARRAY);
    //qa.addIndexConstraints(3, 50000, 100010);
    /// qa.addIndexConstraints(3, 3, 10);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "", ARRAY, 5, false);
    ///qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "id", OBJECT, 6, false, PRIMITIVE);
    qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    ///qa.addTransEle(1, "", OBJECT, 2, false);
   // qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
  //  qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(1, "shippingLevelsOfService", OBJECT, 2, false, ARRAY);
    /// qa.addIndexConstraints(3, 50000, 100010);
    /// qa.addIndexConstraints(3, 3, 10);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(2, "", ARRAY, 3, false);
    ///qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "serviceLevelId", OBJECT, 4, false, PRIMITIVE);
    qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(4, "", PRIMITIVE, 4, true);
}*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    ///qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "shippingLevelsOfService", OBJECT, 4, false, ARRAY);
    /// qa.addIndexConstraints(3, 50000, 100010);
    /// qa.addIndexConstraints(3, 3, 10);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "", ARRAY, 5, false);
    ///qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "serviceLevelId", OBJECT, 6, false, PRIMITIVE);
    qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    ///qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "categoryPath", OBJECT, 4, false, ARRAY);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "", ARRAY, 5, false);
    ///qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "id", OBJECT, 6, false, PRIMITIVE);
    qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    ///qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(1, "products", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "categoryPath", OBJECT, 4, false, ARRAY);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "", ARRAY, 5, false);
    // qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(5, "id", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "claims", OBJECT, 3, false, OBJECT);
///   qa.addIndexConstraints(2, 50000, 100001);
     qa.addIndexConstraints(2, 10, 21);
    qa.addTransEle(3, "P150", OBJECT, 4, false, ARRAY);
    qa.addTransEle(4, "",ARRAY, 5, false);
    qa.addTransEle(5, "mainsnak", OBJECT, 6, false, OBJECT);
//    qa.addIndexConstraints(5, 1, 3); 
    qa.addTransEle(6, "property", OBJECT, 7, false, PRIMITIVE);
    qa.addTransEle(7, "", PRIMITIVE, 7, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    // qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "claims", OBJECT, 2, false, OBJECT);
    qa.addTransEle(2, "P150", OBJECT, 3, false, ARRAY);
    qa.addTransEle(3, "",ARRAY, 4, false);
    qa.addTransEle(4, "mainsnak", OBJECT, 5, false, OBJECT);
    // qa.addIndexConstraints(4, 1, 3);
    qa.addTransEle(5, "property", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

// small records
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    // qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "claims", OBJECT, 2, false, OBJECT);
    qa.addTransEle(2, "P150", OBJECT, 3, false, ARRAY);
    qa.addTransEle(3, "",ARRAY, 4, false);
    qa.addTransEle(4, "mainsnak", OBJECT, 5, false, OBJECT);
    qa.addTransEle(5, "property", OBJECT, 6, false, PRIMITIVE);
    qa.addTransEle(6, "", PRIMITIVE, 6, true);
}*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "claims", OBJECT, 3, false, OBJECT);
   qa.addIndexConstraints(2, 10, 21);
//    qa.addIndexConstraints(2, 50000, 100001);
    qa.addTransEle(3, "P150", OBJECT, 4, false, ARRAY);
    qa.addTransEle(4, "",ARRAY, 5, false);
    qa.addTransEle(5, "mainsnak", OBJECT, 6, false, OBJECT);
    qa.addTransEle(6, "property", OBJECT, 7, false, PRIMITIVE);
    qa.addTransEle(7, "", PRIMITIVE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "claims", OBJECT, 3, false, OBJECT);
    qa.addTransEle(3, "P150", OBJECT, 4, false, ARRAY);
    qa.addTransEle(4, "",ARRAY, 5, false);
    qa.addTransEle(5, "mainsnak", OBJECT, 6, false, OBJECT);
    qa.addTransEle(6, "property", OBJECT, 7, false, PRIMITIVE);
    qa.addTransEle(7, "", PRIMITIVE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    // qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "available_travel_modes", OBJECT, 2, false, ARRAY);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addTransEle(3, "", PRIMITIVE, 3, true, PRIMITIVE);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "available_travel_modes", OBJECT, 3, false, PRIMITIVE);
    // qa.addTransEle(3, "", ARRAY, 4, false);
    qa.addTransEle(3, "", PRIMITIVE, 3, true, PRIMITIVE);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "available_travel_modes", OBJECT, 3, false, ARRAY);
    qa.addTransEle(3, "", ARRAY, 4, false); 
    qa.addTransEle(4, "", PRIMITIVE, 4, true, PRIMITIVE);
}*/

/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    // qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "routes", OBJECT, 2, false, ARRAY);  //current state expects an object value, which expects a routes key
    qa.addTransEle(2, "", ARRAY, 3, false);  // current state after reading "routes" expects an array value
    qa.addTransEle(3, "legs", OBJECT, 4, false, ARRAY);  // inside array, it expects an object value, which expectes a legs key
    qa.addTransEle(4, "", ARRAY, 5, false);
    qa.addTransEle(5, "steps", OBJECT, 6, false, ARRAY);
    qa.addTransEle(6, "", ARRAY, 7, false);
    qa.addTransEle(7, "distance", OBJECT, 8, false, OBJECT);
    qa.addTransEle(8, "text", OBJECT, 9, false, PRIMITIVE);
    qa.addTransEle(9, "", PRIMITIVE, 9, true, PRIMITIVE);
}*/

// save value type
/*__attribute__((always_inline)) void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "routes", OBJECT, 3, false, ARRAY);  //current state expects an object value, which expects a routes key
    qa.addTransEle(3, "", ARRAY, 4, false);  // current state after reading "routes" expects an array value
    qa.addTransEle(4, "legs", OBJECT, 5, false, ARRAY);  // inside array, it expects an object value, which expectes a legs key
    qa.addTransEle(5, "", ARRAY, 6, false);
    qa.addTransEle(6, "steps", OBJECT, 7, false, ARRAY);
    qa.addTransEle(7, "", ARRAY, 8, false);
    qa.addTransEle(8, "distance", OBJECT, 9, false, OBJECT);
    qa.addTransEle(9, "text", OBJECT, 10, false, PRIMITIVE);
    qa.addTransEle(10, "", PRIMITIVE, 10, true, PRIMITIVE);
}*/

// $[*].routes[*].legs[*].steps[*].distance.text
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "routes", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "legs", KEY_ARRAY, 6, false);
    qa.addTransEle(6, "", OBJECT, 7, false);
    qa.addTransEle(7, "steps", KEY_ARRAY, 8, false);
    qa.addTransEle(8, "", OBJECT, 9, false);
    qa.addTransEle(9, "distance", KEY_OBJECT, 10, false); 
    qa.addTransEle(10, "text", KEY, 11, false);
    qa.addTransEle(11, "", OUTPUT_CANDIDATE, 11, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "routes", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "legs", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "steps", KEY_ARRAY, 7, false);
    qa.addTransEle(7, "", OBJECT, 8, false);
    qa.addTransEle(8, "distance", KEY_OBJECT, 9, false);
    qa.addTransEle(9, "text", KEY, 10, false);
    // qa.initExpectedKeysInfo(9);
    qa.addTransEle(10, "", OUTPUT_CANDIDATE, 10, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
   // qa.addTransEle(1, "", OBJECT, 2, false);
   // qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "videoChapters", KEY_ARRAY, 3, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "", OBJECT, 4, false);
 //   qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "chapter", KEY, 5, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
   // qa.addTransEle(1, "", OBJECT, 2, false);
   // qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "additionalFeatures", KEY_ARRAY, 3, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "", OBJECT, 4, false);
 //   qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(4, "feature", KEY, 5, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/


// available_travel_modes
 /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "available_travel_modes", KEY_ARRAY, 3, false);
    /*qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "legs", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "steps", KEY_ARRAY, 7, false);
    qa.addTransEle(7, "", OBJECT, 8, false);
    qa.addTransEle(8, "distance", KEY_OBJECT, 9, false);
    qa.addTransEle(9, "text", KEY, 10, false);*/
   /* qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
}*/


/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
   // qa.addTransEle(1, "", OBJECT, 2, false);
   // qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "categoryPath", KEY_ARRAY, 3, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(4, "id", KEY, 5, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
   // qa.addTransEle(1, "", OBJECT, 2, false);
   // qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "categoryPath", KEY_ARRAY, 3, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(4, "id", KEY, 5, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "total", KEY, 3, false);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "categoryPath", KEY_ARRAY, 5, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "entities", KEY_OBJECT, 4, false);
    qa.addTransEle(3, "id", KEY, 8, false);
    qa.addTransEle(4, "urls", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    // qa.addTransEle(5, "indices", KEY_ARRAY, 6, false);
    qa.addTransEle(6, "url", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
    qa.addTransEle(8, "", OUTPUT_CANDIDATE, 8, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "entities", KEY_OBJECT, 3, false);
    qa.addTransEle(2, "id", KEY, 7, false);
    qa.addTransEle(3, "urls", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    // qa.addTransEle(5, "indices", KEY_ARRAY, 6, false);
    qa.addTransEle(5, "url", KEY, 6, false);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

// $.products[*].categoryPath[*].id
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "categoryPath", KEY_ARRAY, 5, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(5, "", OBJECT, 6, false);
 //   qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(6, "id", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

// $.products[*].categoryPath[*].id
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 1, false);
    qa.addTransEle(1, "products", KEY_ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 2, false);
    qa.addTransEle(2, "categoryPath", KEY_ARRAY, 3, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "", OBJECT, 3, false);
    // qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(3, "id", KEY, 4, false);
    qa.addIndexConstraints(3, 1, 3);
    qa.addTransEle(4, "", OUTPUT_CANDIDATE, 4, true);
}*/


/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
//    qa.addTransEle(1, "", OBJECT, 2, false);
//    qa.addTransEle(2, "products", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "categoryPath", KEY_ARRAY, 3, false);
    // qa.addIndexConstraints(5, 1, 3);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addIndexConstraints(3, 0, 3);
    qa.addTransEle(4, "id", KEY, 5, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "in_reply_to_screen_name", KEY, 4, false);
    qa.addBestSubkey(3, 0, "scre");
    /*qa.addTransEle(4, "urls", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "url", KEY, 7, false);
    */
 /*   qa.addTransEle(4, "", OUTPUT_CANDIDATE, 4, true);
}*/

// $[*].entities.urls[*].url
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "entities", KEY_OBJECT, 4, false);
    qa.addTransEle(4, "urls", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "url", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

// $.meta.view.columns[*].name
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    /*qa.addTransEle(1, "", OBJECT, 1, false);
    qa.addTransEle(1, "meta", KEY_OBJECT, 2, false);
    qa.addTransEle(2, "view", KEY_OBJECT, 3, false);
    qa.addTransEle(3, "columns", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 4, false);
    qa.addTransEle(4, "name", KEY, 5, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);*/
    /*qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "meta", KEY_OBJECT, 3, false);
    qa.addTransEle(3, "view", KEY_OBJECT, 4, false);
    qa.addTransEle(4, "columns", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "name", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}

  /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "data", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", ARRAY, 4, false);
    qa.addTransEle(4, "", ARRAY, 5, false);
    qa.addIndexConstraints(4, 1, 3); 
    /*qa.addTransEle(4, "columns", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "name", KEY, 7, false);*/
    /*qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
  }*/

 /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    // qa.addTransEle(1, "", OBJECT, 2, false);
    // qa.addTransEle(2, "data", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", ARRAY, 3, false);
    qa.addIndexConstraints(2, 1, 3);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
 } */

 /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    //qa.init();
    qa.addTransEle(3, "", OBJECT, 4, false);
   // qa.addTransEle(4, "maxItemsInOrder", KEY, 6, false);
    qa.addTransEle(4, "bestMarketplacePrice", KEY_OBJECT, 5, false);
    qa.addTransEle(4, "name", KEY, 7, false);
    qa.addTransEle(5, "price", KEY, 6, false);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
  }*/


  /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    //qa.init();
    qa.addTransEle(1, "", OBJECT, 2, false);
   // qa.addTransEle(4, "maxItemsInOrder", KEY, 6, false);
    qa.addTransEle(2, "bestMarketplacePrice", KEY_OBJECT, 3, false);
    qa.addTransEle(2, "name", KEY, 5, false);
    qa.addTransEle(3, "price", KEY, 4, false);
    qa.addTransEle(4, "", OUTPUT_CANDIDATE, 4, true);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
  }*/

// $.items[*].bestMarketplacePrice.price
 /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "bestMarketplacePrice", KEY_OBJECT, 5, false);
    qa.addTransEle(5, "price", KEY, 6, false);
    qa.addTransEle(6, "", OUTPUT_CANDIDATE, 6, true);
}*/

 /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "itemId", KEY, 3, false);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
 }*/

  /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "bestMarketplacePrice", KEY_OBJECT, 3, false);
    qa.addTransEle(3, "price", KEY, 4, false);
    qa.addTransEle(4, "", OUTPUT_CANDIDATE, 4, true);
 }*/

  /*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "isbn", KEY, 3, false);
    //qa.addTransEle(3, "price", KEY, 4, false);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
 }*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "bestMarketplacePrice", KEY_OBJECT, 3, false);
    qa.addTransEle(3, "price", KEY, 4, false);
    qa.initExpectedKeysInfo(3);
    qa.addTransEle(4, "", OUTPUT_CANDIDATE, 4, true);
}*/

// $[*].claims.P150[*].mainsnak.property
/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(2, "", OBJECT, 3, false);
    qa.addTransEle(3, "claims", KEY_OBJECT, 4, false);
    qa.addTransEle(4, "P150", KEY_ARRAY, 5, false);
    qa.addTransEle(5, "", OBJECT, 6, false);
    qa.addTransEle(6, "mainsnak", KEY_OBJECT, 7, false);
    qa.addTransEle(7, "property", KEY, 8, false);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "claims", KEY_OBJECT, 3, false);
    qa.addTransEle(3, "P150", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "mainsnak", KEY_OBJECT, 6, false);
    qa.addTransEle(6, "property", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", ARRAY, 2, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "claims", KEY_OBJECT, 3, false);
    qa.addTransEle(3, "P156", KEY_ARRAY, 4, false);
    qa.addTransEle(4, "", OBJECT, 5, false);
    qa.addTransEle(5, "mainsnak", KEY_OBJECT, 6, false);
    qa.addTransEle(6, "property", KEY, 7, false);
    qa.addTransEle(7, "", OUTPUT_CANDIDATE, 7, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    qa.addTransEle(3, "", OBJECT, 4, false);
    qa.addTransEle(4, "availableOnline", KEY, 5, false); //largeImage
///     qa.addBestSubkey(4, 0, "eOnl");
  //  qa.addTransEle(4, "bestMarketplacePrice", KEY_OBJECT, 5, false);
  //  qa.addTransEle(5, "price", KEY, 6, false);
    qa.addTransEle(5, "", OUTPUT_CANDIDATE, 5, true);
}*/

/*void SerialBitmap::generateAutomaton(QueryAutomaton& qa) {
    //qa.addTransEle(1, "", OBJECT, 2, false);
    //qa.addTransEle(2, "items", KEY_ARRAY, 3, false);
    qa.addTransEle(1, "", OBJECT, 2, false);
    qa.addTransEle(2, "availableOnline", KEY, 3, false); //largeImage
///     qa.addBestSubkey(4, 0, "eOnl");
  //  qa.addTransEle(4, "bestMarketplacePrice", KEY_OBJECT, 5, false);
  //  qa.addTransEle(5, "price", KEY, 6, false);
    qa.addTransEle(3, "", OUTPUT_CANDIDATE, 3, true);
}*/

__attribute__((always_inline)) void SerialBitmap::processKeyPriPairs(QueryAutomaton& qa, long& word_id, unsigned long& colon_brace_bit, long& last_colon_pos, string& output, long& output_size, unsigned long& quote_bit, unsigned long& last_quote_bit, unsigned long& end_value_bit, unsigned long& comma_brace_bit, bool& is_right_brace) {
    /// long start = rdtsc();
   /* if (mUnmatched == false) {
        
        if (qa.hasMatchedKey() == false && qa.mDfa.trans_ele[qa.mCurState - 1].num_keys > 0 && last_colon_pos > -1) {
            ++output_size;
            last_colon_pos = -1;
        }
    }*/
    /*#ifdef FILTER2
    #if defined(FILTER3) || defined(MULFILTER3)
    if (mUnmatched == false && (qa.hasMatchedKey())) {// || last_colon_pos > -1)) {//(qa.mDfa.trans_ele[qa.mCurState - 1].num_keys > 0 && last_colon_pos > -1))) {
    #else
    if (qa.hasMatchedKey()) {
    #endif
    #endif*/
        //mUnmatched = true;
        while (colon_brace_bit) {
            long cur_colon_pos = word_id * 64 + __builtin_ctzll(colon_brace_bit);
            if (last_colon_pos > -1) {
                long st = -1, ed = -1;
                findFieldQuotePos(last_colon_pos, st, ed, last_quote_bit);
                int key_len = ed - st - 1;
                if (qa.hasMatchedKeyLen(key_len)) {
                    // get the content of current key field
                    //memcpy(mKey, mRecord + st + 0, key_len);
                    //mKey[key_len] = '\0';
                    int next_state = qa.getNextState(mRecord + st + 1, key_len, KEY);
                    if (next_state > 0) {
                    //    if (qa.getType(next_state) == OUTPUT_CANDIDATE) {
                            // add matched value into output list (print mode)
                            //unsigned long t_quote_bit = quote_bit & (colon_brace_bit ^ (colon_brace_bit - 1));
                            //findFieldQuotePos(cur_colon_pos, st, ed, t_quote_bit);
                            long w_id = last_colon_pos / 64;
                            if (is_right_brace == true) w_id = word_id;
                            else if (end_value_bit == 0) {
                                w_id = word_id;
                                end_value_bit = comma_brace_bit;
                            }
                   //         if (w_id != word_id) cout<<"word id "<<word_id<<" last word id "<<w_id<<endl;
                            long end_value_pos = w_id * 64 + __builtin_ctzll(end_value_bit); 
                            long text_length = end_value_pos - last_colon_pos - 1;
                   //         char* text = (char*)malloc(text_length + 1);
                            //if (text_length > 10) {
                          //  __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + last_colon_pos + 1));
                          //  _mm256_storeu_si256(reinterpret_cast<__m256i *>(mText), v);
                           // }
                           // else 
                            long temp_len = text_length;
                            char* temp_start = mRecord + last_colon_pos + 1;
                            char* ttext = mText;
                            __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                            _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                            ttext += 32;
                            temp_len -= 32;
                            temp_start += 32;
                            if (unlikely(temp_len > 0)) {
                                while (temp_len > 0) {
                                    __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                                    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                                    ttext += 32;
                                    temp_len -= 32;
                                    temp_start += 32;
                                }
                            }
                            // memcpy(mText, mRecord + last_colon_pos + 1, text_length);
                            mText[text_length] = '\0';
                         //   mText[text_length] = ';';
                       //     mText = mText + text_length + 1;
                   //         cout<<"text "<<text<<" "<<is_right_brace<<" "<<end_value_pos<<" "<<last_colon_pos<<" "<<end_value_bit<<endl;
                            output.append(mText);
                   //         cout<<"text "<<mText<<endl;
                   //         free(text);
                            ++output_size;
                            last_colon_pos = -1;
                            #ifdef FILTER3
                            mUnmatched = true;
                            break;
                            #elif defined(MULFILTER3)
                            if (qa.hasFoundFields()) {
                                mUnmatched = true;
                                #ifdef SKIPOBJ
                                if (qa.getStackSize() == 1) {
                                    mStop = true;
                                }
                                #endif
                                break;
                            }
                            #endif
                        }
                    //}
                }
            }
            last_colon_pos = cur_colon_pos;
            end_value_bit =  comma_brace_bit & (~(colon_brace_bit ^ (colon_brace_bit - 1)));
       //     bitset<64> ocolon_bit(colon_brace_bit);
            last_quote_bit = quote_bit & (colon_brace_bit ^ (colon_brace_bit - 1));
        //    bitset<64> bquote_bit(quote_bit);
       //     bitset<64> lastquote_bit(last_quote_bit);
      //      cout<<"colon "<<ocolon_bit<<" quote "<<bquote_bit<<" final "<<lastquote_bit<<endl;
             colon_brace_bit = colon_brace_bit & (colon_brace_bit - 1);
            /*int offset_pos = last_colon_pos % 64;
            unsigned long tmpmask = (1UL << offset_pos);
            colon_brace_bit = colon_brace_bit & (~(tmpmask ^ (tmpmask - 1)));*/
   ///         if (colon_brace_bit) cout<<"in loop"<<endl;
        }
    /*#ifdef FILTER2
    } else {
        #if defined(FILTER3) || defined(MULFILTER3)
        mUnmatched = true;
        #endif
        mColonBit = colon_brace_bit;
        mWordId = word_id;
   }
   #endif*/
  /// long end = rdtsc();
  /// qa.mCost += (end - start);
} 

// TODO: remove skip_unmatched_tkn, and generate different code during compilation
__attribute__((always_inline)) void SerialBitmap::processKeyBracket(QueryAutomaton& qa, int type, long& last_colon_pos, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, unsigned long& last_quote_bit) {
    match_flag = false;
    int next_state = UNMATCHED_STATE;
    #ifdef FILTER2
    if (skip_arr_ele == false && qa.hasMatchedKeyType(type)) {
    #else
    if (skip_arr_ele == false) {
    #endif
        long st = -1, ed = -1;
        
        findFieldQuotePos(last_colon_pos, st, ed, last_quote_bit);
        int key_len = ed - st - 1;
        if (qa.hasMatchedKeyLen(key_len)) {
            //memcpy(mKey, mRecord + st + 1, key_len);
            //mKey[key_len] = '\0';
            next_state = qa.getNextState(mRecord + st + 1, key_len, type);
        }
    //#ifdef FILTER2
    }
    //#endif
    #ifdef FILTER4
    // push matched state or unmatched state for not skipping unmatched tokens
    if (next_state != UNMATCHED_STATE){// || skip_unmatched_tkn == false) {
        qa.pushStack(next_state);
     //   qa.mStateMaskInfo.state_masks[0].last_match_idx = -1;
        match_flag = true;
        #if defined(FILTER3) || defined(MULFILTER3)
        mUnmatched = false;
        #endif
        #ifdef MULFILTER3
        qa.iniVisitArray();
        #endif
        mColonBit = 0;
        // check index for the first element inside array
        /*if (type == KEY_ARRAY && qa.hasIndexConstraints()) {
            if (qa.checkArrayCounter() == false) {
                skip_arr_ele = true;
            } else skip_arr_ele = false;
        }*/
    }
    #else
    {
        qa.pushStack(next_state);
        #ifdef MULFILTER3
        qa.iniVisitArray();
        #endif
        match_flag = true;
        #if defined(FILTER3) || defined(MULFILTER3)
        mUnmatched = false;
        #endif
        mColonBit = 0;
    }
    #endif
}

// TODO: remove skip_unmatched_tkn, and generate different code during compilation
__attribute__((always_inline)) void SerialBitmap::processOpenBracket(QueryAutomaton& qa, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn) {
    match_flag = false;
    int next_state = UNMATCHED_STATE;
    /*if (skip_unmatched_tkn == false && skip_arr_ele == true) {
        // simply set next_state as unmatched state and change skip_arr_ele back to false
        skip_arr_ele = false;
    } else {*/
    if (skip_arr_ele == false) {
        next_state = qa.getNextStateNoKey(type);
    }
    #ifdef FILTER4
    if (next_state != UNMATCHED_STATE) {
    //if (skip_unmatched_tkn == false || (next_state != UNMATCHED_STATE && skip_arr_ele == false)) {
        qa.pushStack(next_state);
        #ifdef MULFILTER3
        qa.iniVisitArray();
        #endif
     //   qa.mStateMaskInfo.state_masks[0].last_match_idx = -1;
        match_flag = true;
        #if defined(FILTER3) || defined(MULFILTER3)
        mUnmatched = false;
        #endif
        mColonBit = 0;
        /*if (type == ARRAY && qa.hasIndexConstraints()) {
            if (qa.checkArrayCounter() == false) {
                skip_arr_ele = true;
            } else skip_arr_ele = false;
        }*/
    } 
    #else
    {
        qa.pushStack(next_state);
        #ifdef MULFILTER3
        qa.iniVisitArray();
        #endif
        match_flag = true;
        #if defined(FILTER3) || defined(MULFILTER3)
        mUnmatched = false;
        #endif
        mColonBit = 0;
    }
    #endif
}

// TODO: remove skip_unmatched_tkn, and generate different code during compilation
__attribute__((always_inline)) void SerialBitmap::processCloseBracket(QueryAutomaton& qa, bool& skip_arr_ele) {
    if (qa.hasIndexConstraints() && skip_arr_ele == true) {
        skip_arr_ele = false;
    }
    qa.popStack();
    #ifdef FILTER3
    if (qa.hasMatchedKey())
        mUnmatched = true;
    else mUnmatched = false;
    #elif defined(MULFILTER3)
    //if (qa.hasMatchedKeyType(KEY)) 
    if (qa.hasFoundFields()) {
        mUnmatched = true;
        #ifdef SKIPOBJ
        if (qa.getStackSize() <= 1) {
            mStop = true;
        }
        #endif
    }
    else mUnmatched = false;
    #endif
    mColonBit = 0;
}

void SerialBitmap::processArrayMember(QueryAutomaton& qa, long& last_comma_pos, bool& skip_arr_ele) {
    qa.addArrayCounter();
    if (qa.checkArrayCounter() == false) {
        skip_arr_ele = true;
    } else skip_arr_ele = false;

}

void SerialBitmap::processCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& commabit, long& last_comma_pos, bool& skip_arr_ele) {
    if (qa.hasIndexConstraints()) {
        // check if needs to process the candidate array member
        if (last_comma_pos > -1) {
            // process the previous comma, previous interval is a part of array members
            processArrayMember(qa, last_comma_pos, skip_arr_ele);
            last_comma_pos = -1;
        }
        // quick check for current interval
        int cnt_comma = 0;
        while (commabit) {
            if (cnt_comma == 1) {
                ++cnt_comma;
                break;
            }
            long cur_comma_pos = (word_id) * 64 + __builtin_ctzll(commabit);
            last_comma_pos = cur_comma_pos;
            ++cnt_comma;
            commabit = commabit & (commabit - 1);
        }
        // current interval is a part of array members
        // otherwise, the only comma within this interval will be verified and processed when meeting the right symbol
        if (cnt_comma > 1) {
            last_comma_pos = -1;
            while (commabit) {
                qa.addArrayCounter();
                if (qa.checkArrayCounter() == false) {
                    skip_arr_ele = true;
                } else skip_arr_ele = false;
                long cur_comma_pos = (word_id) * 64 + __builtin_ctzll(commabit);
                last_comma_pos = cur_comma_pos;
                commabit = commabit & (commabit - 1);
            }
        }
    }
    else if (last_comma_pos > -1) {
        // previous interval is not a part of array members
        last_comma_pos = -1;
    }
}

// Method 3
__attribute__((always_inline)) bool SerialBitmap::substrSearch_2(string* str, int num_str) {
    char target[33];
    for (int i = 0; i < num_str; ++i) {
        const char* word = str[i].c_str();
        int word_len = strlen(word);
        // copy word into target to form 256-bit vector
        for (int j = 0; j < 32; ++j) {
            target[j] = word[j % word_len];
        }
        target[32] = '\0';
        __m256i v_target = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(target));
        bool found = false;
        for (long j = 0; j < mNumTmpWords; ++j) {
            unsigned long k = j * 32;
            int cnt = 0;
            bool match = false;
            __m256i v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
            unsigned matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target)); //v_target
            match = (match || (matchbit > 0));
           /*if (matchbit > 0) {
                found = true;
                break;
               //cout<<"match "<<endl;
            }*/
            ++cnt;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
            matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
            match = (match || matchbit > 0);
            if (match > 0) {
                found = true;
                break;
                //cout<<"match "<<endl;
            }
        }
        if (found == false) return false;
    }
    return true;
}

__attribute__((always_inline)) bool SerialBitmap::substrSearch_4(string* str, int num_str) {
    char target[33];
    for (int i = 0; i < num_str; ++i) {
        const char* word = "estM";//str[i].c_str();
        int word_len = 4;//strlen(word);
        // copy word into target to form 256-bit vector
        for (int j = 0; j < 32; ++j) {
            target[j] = word[j % word_len];
        }
        target[32] = '\0';
        __m256i v_target = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(target));
        bool found = false;
        for (long j = 0; j < mNumTmpWords; ++j) {
            unsigned long k = j * 32;
            int cnt = 0;
            bool match = false;
            __m256i v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
            unsigned matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target)); //v_target
            match = (match || (matchbit > 0));
           /*if (matchbit > 0) {
                found = true;
                break;
               //cout<<"match "<<endl;
            }*/
            ++cnt;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
            matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
            match = (match || matchbit > 0);
            ++cnt;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 2));
            matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
            match = (match || matchbit > 0);
            ++cnt;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 3));
            matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
            match = (match || matchbit > 0);
            if (match > 0) {
                found = true;
                break;
                //cout<<"match "<<endl;
            }
        }
        if (found == false) return false;
    }
    return true;
}

// Method 2
__attribute__((always_inline)) bool SerialBitmap::substrSearch(string* str, int num_str) {
    for (int i = 0; i < 1;++i){//num_str; ++i) {
        const char* word = "estMarke";//"estM";//"estM";//str[i].c_str();
        int word_len = 8;//4;//strlen(word);
        bool found = false;
        unsigned long carrys[16] = {0};
        __m256i v_text0, v_text;
        long last_match_idx = -1;
        for (long j = 0; j < mNumTmpWords; ++j) {
            unsigned long k = j * 32;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
            /// if (j % 2 == 0) v_text0 = v_text;
            if (j % 2 == 1) {
                int lastidx = last_match_idx;
                last_match_idx = -1;
                unsigned long tmask = 0xffffffffffffffff;
                unsigned long next_carry = carrys[0];
                for (int l = 0; l < word_len; ++l) { //word_len
                    char ch = word[l];
                   // cout<<"ch "<<ch<<" "<<l<<endl;
                    __m256i v_ch = _mm256_set1_epi8(ch);
                    unsigned long chbit0, chbit;
                    chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_ch));
                    chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_ch));
                    chbit = (chbit << 32) | chbit0;
                    tmask = tmask & chbit;
                    if (tmask == 0 && lastidx < l) {
                        /// cout<<"jump out of the loop "<<endl;
                        break;
                    }
                    next_carry = carrys[l + 1];
                    carrys[l + 1] = tmask >> 63;
                    if (carrys[l + 1]) last_match_idx = k;
                    tmask = tmask << 1;
                    tmask = tmask | next_carry;
                }
                if (tmask) {
                    found = true;
                    break;
                }
            }
            v_text0 = v_text;
        }
        if (found == false) return false; 
    }
    return true;    
}

// build quote bitmap and string mask bitmap for the current word
__attribute__((always_inline)) void SerialBitmap::build_bitmap_basic() {
    // unsigned long str_mask;
    unsigned long quotebit0, escapebit0;
    unsigned long quotebit, escapebit;
    // start_id, top_word
    // first half of bitmap
    top_word = start_id / 2; // word id 
    //if (top_word == 15861276)
    ///    cout<<"start_id to 15861276 "<<start_id<<endl;
    unsigned long i = start_id * 32;
    //cout<<"new word "<<substring_200(mRecord + i, 0, 64)<<endl;
    v_text0 = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
    quotebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_quote));
    escapebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_escape));
    // second half of bitmap 
    ++start_id;
    i = (start_id) * 32;
    v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
    quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
    escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
    quotebit = (quotebit << 32) | quotebit0;
    escapebit = (escapebit << 32) | escapebit0;
    // step 2: update structural quote bitmaps
    uint64_t bs_bits = escapebit;
    uint64_t start_edges = bs_bits & ~(bs_bits << 1);
    int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
    uint64_t even_starts = start_edges & even_start_mask;
    uint64_t odd_starts = start_edges & ~even_start_mask;
    uint64_t even_carries = bs_bits + even_starts;
    int64_t odd_carries;
    bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
        (unsigned long long *)(&odd_carries));
    odd_carries |= prev_iter_ends_odd_backslash;
    prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
    uint64_t even_carry_ends = even_carries & ~bs_bits;
    uint64_t odd_carry_ends = odd_carries & ~bs_bits;
    uint64_t even_start_odd_end = even_carry_ends & odd_bits;
    uint64_t odd_start_even_end = odd_carry_ends & even_bits;
    uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
    quote_bits = quotebit & ~odd_ends;
     // step 3: build string mask bitmaps
    str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
        _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
    str_mask ^= prev_iter_inside_quote;
    prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
    // ++top_word;
    /// mQuoteBitmap[top_word] = quote_bits; 
    //bm.has_basic = true; 
}

__attribute__((always_inline)) void SerialBitmap::build_bitmap_colon(bitmap& bm) {
    unsigned long colonbit0, colonbit;
    colonbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_colon));
    colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
    bm.colonbit = (colonbit << 32) | colonbit0;
    bm.colonbit = bm.colonbit & (~str_mask);
}

__attribute__((always_inline)) void SerialBitmap::get_bitmap_colon(bitmap& bm) {
    if (bm.has_colon == false) {
        build_bitmap_colon(bm);
        bm.has_colon = true;
    }
}

__attribute__((always_inline)) void SerialBitmap::build_bitmap_comma(bitmap& bm) {
    unsigned long commabit0, commabit;
    commabit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_comma));
    commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
    bm.commabit = (commabit << 32) | commabit0;
    bm.commabit = bm.commabit & (~str_mask);
}

__attribute__((always_inline)) void SerialBitmap::get_bitmap_comma(bitmap& bm) {
    if (bm.has_comma == false) {
        build_bitmap_comma(bm);
        bm.has_comma = true;
    }
}

__attribute__((always_inline)) void SerialBitmap::build_bitmap_lbrace(bitmap& bm) {
    unsigned long lbracebit0, lbracebit;
    lbracebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_lbrace));
    lbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbrace));
    bm.lbracebit = (lbracebit << 32) | lbracebit0;
    bm.lbracebit = bm.lbracebit & (~str_mask);
}

__attribute__((always_inline)) void SerialBitmap::get_bitmap_lbrace(bitmap& bm) {
    if (bm.has_lbrace == false) {
        build_bitmap_lbrace(bm);
        bm.has_lbrace = true;
    }
}

__attribute__((always_inline)) void SerialBitmap::build_bitmap_rbrace(bitmap& bm) {
    unsigned long rbracebit0, rbracebit;
    rbracebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_rbrace));
    rbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbrace));
    bm.rbracebit = (rbracebit << 32) | rbracebit0;
    bm.rbracebit = bm.rbracebit & (~str_mask);
}

__attribute__((always_inline)) void SerialBitmap::get_bitmap_rbrace(bitmap& bm) {
    if (bm.has_rbrace == false) {
        build_bitmap_rbrace(bm);
        bm.has_rbrace = true;
    }
}

__attribute__((always_inline)) void SerialBitmap::build_bitmap_lbracket(bitmap& bm) {
    unsigned long lbracketbit0, lbracketbit;
    lbracketbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_lbracket));
    lbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbracket));
    bm.lbracketbit = (lbracketbit << 32) | lbracketbit0;
    bm.lbracketbit = bm.lbracketbit & (~str_mask);
}

__attribute__((always_inline)) void SerialBitmap::get_bitmap_lbracket(bitmap& bm) {
    if (bm.has_lbracket == false) {
        build_bitmap_lbracket(bm);
        bm.has_lbracket = true;
    }
}

__attribute__((always_inline)) void SerialBitmap::build_bitmap_rbracket(bitmap& bm) {
    unsigned long rbracketbit0, rbracketbit;
    rbracketbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_rbracket));
    rbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbracket));
    bm.rbracketbit = (rbracketbit << 32) | rbracketbit0;
    bm.rbracketbit = bm.rbracketbit & (~str_mask);
    /// cout<<"rbracket bit "<<bm.rbracketbit<<endl;
}

__attribute__((always_inline)) void SerialBitmap::get_bitmap_rbracket(bitmap& bm) {
    if (bm.has_rbracket == false) {
        /// cout<<"build for rbracket "<<endl;
        build_bitmap_rbracket(bm);
        bm.has_rbracket = true;
    }
}

__attribute__((always_inline)) IntervalInfo SerialBitmap::get_interval(long& pos, unsigned long& bitmap) {
    IntervalInfo itv_info;
    int relative_pos = pos % 64;
    unsigned long w_start = (1UL << relative_pos);
    // unsigned long w_temp = (1UL<< relative_pos);
    // cout<<"pos "<<pos<<" "<<relative_pos<<" "<<w_start<<" "<<w_temp<<endl;
    unsigned long mask_start = w_start ^ (w_start - 1);
    bitmap = bitmap & (~mask_start);
    if (bitmap) {
        unsigned long w_end = bitmap & (-bitmap);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval & (~mask_start);
        itv_info.is_complete = true;
    } else {
        // include the last character inside the word (incomplete interval)
        unsigned long w_end = (1UL << 63);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval & (~mask_start);
        itv_info.is_complete = false;
    }
    return itv_info;
}

__attribute__((always_inline)) IntervalInfo SerialBitmap::get_interval_new_word(unsigned long& bitmap) {
    IntervalInfo itv_info;
    unsigned long w_start = 1;
    if (bitmap) {
        unsigned long w_end = bitmap & (-bitmap);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = true;
    } else {
        // include the last character inside the word (incomplete interval)
        unsigned long w_end = (1UL << 63);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = false;
    }
    return itv_info;
}

__attribute__((always_inline)) IntervalInfo SerialBitmap::next_interval(unsigned long& bitmap) {
    IntervalInfo itv_info;
    unsigned long w_start = bitmap & (-bitmap);
    bitmap = bitmap & (bitmap - 1);
    if (bitmap) {
        unsigned long w_end = bitmap & (-bitmap);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = true;
    } else {
        // include the last character inside the word (incomplete interval)
        unsigned long w_end = (1UL << 63);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = false;
    }
    return itv_info;
}

__attribute__((always_inline)) long SerialBitmap::get_position(unsigned long& bitmap, int number) {
    while (number > 1) {
        bitmap = bitmap & (bitmap - 1);
        --number;
    }
    unsigned long pos = top_word * 64 + __builtin_ctzll(bitmap);
    return pos;
}

__attribute__((always_inline)) int SerialBitmap::count(unsigned long& interval, unsigned long& bitmap) {
    return __builtin_popcountl(bitmap & interval); 
}

__attribute__((always_inline)) long SerialBitmap::object_end(unsigned long& interval, unsigned long& bitmap) {
    return top_word * 64 + 64 - __builtin_clzll(bitmap & interval);
}

/*__attribute__((always_inline)) long SerialBitmap::get_position(unsigned long, int number) {
    while (number > 1) {
        
    }
}*/

__attribute__((always_inline)) long SerialBitmap::interval_end(unsigned long& interval) {
    // TODO: confirm whether it is absolute or relevant
    long temp = top_word * 64 + 63 - __builtin_clzll(interval);
    if (interval == 0 && temp % 64 == 0) 
        cout<<"*********** word id "<<top_word<<" "<<__builtin_clzll(interval)<<endl;
    //long temp_pos = top_word * 64 _+ 63 - __buildin_clzll(interval);
    
    return top_word * 64 + 63 - __builtin_clzll(interval);
}

__attribute__((always_inline)) void SerialBitmap::jumpToNextBracket1(bitmap& bm) {
    // first check curent word
    if (cur_word == true)
    {  // inside current word
        if (cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
           ///  cout<<"jump to bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            /*bitset<64> tempbit(cb_mask);
                bitset<64> tempbit1(colonbit);
                if(start_id > 130 && start_id < 124) cout<<"temp bit "<<tempbit<<" "<<tempbit1<<endl;
            if (start_id > 60 && start_id < 70) cout<<"1 jump to next bracket "<<start_id<<" "<<colonbit<<" "<<colon_mask<<" "<<cb_bit<<endl;
           */
            return;
        } else {
            // interval ends with no bracket
            ++start_id;
            cur_word = false;
        }
    }
    unsigned long str_mask;
    unsigned long escapebit, stringbit;
    // unsigned long lbracebit, rbracebit;
    ///unsigned long escapebit, stringbit,
    /// unsigned long lbracebit, rbracebit, lbracketbit, rbracketbit;
   //unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long cb_mask1 = cb_mask;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
   unsigned long sid = start_id;
   unsigned long colonbit, commabit;
   while (sid < mNumTmpWords) {
        /// if (cur_pos > 63028) cout<<"sid jump "<<sid<<endl;
        //create relevant bitmaps
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, bm.lbracketbit = 0, bm.rbracketbit = 0;
        unsigned long i = sid * 32;
        if (sid > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        /*__m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3a);*/
        bm.lbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbrace));
        bm.rbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbrace));
        bm.lbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbracket));
        bm.rbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbracket));
        bracketbit = bm.lbracketbit | bm.rbracketbit;
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(sid % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++sid;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask1 = bracketbit;
            if (cb_mask1) {
                // has jumped to next bracket
                first = 1;
                cb_bit = cb_mask1 & (-cb_mask1);
                second = cb_bit;
                cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                /// cout<<"ch "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
                first = second;
                cb_mask1 = cb_mask1 & (cb_mask1 - 1);
                //mask = second - first;
                second = cb_mask1 & (-cb_mask1);
                if (!cb_mask1) {
                    second = 1UL<<63;  //TODO: set second to be zero later
                    //mask = mask | second;
                }
                mask = second - first;
                if (!cb_mask1)
                    mask = mask | second;
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                cur_word = true;
                /*bitset<64> tempbit(cb_mask1);
                bitset<64> tempbit1(colonbit);
                if(start_id > 130 && start_id < 134) cout<<"temp bit x "<<tempbit<<" "<<tempbit1<<endl;
                if (start_id > 60 && start_id < 70) cout<<"jump to next bracket x "<<start_id<<" "<<colonbit<<" "<<colon_mask<<" "<<cb_bit<<" "<<tempbit<<endl;
                */
                cb_mask = cb_mask1;
                start_id = sid;
                this->colonbit = colonbit;
                this->commabit = commabit;
                //this->lbracketbit = lbracketbit;
                //this->rbracketbit = rbracketbit;
                return;
            }
            ++sid;
        }
    }
}


__attribute__((always_inline)) void SerialBitmap::jumpToNextBracket() {
    // first check curent word
    if (cur_word == true)
    {  // inside current word
        if (cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
           ///  cout<<"jump to bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            } 
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            /*bitset<64> tempbit(cb_mask);
                bitset<64> tempbit1(colonbit);
                if(start_id > 130 && start_id < 124) cout<<"temp bit "<<tempbit<<" "<<tempbit1<<endl;
            if (start_id > 60 && start_id < 70) cout<<"1 jump to next bracket "<<start_id<<" "<<colonbit<<" "<<colon_mask<<" "<<cb_bit<<endl;
           */
            return;
        } else {
            // interval ends with no bracket
            ++start_id;
            cur_word = false;
        }
    }
    unsigned long str_mask;
    unsigned long escapebit, stringbit;
    ///unsigned long escapebit, stringbit, 
    /// unsigned long lbracebit, rbracebit, lbracketbit, rbracketbit;
   //unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long cb_mask1 = cb_mask;
    unsigned long bracketbit; 
    __m256i v_text0, v_text;
   unsigned long sid = start_id;
   unsigned long colonbit, commabit;
   while (sid < mNumTmpWords) {
        /// if (cur_pos > 63028) cout<<"sid jump "<<sid<<endl;
        //create relevant bitmaps
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = sid * 32;
        if (sid > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        /*__m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3a);*/
        lbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbrace));
        rbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbrace));
         lbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbracket));
        rbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbracket));
        bracketbit = lbracketbit | rbracketbit; 
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(sid % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++sid;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask1 = bracketbit;
            if (cb_mask1) {
                // has jumped to next bracket
                first = 1;
                cb_bit = cb_mask1 & (-cb_mask1);
                second = cb_bit;
                cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                /// cout<<"ch "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
                first = second;
                cb_mask1 = cb_mask1 & (cb_mask1 - 1);
                //mask = second - first;
                second = cb_mask1 & (-cb_mask1);
                if (!cb_mask1) {
                    second = 1UL<<63;  //TODO: set second to be zero later
                    //mask = mask | second;
                }
                mask = second - first;
                if (!cb_mask1)
                    mask = mask | second;
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                cur_word = true;
                /*bitset<64> tempbit(cb_mask1);
                bitset<64> tempbit1(colonbit);
                if(start_id > 130 && start_id < 134) cout<<"temp bit x "<<tempbit<<" "<<tempbit1<<endl;
                if (start_id > 60 && start_id < 70) cout<<"jump to next bracket x "<<start_id<<" "<<colonbit<<" "<<colon_mask<<" "<<cb_bit<<" "<<tempbit<<endl;
                */
                cb_mask = cb_mask1;
                start_id = sid;
                this->colonbit = colonbit;
                this->commabit = commabit;
                this->lbracketbit = lbracketbit;
                this->rbracketbit = rbracketbit;
                return;
            }
            ++sid;
        }
    }
}

__attribute__((always_inline)) bool SerialBitmap::hasMoreKV() {
    if (cur_word == true) {
    // start from current word
    /*if (colon_mask) {
        bitset<64> tempbit(colon_mask);
        bitset<64> tempbit1(colonbit);
    ///    cout<<"matched colon mask current "<<tempbit<<" "<<tempbit1<<" "<<start_id<<endl;
    }*/
    if (colon_mask) return true;
    if (cb_mask) {  // move to next interval and return false
        cb_bit = cb_mask & (-cb_mask);
        second = cb_bit;
        cur_pos = top_word * 64 + __builtin_ctzll(cb_bit); // no more K-V
        first = second;
        cb_mask = cb_mask & (cb_mask - 1);
        // mask = second - first;
        second = cb_mask & (-cb_mask);
        if (!cb_mask) {
            second = 1UL<<63;  //TODO: set second to be zero later
            // mask = mask | second;
        }
        mask = second - first;
        if (!cb_mask) {
            mask = mask | second;
        }
        colon_mask = mask & colonbit;
        comma_mask = mask & commabit;
        cur_word = true;
        return false; 
    }
    bitset<64> tempbit1(colonbit);
    bitset<64> temp2(first);
    bitset<64> temp3(second);
    unsigned long tmask = second - first;
    bitset<64> temp4(tmask);
  ///  cout<<"cb mask is empty check next word "<<tempbit1<<" "<<temp2<<" "<<temp3<<" "<<temp4<<" "<<start_id<<endl;
    ++start_id;
    cur_word = false;
    }
    unsigned long str_mask;
    unsigned long escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long cb_mask1 = cb_mask;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
    unsigned long colonbit, commabit;
    // check following words for ending position of interval
    while (start_id < mNumTmpWords) {
        //create relevant bitmaps
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask1 = bracketbit;
            if (cb_mask1) {
                // decision is based on colon_mask
                // reached the end of interval
                // has jumped to next bracket
                first = 1;
                cb_bit = cb_mask1 & (-cb_mask1);
                second = cb_bit;
                    /// cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                mask = second - first;
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                /*if (start_id == 65) {
                    bitset<64> tempbit(colon_mask);
                    cout<<"temp bit 65 "<<tempbit<<endl;
                }*/
                if (colon_mask) {
                    if (colon_mask) {
                        bitset<64> tempbit(colon_mask);
                        bitset<64> tempbit1(colonbit);
     ///                   cout<<"matched colon mask "<<tempbit<<" "<<tempbit1<<endl;
                    }
                    cur_word = true;
                    cb_mask = cb_mask1;
                    this->colonbit = colonbit;
                    this->commabit = commabit;
                    return true;
                }
                cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                // move onto next interval
                first = second;
                cb_mask1 = cb_mask1 & (cb_mask1 - 1);
                second = cb_mask1 & (-cb_mask1);
                //mask = second - first;
                if (!cb_mask1) {
                    second = 1UL<<63;  //TODO: set second to be zero later
                    //mask = mask | second;
                }
                mask = second - first;
                if (!cb_mask1) {
                    mask = mask | second;
                }
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                cur_word = true;
                cb_mask = cb_mask1;
                this->colonbit = colonbit;
                this->commabit = commabit;
                return false;        
            } else {
                // check colon bit instead
                colon_mask = colonbit;
                comma_mask = commabit;
                if (colon_mask) {
                    cur_word = true;
                    cb_mask = cb_mask1;
                    this->colonbit = colonbit;
                    this->commabit = commabit;
                    return true;
                }
                // check next word, since result is UNKNOWN
                cur_word = false;
                ++start_id;
            }
        }
    }
    cb_mask = cb_mask1;
    this->colonbit = colonbit;
    this->commabit = commabit;
    return false;
}

__attribute__((always_inline)) void SerialBitmap::jumpToNextKV() {
    cur_pos = top_word * 64 + __builtin_ctzll(colon_mask);   // last_colon_pos
//////    if (qa.mCurState >= 6) cout<<" jump to next kv "<<substring_200(mRecord, cur_pos - 5, cur_pos + 50)<<endl;
    colon_mask = colon_mask & (colon_mask - 1);
}

__attribute__((always_inline)) int SerialBitmap::getVType() {
    long pos = cur_pos + 1;
    while (mRecord[pos] == ' ') ++pos;
    if (mRecord[pos] == '{') return OBJECT;
    if (mRecord[pos] == '[') return ARRAY;
    return PRIMITIVE;
}

__attribute__((always_inline)) int SerialBitmap::getEType() {
    long pos = cur_pos;
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') ++pos;
    if (mRecord[pos] == '{') return OBJECT;
    if (mRecord[pos] == '[') return ARRAY;
    return PRIMITIVE;
}

// TODO: confirm whether we need to return END_OBJECT, similar for skipArray and skipPrimitive
// TODO: how to get interval and pos, similar issue happens for all following functions
__attribute__((always_inline)) void SerialBitmap::skipObject(long& pos, bitmap& bm) {
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    // int relevant_pos = pos % 64;  // relevant position for the current word
    bool new_word = false;
    // TODO: used for debugging
    /// long start_pos = 1015121679;
    /// long st_pos = pos;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                /// if (word_id == 15861276) cout<<"build basic for word "<<substring_200(mRecord, word_id * 64, word_id * 64 + 64)<<" "<<top_word<<endl;
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                /// if (start_id == 31722552) cout<<"word id build "<<word_id<<" "<<top_word<<endl;
                build_bitmap_basic();
            } /*else {
                // current word
            }*/
            /// if (word_id == 15861276 && bm.has_lbrace == false) cout<<"create lbracket bitmap "<<endl;
            get_bitmap_lbrace(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    /*if (word_id == 15861276) {
                        bitset<64> tempbit(bm.lbracebit);
                        cout<<"new word interval "<<tempbit<<" "<<bm.has_lbrace<<" "<<top_word<<endl;
                    }*/
                    interval = get_interval_new_word(bm.lbracebit);
                } else {
                    /*if (st_pos == start_pos) {
                        bitset<64> tempbit(bm.lbracebit);
                        cout<<"first interval "<<tempbit<<" "<<word_id<<" "<<bm.has_lbrace<<" "<<top_word<<endl;
                    }*/
                    interval = get_interval(pos, bm.lbracebit);
                }
                first_interval = true;
            } else {
                // if (st_pos == start_pos) {
                /*if (word_id == 15861276) {
                    bitset<64> tempbit(bm.lbracebit); 
                    cout<<"next interval "<<tempbit<<" "<<top_word<<endl;
                }*/
                interval = next_interval(bm.lbracebit);
            }
            get_bitmap_rbrace(bm);
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            num_close = __builtin_popcountl(bitmap_rbrace);
            /*if (st_pos == start_pos) {
                bitset<64> tempbit(bm.lbracebit);
                cout<<"num open "<<num_open<<" "<<num_close<<" "<<tempbit<<" "<<substring_200(mRecord, word_id * 64, word_id * 64 + 64)<<endl;
            }*/
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbrace, num_open);  //bm.rbracebit
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            /// ++start_id;
            first_interval = false;
            // relevant_pos = 0;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipArray(long& pos, bitmap& bm) {
    /// cout<<"calling skip array "<<pos<<" "<<mNumWords<<" "<<mRecord[pos]<<endl;
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    // int relevant_pos = pos % 64;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                /// cout<<"new word "<<word_id<<" "<<top_word<<endl;
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                /// if (start_id == 31722552) cout<<"word id build "<<word_id<<" "<<top_word<<endl;
                build_bitmap_basic();
                /// cout<<"basic created "<<word_id<<endl;
            }
            get_bitmap_lbracket(bm);
        ///     bitset<64> tempbit4(bm.lbracketbit);
        ///     cout<<"left bit0 "<<tempbit4<<endl;
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    // interval.intervalbit = 0;
                    // interval.is_complete = true;
                    interval = get_interval_new_word(bm.lbracketbit);
                    //bitset<64> tempbit(interval.intervalbit);
                    //cout<<"interval "<<tempbit<<" "<<interval.is_complete<<" "<<substring_200(mRecord, word_id * 64, word_id * 64 + 64)<<endl;
                } else {
                interval = get_interval(pos, bm.lbracketbit);
                    // first_interval = true;
                } 
                first_interval = true;
            } else { //if (new_word == false) {
                interval = next_interval(bm.lbracketbit);
            } /*else {
                interval = get_interval_new_word(bm.lbracketbit);
                new_word = false; 
            }*/
           /* bitset<64> tempbit3(bm.lbracketbit);
            cout<<"left bit "<<tempbit3<<endl;
            bitset<64> tempbit(interval.intervalbit);
            cout<<"interval "<<tempbit<<" "<<interval.is_complete<<" "<<substring_200(mRecord, word_id * 64, word_id * 64 + 64)<<endl;
          */get_bitmap_rbracket(bm);
            unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
            bitset<64> tempbit1(bm.rbracketbit);
          ///  cout<<"right bit "<<tempbit1<<endl;
            num_close = __builtin_popcountl(bitmap_rbracket);
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbracket, num_open);  //bm.rbracebit
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            // ++start_id;
            first_interval = false;
            //relevant_pos = 0;
            new_word = true;
            ///cout<<"new word "<<word_id<<" "<<num_open<<" "<<num_close<<" "<<mNumWords<<endl;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipFollowingAttributes(long& pos, bitmap& bm) {
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            } 
            get_bitmap_lbrace(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    interval = get_interval_new_word(bm.lbracebit);
                } else {
                    interval = get_interval(pos, bm.lbracebit);
                }
                first_interval = true;
            } else {
                interval = next_interval(bm.lbracebit);
            }
            get_bitmap_rbrace(bm);
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            num_close = __builtin_popcountl(bitmap_rbrace);
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbrace, num_open);  //bm.rbracebit
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipFollowingElements(long& pos, bitmap& bm) {
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_lbracket(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    interval = get_interval_new_word(bm.lbracketbit);
                } else {
                    interval = get_interval(pos, bm.lbracketbit);
                }
                first_interval = true;
            } else {
                interval = next_interval(bm.lbracketbit);
            }
            get_bitmap_rbracket(bm);
            unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
            num_close = __builtin_popcountl(bitmap_rbracket);
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbracket, num_open);  //bm.rbracebit
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipPrimitiveObj(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    bool first_interval = false;
    /// int relevant_pos = pos % 64;
    bool new_word = false;
    // cout<<"*** word id "<<word_id<<" "<<start_id<<endl;
    // in general case it can only pass one word
    /*if (start_id > 0 && start_id != 2 * word_id + 1) {
        cout<<"*** special word id "<<word_id<<" "<<start_id<<endl; 
        ++start_id;
    }*/
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            /// if (start_id == 31722552) cout<<"word id build primitive "<<word_id<<" "<<top_word<<endl;
            build_bitmap_basic();
            // if (word_id == 15861276) cout<<"lbrace flag "<<bm.has_lbrace<<endl;
        }
        get_bitmap_comma(bm);
        IntervalInfo interval;
        if (first_interval == false) {
            if (new_word == true) {
                interval = get_interval_new_word(bm.commabit);
            } else {
            ///    bitset<64> tempbit1(bm.commabit);
             ///   cout<<"prior tempbit "<<tempbit1<<" "<<substring_200(mRecord, word_id * 64, word_id * 64 + 10)<<endl;
                interval = get_interval(pos, bm.commabit);
           ///     bitset<64> tempbit(bm.commabit);
           ///     cout<<"intialization "<<pos<<" "<<relevant_pos<<" "<<mRecord[pos]<<" "<<tempbit<<" "<<substring_200(mRecord, pos - relevant_pos, pos-relevant_pos + 10)<<endl;
           ///     unsigned long test1 = (1UL << (pos % 64));
            ///    bitset<64> tempbit2(test1);
            ///    cout<<"intialization1 "<<tempbit2<<endl;
            }
            first_interval = true;
        } else {
            interval = next_interval(bm.commabit);
        }
        get_bitmap_rbrace(bm);
        unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
        if (bitmap_rbrace) {
            // end of object
            pos = get_position(bitmap_rbrace, 1) - 1;
            return;
        }
        if (interval.is_complete) {
            // position before comma
            ///if (interval.intervalbit == 0) 
                ///interval.intervalbit = 0UL;
            pos = interval_end(interval.intervalbit);
            /// if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
            pos = pos - 1;
            /// bitset<64> tempbit(interval.intervalbit);
            /// unsigned long test = interval.intervalbit;
         //////   if (word_id == 15861276) cout<<"*** lbrace flag "<<bm.has_lbrace<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            ///cout<<"word id "<<top_word<<" offset "<<__builtin_clzll(test)<<endl;
            /// cout<<"successfully skip an object primitive "<<" "<<(interval.intervalbit == 0)<<" "<<__builtin_clzll(test)<<" "<<word_id<<" "<<pos<<" "<<relevant_pos<<" "<<mRecord[pos]<<" "<<substring_200(mRecord, pos - 5, pos + 1)<<" "<<tempbit<<" "<<endl;
            return;
        } 
        // interval is incomplete in the current word
        ++word_id;
        // ++start_id;
        first_interval = false;
        //relevant_pos = 0;
        new_word = true;
    }  
}

__attribute__((always_inline)) int SerialBitmap::skipPrimitiveAry(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    bool first_interval = false;
    // int relevant_pos = pos % 64;
    bool new_word = false;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_comma(bm);
        IntervalInfo interval;
        if (first_interval == false) {
            if (new_word == true) {
                interval = get_interval_new_word(bm.commabit);
            } else {
                interval = get_interval(pos, bm.commabit);
            }
            first_interval = true;
        } else {
            interval = next_interval(bm.commabit);
        }
        get_bitmap_rbracket(bm);
        unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
        if (bitmap_rbracket) {
            //TODO: make the corresponding changes inside object & skip elements in range
            // end of array
            pos = get_position(bitmap_rbracket, 1); // - 1;
            /// long temp_pos = get_position(bitmap_rbracket, 1);
            /// cout<<"end of array "<<substring_200(mRecord, temp_pos, pos + 64)<<endl;
            return ARRAY_END;
        }
        if (interval.is_complete) {
            // position before comma
            pos = interval_end(interval.intervalbit);
            /// if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
            pos = pos - 1;
            // cout<<"ending position of output array "<<substring_200(mRecord, pos, pos + 64)<<endl;
            return SUCCESS;
        }
        // interval is incomplete in the current word
        ++word_id;
        // ++start_id;
        first_interval = false;
        // relevant_pos = 0;
        new_word = true;
    }
}

__attribute__((always_inline)) int SerialBitmap::skipPrimElements(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    // bool first_interval = false;
    bool new_word = false;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_lbrace(bm);
        get_bitmap_lbracket(bm);
        unsigned long bitmap_bracket = bm.lbracebit | bm.lbracketbit;
        IntervalInfo interval;
        /// if (first_interval == false) {
            if (new_word == true) {
                interval = get_interval_new_word(bitmap_bracket);
            } else {
                interval = get_interval(pos, bitmap_bracket);
            }
            /// first_interval = true;
        ///} else {
        ///    interval = next_interval(bitmap_bracket);
        ///}
        get_bitmap_rbracket(bm);
        unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
        if (bitmap_rbracket) {
            pos = get_position(bitmap_rbracket, 1);
            return ARRAY_END;
        }
        if (interval.is_complete) {
            pos = interval_end(interval.intervalbit);
            //  find cloest colon
            /// while (mRecord[pos] != ':') --pos;
            return SUCCESS;
        }
        ++word_id;
        /// first_interval = false;
        new_word = true;
    }
}

__attribute__((always_inline)) int SerialBitmap::goToObjElem(long& pos, bitmap& bm) {
    do {
        // TODO: remove the temporarliy added code
        if (mRecord[pos] != '{' || mRecord[pos] != '[') {
        int result = skipPrimElements(pos, bm);
        if (result == ARRAY_END) {
            return result;
        }
        }
        int element_type = getElementType(pos);
        if (element_type == OBJECT) {
            return SUCCESS;
        }
        skipArray(pos, bm);
    } while (hasMoreElements(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int SerialBitmap::goToAryElem(long& pos, bitmap& bm) {
    do {
        /// cout<<"pos needs to skip "<<substring_200(mRecord, pos, pos + 64)<<endl;
        // TODO: remove the temporarliy added code
        if (mRecord[pos] != '{' || mRecord[pos] != '[') {
        /// cout<<"skip prim elements "<<substring_200(mRecord, pos, pos + 64)<<endl;
        int result = skipPrimElements(pos, bm);
        /// cout<<"check skip prim elements result "<<result<<endl;
        if (result == ARRAY_END) {
            return result;
        }
        }
        int element_type = getElementType(pos);
        /// cout<<"next element type "<<element_type<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
        if (element_type == ARRAY) {
            return SUCCESS;
        }
        skipObject(pos, bm);
    } while (hasMoreElements(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int SerialBitmap::goToObjElem1(long& pos, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        switch (element_type) {
            case PRIMITIVE: {
                int result = skipPrimElements(pos, bm);
                if (result == ARRAY_END) {
                    return result;
                }
                break;
            }
            case OBJECT:
                return SUCCESS;
            case ARRAY:
                skipArray(pos, bm);
        }
    } while (hasMoreElements(pos));
    return OBJECT_END;
}

/*__attribute__((always_inline)) int SerialBitmap::goToAryElem(long& pos, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        switch (element_type) {
            case PRIMITIVE: {
                int result = skipPrimElements(pos, bm);
                if (result == ARRAY_END) {
                    return result;
                }
                break;
            }
            case OBJECT:
                skipObject(pos, bm);
                break;
            case ARRAY:
                return SUCCESS;
        }
    } while (hasMoreElements(pos));
    return OBJECT_END;
}*/

__attribute__((always_inline)) int SerialBitmap::skipPrimPairs(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    // bool first_interval = false;
    bool new_word = false;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_lbrace(bm);
        get_bitmap_lbracket(bm);
        unsigned long bitmap_bracket = bm.lbracebit | bm.lbracketbit; 
        IntervalInfo interval;
        /// if (first_interval == false) {
            if (new_word == true) {
                interval = get_interval_new_word(bitmap_bracket);
            } else {
                interval = get_interval(pos, bitmap_bracket);
            }
            /// first_interval = true;
        ///} else {
        ///    interval = next_interval(bitmap_bracket);
        ///}
        get_bitmap_rbrace(bm);
        unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
        if (bitmap_rbrace) {
            pos = get_position(bitmap_rbrace, 1);
            return OBJECT_END;
        }
        if (interval.is_complete) {
            pos = interval_end(interval.intervalbit);
            //  find cloest colon
            /// while (mRecord[pos] != ':') --pos;
            return SUCCESS;
        }
        ++word_id;
        /// first_interval = false;
        new_word = true; 
    }
}

__attribute__((always_inline)) int SerialBitmap::goToObjAttr(long& pos, bitmap& bm) {
    do {
        int result = skipPrimPairs(pos, bm);
        if (result == OBJECT_END) {
            return result;
        }
        int attribute_type = getAttributeType(pos);
        if (attribute_type == OBJECT) {
            return SUCCESS;
        }
        skipArray(pos, bm);
    } while (hasMoreAttributes(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int SerialBitmap::goToAryAttr(long& pos, bitmap& bm) {
    do {
        int result = skipPrimPairs(pos, bm);
        if (result == OBJECT_END) {
            return result;
        }
        int attribute_type = getAttributeType(pos);
        if (attribute_type == ARRAY) {
            return SUCCESS;
        }
        skipObject(pos, bm);
    } while (hasMoreAttributes(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int SerialBitmap::goToObjAttr1(long& pos, bitmap& bm) {
    // TODO: check whether num_lbrace = 0
    int num_lbrace = 0; // original is 1
    int num_lbracket = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_lbrace(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    interval = get_interval_new_word(bm.lbracebit);
                } else {
                    interval = get_interval(pos, bm.lbracebit);
                }
                first_interval = true;
            } else {
                interval = next_interval(bm.lbracebit);
            }
           get_bitmap_lbracket(bm);
           get_bitmap_rbracket(bm);
           get_bitmap_rbrace(bm);
           unsigned long bitmap_lbracket = bm.lbracketbit & interval.intervalbit;
           unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
           unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
           num_lbracket = num_lbracket + __builtin_popcountl(bitmap_lbracket);
           int num_rbracket = __builtin_popcountl(bitmap_rbracket);
           int num_rbrace = __builtin_popcountl(bitmap_rbrace);
           if (num_rbracket < num_lbracket) {
               if (num_lbrace < num_rbrace) {
                   pos = get_position(bitmap_rbrace, num_lbrace + 1);
                   cout<<"object end "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                   return OBJECT_END;
               }
               num_lbracket = num_lbracket - num_rbracket;
               /// if (num_lbrace < num_rbrace) cout<<" abc "<<num_lbrace<<" "<<num_rbrace<<endl;
               if (interval.is_complete) {
                   num_lbrace = num_lbrace - num_rbrace + 1;
                   break;
               }
               else num_lbrace = num_lbrace - num_rbrace;
           } else if (num_rbracket == num_lbracket) {
               /// cout<<"word id "<<word_id<<" "<<num_lbrace<<" "<<num_rbrace<<" "<<num_lbracket<<" "<<num_rbracket<<endl;
               if (num_rbrace == num_lbrace) {
                   if (interval.is_complete) {
                       pos = interval_end(interval.intervalbit);
                       if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
                       /// pos = pos + 1;
                       cout<<"successfully detected object start "<<substring_200(mRecord, pos, pos + 64)<<endl;
                       return SUCCESS;
                   } else {
                       num_lbrace = 0;
                   }
               } else if(num_rbrace > num_lbrace) {
                   pos = get_position(bitmap_rbrace, num_lbrace + 1);
                   return OBJECT_END;
               } else {
                   if (interval.is_complete) {
                       num_lbrace = num_lbrace - num_rbrace + 1;
                       break;
                   } else {
                       num_lbrace = num_lbrace - num_rbrace;
                   }
               }
           } else {
               pos = get_position(bitmap_rbrace, num_lbrace + 1);
               return OBJECT_END;
           }
           ++word_id;
           //++start_id;
           first_interval = false;
           new_word = true;
       }
    }
}

__attribute__((always_inline)) int SerialBitmap::goToAryAttr1(long& pos, bitmap& bm) {
    int num_lbrace = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    int counter = 0;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_lbracket(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    interval = get_interval_new_word(bm.lbracketbit);
                } else {
                    cout<<"pos interval "<<pos<<endl;
                    interval = get_interval(pos, bm.lbracketbit);
                }
                first_interval = true;
            } else {
                interval = next_interval(bm.lbracketbit);
            }
            get_bitmap_lbrace(bm);
            get_bitmap_rbrace(bm);
            unsigned long bitmap_lbrace = bm.lbracebit & interval.intervalbit;
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            num_lbrace = num_lbrace + __builtin_popcountll(bitmap_lbrace);
            counter += __builtin_popcountll(bitmap_lbrace);
            if (__builtin_popcountll(bitmap_lbrace) > 0) {
                long temp_pos = word_id * 64;// + __builtin_ctzll(bitmap_lbrace);
                cout<<"{ "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<" "<<__builtin_popcountll(bitmap_lbrace)<<" "<<counter<<endl;
            }
            int num_rbrace = __builtin_popcountll(bitmap_rbrace);
            counter -= num_rbrace;
            if (num_rbrace > 0) {
                long temp_pos = word_id * 64;// + __builtin_ctzll(bitmap_rbrace);
                cout<<"} "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<" "<<num_rbrace<<" "<<num_lbrace<<" "<<counter<<endl;
            }
            if (num_rbrace < num_lbrace) {
                num_lbrace = num_lbrace - num_rbrace;
                if (interval.is_complete) {
                    continue;
                }
            } else if (num_rbrace == num_lbrace) {
                /// pos = interval_end(interval.intervalbit);
                if (interval.is_complete == true) {
                    pos = interval_end(interval.intervalbit);
                    if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
                    pos = pos + 1;
                    cout<<"open curly "<<num_lbrace<<" "<<num_rbrace<<endl;
                    cout<<"successfully detected object start "<<pos<<" "<<substring_200(mRecord, pos, pos + 64)<<" "<<mRecord[pos]<<endl;
                    return SUCCESS; // success
                }
                num_lbrace = 0;
            } else {
                // object ends
                pos = get_position(bitmap_rbrace, num_lbrace + 1);
                cout<<"object end "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                return OBJECT_END;
            }
            ++word_id;
            //++start_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) int SerialBitmap::goToAryAttr2(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                 cout<<"build basic "<<word_id<<" "<<top_word<<endl;
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_colon(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    cout<<"get interval new word "<<pos<<endl;
                    interval = get_interval_new_word(bm.colonbit);
                } else {
                    cout<<"get interval "<<pos<<endl;
                    interval = get_interval(pos, bm.colonbit);
                }
                first_interval = true;
            } else {
                 cout<<"next interval "<<pos<<endl;
                interval = next_interval(bm.colonbit);
            }
            bitset<64> tempbit(bm.colonbit);
            bitset<64> tempbit1(interval.intervalbit);
            /// cout<<"colon bitmap "<<tempbit<<" "<<tempbit1<<endl;
            get_bitmap_rbrace(bm);
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            if (bitmap_rbrace > 0) {
                // object ends
                pos = get_position(bitmap_rbrace, 1);
                cout<<"object end "<<substring_200(mRecord, pos , pos + 64)<<endl;
                return OBJECT_END;
            }
            if (interval.is_complete) {
                cout<<" pos before interval end "<<pos<<" "<<tempbit1<<" word id "<<top_word<<endl;
                pos = interval_end(interval.intervalbit);
                if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
                pos += 1;
                cout<<"prior pos "<<pos<<endl;
                int type = getAttributeType(pos);
                cout<<"after pos "<<pos<<endl;
                if (type == OBJECT) {
                    cout<<"before skipping an object "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    skipObject(pos, bm);
                    word_id = pos / 64;  // update word id
                    first_interval = false;
                    new_word = false;
                    cout<<"after skipping an object "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                }
                else if (type == ARRAY) {
                    cout<<"successfully skip to an array "<<pos<<" "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    return pos;
                    //// cout<<"before skipping an array "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    /*skipArray(pos, bm);
                    word_id = pos / 64; // update word id
                    first_interval = false;*/
                    //// cout<<"after skipping an array "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                }
                else {
                    /// cout<<"word id "<<word_id<<" "<<top_word<<endl;
                    // cout<<"successfully skip to a primitive "<<pos<<" "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    //return pos;
                    cout<<"before skipping a primitive "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    skipPrimitiveObj(pos, bm);
                    // pos = pos + 2;
                    cout<<"after skipping a  primitive "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    /*if (mRecord[pos] == '}') {
                        return OBJECT_END;
                    }*/
                    word_id = pos / 64;
                    first_interval = false;
                    new_word = false;
                }
                break;
            }
            ++word_id;
            //++start_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) int SerialBitmap::goToPrimAttr(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                /// cout<<"build basic "<<word_id<<" "<<top_word<<endl;
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_colon(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    /// cout<<"get interval new word "<<pos<<endl;
                    interval = get_interval_new_word(bm.colonbit);
                    new_word = false;
                } else {
                    /// cout<<"get interval "<<pos<<endl;
                    interval = get_interval(pos, bm.colonbit);
                }
                first_interval = true;
            } else {
                /// cout<<"next interval "<<pos<<endl;
                interval = next_interval(bm.colonbit);
            }
            bitset<64> tempbit(bm.colonbit);
            bitset<64> tempbit1(interval.intervalbit);
            /// cout<<"colon bitmap "<<tempbit<<" "<<tempbit1<<endl;
            get_bitmap_rbrace(bm);
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            if (bitmap_rbrace > 0) {
                // object ends
                pos = get_position(bitmap_rbrace, 1);
                ///// cout<<"object end "<<substring_200(mRecord, pos , pos + 64)<<endl;
                return OBJECT_END;
            }
            if (interval.is_complete) {
                pos = interval_end(interval.intervalbit);
                /// if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
                pos += 1;
                int type = getAttributeType(pos);
                if (type == OBJECT) {
                    //// cout<<"before skipping an object "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    skipObject(pos, bm);
                    word_id = pos / 64;  // update word id 
                    first_interval = false;
                    //// cout<<"after skipping an object "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                }
                else if (type == ARRAY) {
                    ///  cout<<"before skipping an array "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    skipArray(pos, bm);
                    word_id = pos / 64; // update word id 
                    first_interval = false;
                    /// cout<<"after skipping an array "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                }
                else {
                    /// cout<<"word id "<<word_id<<" "<<top_word<<endl;
                    /////  cout<<"successfully skip to a primitive "<<pos<<" "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    return SUCCESS;
                }
                break;
            }
            ++word_id;
            //++start_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) JumpInfo SerialBitmap::skipPrimElemInRange(long& pos, int num_elements, bitmap& bm) {
    int word_id = pos / 64;
    bool new_word = false;
    int num_comma = 0;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_lbrace(bm);
        get_bitmap_lbracket(bm);
        unsigned long bitmap_bracket = bm.lbracebit | bm.lbracketbit;
        IntervalInfo interval;
        if (new_word == true) {
            interval = get_interval_new_word(bitmap_bracket);
        } else {
            interval = get_interval(pos, bitmap_bracket);
        }
        build_bitmap_rbracket(bm);
        unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
        if (bitmap_rbracket) {
            // end of array
            pos = get_position(bitmap_rbracket, 1);
            JumpInfo ji(ARRAY_END);
            return ji;
        }
        get_bitmap_comma(bm);
        unsigned long bitmap_comma = bm.commabit & interval.intervalbit;
        num_comma = num_comma +__builtin_popcountl(bitmap_comma);
        if (num_comma >= num_elements) {
            pos = get_position(bitmap_comma, num_elements);
            JumpInfo ji(SUCCESS);
            return ji;
        } else {
            if (interval.is_complete) {
                pos = interval_end(interval.intervalbit);// + 1;
                JumpInfo ji(PARTIAL_SKIP, num_comma);
                return ji;
            }
            num_elements -= num_comma;
        }
        // interval is incomplete in the current word
        ++word_id;
        //++start_id;
        new_word = true;
    }
}

// TODO: when jumping operation happens, returned position needs to be consistent with others
__attribute__((always_inline)) JumpInfo SerialBitmap::skipPrimElemInRangeEPos(long& pos, int num_elements, bitmap& bm) {
    int word_id = pos / 64;
    bool new_word = false;
    int num_comma = 0;
    bool flag = false;
    if (mRecord[pos] != '"') flag = true;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_lbrace(bm);
        get_bitmap_lbracket(bm);
        // build_bitmap_rbracket(bm);
        unsigned long bitmap_bracket = bm.lbracebit | bm.lbracketbit;// | bm.rbracketbit;
        IntervalInfo interval;
        if (new_word == true) {
            interval = get_interval_new_word(bitmap_bracket);
        } else {
            /// if (flag == true) cout<<"get interval from pos "<<substring_200(mRecord, pos, pos + 100)<<" "<<(pos % 64)<<endl;
            interval = get_interval(pos, bitmap_bracket);
            /// bitset<64> tempbit(interval.intervalbit);
            /// if (flag == true) cout<<"get interval bit "<<tempbit<<endl;
        }
        build_bitmap_rbracket(bm);
        unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
        /*if (bitmap_rbracket) {
            // end of array
            pos = get_position(bitmap_rbracket, 1);
            JumpInfo ji(ARRAY_END);
            return ji;
        }*/
        get_bitmap_comma(bm);
        unsigned long bitmap_comma = bm.commabit & interval.intervalbit;
        if (bitmap_rbracket) {
            bitmap_comma = bitmap_comma & (bitmap_rbracket ^ (bitmap_rbracket - 1));
        } /*else {
            bitmap_comma = bm.commabit & interval.intervalbit; 
        }*/
        num_comma = num_comma +__builtin_popcountl(bitmap_comma);
        if (num_comma >= num_elements) {
            long temp_pos = word_id * 64 + __builtin_ctzll(bitmap_comma);
            /// if (flag == true) cout<<"previous pos "<<pos<<" "<<word_id<<" "<<top_word<<" "<<temp_pos<<" "<<bitmap_rbracket<<endl;
            pos = get_position(bitmap_comma, num_elements);
            /// if (flag == true) cout<<"after pos "<<pos<<endl;
            JumpInfo ji(SUCCESS);
            /// if (flag == true) cout<<"success "<<substring_200(mRecord, pos, pos + 100)<<endl;
            return ji; 
        } 
        if (bitmap_rbracket) {
            // end of array
            pos = get_position(bitmap_rbracket, 1);
            JumpInfo ji(ARRAY_END);
            return ji;
        } else {
            /*long temp_pos = get_position(bitmap_bracket, 1);
            /// cout<<"end "<<mRecord[temp_pos]<<endl;
            if (mRecord[temp_pos] == ']') {
                 
                 pos = temp_pos;
                 JumpInfo ji(ARRAY_END);
                 return ji; 
            }*/
            if (interval.is_complete) {
                pos = interval_end(interval.intervalbit);// + 1;
                JumpInfo ji(PARTIAL_SKIP, num_comma);
                return ji;
            }
            num_elements -= num_comma;
        }
        // interval is incomplete in the current word
        ++word_id;
        //++start_id;
        new_word = true;
    } 
}

__attribute__((always_inline)) int SerialBitmap::skipElements(long& pos, int num_elements, bitmap& bm) {
    while (num_elements > 0) {
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
        /// cout<<"skip elements before inside "<<substring_200(mRecord, pos, pos + 200)<<" "<<num_elements<<endl; 
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                bool flag = false;
                /*if (mRecord[pos] != '"') {
                    cout<<"skip primitives "<<num_elements<<" "<<substring_200(mRecord, pos, pos + 200)<<endl;
                    flag = true;
                    long word_id = pos / 64;
                    cout<<"word id "<<word_id<<" "<<top_word<<endl;
                }*/
                JumpInfo res = skipPrimElemInRangeEPos(pos, num_elements, bm);
                ///if (flag == true)
                ///    cout<<"after skipping primitives "<<num_elements<<" "<<substring_200(mRecord, pos, pos + 200)<<endl; 
                if (res.status == ARRAY_END || res.status == SUCCESS) {
                    // cout<<"skip to array end "<<endl;
                    return res.status;
                }
                if (res.status == PARTIAL_SKIP) {
                    num_elements = num_elements - res.num_comma + 1;
                }
                /// skipPrimitiveAry(pos, bm);
                /*int result = skipPrimitiveAry(pos, bm);
                if (result == ARRAY_END)
                    return ARRAY_END;*/
                break;
            }
            case OBJECT:
                skipObject(pos, bm);
                break;
            case ARRAY:
                skipArray(pos, bm);
                break;
        }
        --num_elements;
    }
    return SUCCESS;
}

__attribute__((always_inline)) int SerialBitmap::goToObjElemInRange(long& pos, int& num_elements, bitmap& bm) {
     do {
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                JumpInfo res = skipPrimElemInRange(pos, num_elements, bm);
                if (res.status == ARRAY_END) {
                    return res.status;
                }
                if (res.status == SUCCESS) {
                    return RANGE_END;
                }
                if (res.status == PARTIAL_SKIP) {
                    num_elements = num_elements - res.num_comma + 1;
                }
                break;
            }
            case OBJECT:
                return SUCCESS;
                // break;
            case ARRAY:
                skipArray(pos, bm);
                break;
        }
        --num_elements;
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
    } while (num_elements > 0);
    return RANGE_END;
}

__attribute__((always_inline)) int SerialBitmap::goToAryElemInRange(long& pos, int& num_elements, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                JumpInfo res = skipPrimElemInRange(pos, num_elements, bm);
                if (res.status == ARRAY_END) {
                    return res.status;
                }
                if (res.status == SUCCESS) {
                    return RANGE_END;
                }
                if (res.status == PARTIAL_SKIP) {
                    num_elements = num_elements - res.num_comma + 1;
                }
                break;
            }
            case OBJECT:
                skipObject(pos, bm);
                break;
            case ARRAY:
                ///skipArray(pos, bm);
                ///break;
                return SUCCESS;
        }
        --num_elements;
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
    } while (num_elements > 0);
    return RANGE_END;
}

__attribute__((always_inline)) int SerialBitmap::goToPrimElemInRange(long& pos, int& num_elements, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                return SUCCESS;
            }
            case OBJECT:
                skipObject(pos, bm);
                break;
            case ARRAY:
                skipArray(pos, bm);
                ///break;
                /// return SUCCESS;
        }
        --num_elements;
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
    } while (num_elements > 0);
    return RANGE_END;
}

// TODO: check whether pos after using skippers points to the correct position
// e.g. pos = get_position() - 1 when reaching to end of object/array
__attribute__((always_inline)) bool SerialBitmap::hasMoreElements(long& pos) {
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') ++pos;
    ++pos;
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') {
        ++pos;
    } 
    if (mRecord[pos] == ']') {
        return false;
    }
    if (mRecord[pos] == ',') ++pos;
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') ++pos;
    return true;
}

__attribute__((always_inline)) int SerialBitmap::getElementType(long& pos) {
    while (mRecord[pos] == ' ') ++pos;
    if (mRecord[pos] == '{') return OBJECT;
    if (mRecord[pos] == '[') return ARRAY;
    return PRIMITIVE;
}

__attribute__((always_inline)) int SerialBitmap::goToPrimElem(long& pos, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        switch (element_type) {
            case PRIMITIVE:
                return SUCCESS;
            case OBJECT:
                skipObject(pos, bm);
                break;
            case ARRAY:
                skipArray(pos, bm);
        }
    } while (hasMoreElements(pos));
    return ARRAY_END;
}

// TODO: check whether pos after using skippers points to the correct position
// e.g. pos = get_position() - 1 when reaching to end of object/array
__attribute__((always_inline)) bool SerialBitmap::hasMoreAttributes(long& pos) {
    // if current character is blank, skip this character until meeting a non-blank character
    while (mRecord[pos] == ' ') ++pos;
    ++pos;
    while (mRecord[pos] == ' ') {
        ++pos;
    }
    if (mRecord[pos] == '}') {
        return false;
    }
    if (mRecord[pos] == ',') ++pos;
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n') ++pos; 
    return true;
}

__attribute__((always_inline)) int SerialBitmap::getAttributeType(long& pos) {
    while (mRecord[pos] == ' ') ++pos;
    if (mRecord[pos] == '{') return OBJECT;
    if (mRecord[pos] == '[') return ARRAY;
    return PRIMITIVE;
}

/*__attribute__((always_inline)) int SerialBitmap::goToPrimAttr(long& pos, bitmap& bm) {
    while (hasMoreAttributes(pos)) {
        int element_type = getAttributeType(pos);
        switch (element_type) {
            case PRIMITIVE:
                return SUCCESS;
            case OBJECT:
                skipObject(pos, bm);
                break;
            case ARRAY:
                skipArray(pos, bm);
        }
    }
    return OBJECT_END;
}*/

void SerialBitmap::object(long& pos, bitmap& bm) {
    int attribute_type = qa.getExpectedValueTypeObj();
    while (hasMoreAttributes(pos)) {
        /// cout<<"attribute pos "<<substring_200(mRecord, pos, pos + 100)<<endl;
        int result = 0;
        int next_state = 0;
        int element_type = attribute_type;
        switch (attribute_type) {
            case OBJECT:
                result = goToObjAttr(pos, bm);
                break;
            case ARRAY:
                result = goToAryAttr(pos, bm);
                break;
            case PRIMITIVE: {
                 ///cout<<"before going next primitive "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 100)<<endl;
                /// result = goToPrimAttr(pos, bm);
                long st = pos;
                // while (mRecord[st] != ':') --st;
                while (mRecord[st] != '"') ++st;
                long ed = st + 1;
                while (mRecord[ed] != '"') ++ed;
                int key_len = ed - st - 1;
                ///memcpy(mKey, mRecord + st + 1, key_len);
                ///mKey[key_len] = '\0';
                ///cout<<"key "<<mKey<<" len "<<key_len<<endl;
                next_state = qa.getNextState(mRecord + st + 1, key_len, KEY);
                while (mRecord[ed] != ':') ++ed; 
                pos = ed + 1;
                element_type = getElementType(pos);
                ///cout<<"before next primitive "<<substring_200(mRecord, pos, pos +100)<<endl;
            }
        }
        if (result == OBJECT_END)
            return;
        // int next_state = 0;
        /*if (attribute_type != PRIMITIVE) {
        long st = 0;
        long ed = 0;
        long cur_pos = pos;
        // find the previous colon
        /// cout<<qa.mCurState<<" "<<attribute_type<<" before colon check "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
        while (mRecord[cur_pos] != ':') --cur_pos; 
        /// cout<<"colon check "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
        findFieldQuotePos2(cur_pos, st, ed);
        int key_len = ed - st - 1;
        next_state = qa.getNextState(mRecord + st + 1, key_len, KEY);
        } */
        if (attribute_type != PRIMITIVE) {
            long st = pos;
            while (mRecord[st] != ':') --st;
            while (mRecord[st] != '"') --st;
            long ed = st - 1;
            while (mRecord[ed] != '"') --ed;
            int key_len = st - ed - 1;
            //memcpy(mKey, mRecord + ed + 1, key_len);
            //mKey[key_len] = '\0';
            ///cout<<"key "<<mKey<<" len "<<key_len<<endl;
            next_state = qa.getNextState(mRecord + ed + 1, key_len, KEY);
        }
        // memcpy(mKey, mRecord + st + 1, key_len);
       //  mKey[key_len] = '\0';
       /// if (strcmp(mKey, "timestamp_ms") != 0) 
        /// cout<<"key "<<mKey<<" "<<next_state<<" cur state "<<qa.mCurState<<" "<<attribute_type<<" "<<pos<<endl;
        /// int element_type = getElementType(pos);
        /*cout<<"element type "<<element_type<<" "<<substring_200(mRecord, pos, pos + 100)<<endl;
        if (element_type != attribute_type) {
            cout<<"ele type "<<element_type<<" "<<attribute_type<<endl;
        }*/
        if (next_state == UNMATCHED_STATE) {
            switch (element_type) {
                case OBJECT:
                    skipObject(pos, bm);
                    break;
                case ARRAY:
                    skipArray(pos, bm);
                    break;
                case PRIMITIVE: {
                    ///cout<<"before skipping primitive "<<substring_200(mRecord, pos, pos + 100)<<endl;
                    skipPrimitiveObj(pos, bm);
                    //++pos;
                    /// cout<<"after skipping primitive "<<substring_200(mRecord, pos, pos + 100)<<endl;

                }
            }
        } else if (qa.getType(next_state) == OUTPUT_CANDIDATE) { //ACCEPT
            ++mOutputSize;
            long start_pos = pos;
            switch (element_type) {
                case OBJECT: {
                    skipObject(pos, bm);
                    break;
                }
                case ARRAY: {
                    skipArray(pos, bm);
                    break;
                }
                case PRIMITIVE:
                    skipPrimitiveObj(pos, bm);
                    ++pos;
            }
            long end_pos = pos;
            long text_length = end_pos - start_pos + 1;
            memcpy(mText, mRecord + start_pos, text_length);
            mText[text_length] = '\0';
            mOutput.append(mText);
            /// cout<<"text "<<mText<<endl;
            /// cout<<"going to skip remaining pairs1 "<<substring_200(mRecord, pos, pos + 64)<<endl;
            if (mRecord[pos] != '}') {
                if (qa.getStackSize() == 0) return;
                cout<<"prev pos "<<pos<<endl;
                skipFollowingAttributes(pos, bm);
                cout<<"after pos "<<pos<<endl;
                // skipObject(pos, bm);
            }
            ///cout<<"after skip remaining pairs1 "<<substring_200(mRecord, pos, pos + 64)<<endl;  
            break;
        } else {  // in-progress
            qa.pushStack(next_state);
            switch (attribute_type) {
                case OBJECT:
                    object(pos, bm);
                    break;
                case ARRAY:
                    array(pos, bm);
                //case PRIMITIVE:
                //    skipPrimitiveObj(pos, bm);
            }
            qa.popStack(); // virtual token "value"
           /// cout<<"going to skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<endl;
            /// pend_wid = pos;
            if (qa.getStackSize() == 0) return;
            skipFollowingAttributes(pos, bm);
            /// skipObject(pos, bm);
            /// pend_wid1 = pos;
            ///cout<<"after after skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<" st "<<(pend_wid % 64)<<" ed "<<(pend_wid1 % 64)<<endl;
            break;
        }
    }
    // if (hasMoreAttributes(pos))
       // skipObject(pos, bm); 
}

void SerialBitmap::array(long& pos, bitmap& bm) {
    ///if (mRecord[pos + 2] == 'n')
    /// cout<<"process array "<<substring_200(mRecord, pos, pos + 200)<<endl;
    int next_state = qa.getNextStateNoKey(ARRAY);
    qa.pushStack(next_state);
    int element_type = qa.getExpectedValueType();
    long prev_pos = -1; // only use for debugging
    bool flag = false;
    if (qa.hasIndexConstraints()) {
        int start_idx = qa.mDfa.trans_ele[qa.mCurState - 1].start_idx;
        int end_idx = qa.mDfa.trans_ele[qa.mCurState - 1].end_idx;
        /////cout<<"process index constraint "<<start_idx<<" "<<end_idx<<endl;
        int num_elements = end_idx - start_idx;
        if (start_idx > 0) {
            /// if (flag == false) cout<<qa.mCurState<<" jump start index "<<start_idx<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            int result = skipElements(pos, start_idx, bm);
            if (result == ARRAY_END) {
                /////cout<<"array end "<<substring_200(mRecord, pos, pos + 64)<<endl;
                qa.popStack();
                return; 
            }
            /// if(flag == false) cout<<"skip elements before "<<qa.mCurState<<" "<<(start_idx + 1)<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
        }
        while (hasMoreElements(pos) && num_elements > 0) {
            if (qa.getType(qa.mCurState) == OUTPUT_CANDIDATE) {
                ++mOutputSize;
                long start_pos = pos;
                bool break_while = false;
                int value_type = element_type;
                if (element_type == PRIMITIVE) {
                    /// cout<<"state "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    value_type = getElementType(pos); 
                    /*if (value_type != PRIMITIVE) { 
                        cout<<"******value type "<<value_type<<" "<<substring_200(mRecord, pos, pos + 64)<<" "<<start_idx<<" "<<num_elements<<endl;
                        flag = true;
                        long temp_pos = pos  + 3;
                        int result = skipElements(temp_pos, start_idx, bm);
                        cout<<"******check after result "<<qa.mCurState<<" "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<" "<<result<<endl; 
                    }*/
                }
                switch (value_type) {
                    case OBJECT: {
                        skipObject(pos, bm);
                        break;
                    }
                    case ARRAY: {
                        skipArray(pos, bm);
                        break;
                    }
                    case PRIMITIVE: {
                        int result = skipPrimitiveAry(pos, bm);
                        if (result == ARRAY_END) {
                            break_while = true;
                            /////cout<<"break array "<<substring_200(mRecord, pos, pos + 64)<<" "<<num_elements<<endl;
                        }
                    }
                }
                long end_pos = pos;
                long text_length = end_pos - start_pos + 1;
                memcpy(mText, mRecord + start_pos, text_length);
                mText[text_length] = '\0';
                mOutput.append(mText);
                ///if (mOutputSize == 1) 
                  ///cout<<mText<<endl;
                if (break_while) {
                    if (mRecord[pos] != ']')
                        skipFollowingElements(pos, bm);
                        ///skipArray(pos, bm);
                    break;
                }
                --num_elements;
            } else if (qa.mCurState > 0) {
                int result; 
                switch (element_type) {
                    case OBJECT: {
                        /// cout<<"prior pos "<<pos<<endl;
                        result = goToObjElemInRange(pos, num_elements, bm);
                        /// cout<<"after find object pos "<<pos<<endl;
                        break;
                    }
                    case ARRAY: {
                        result = goToAryElemInRange(pos, num_elements, bm);
                        /// break;
                    }
                    // impossible
                    /*case PRIMITIVE: {
                        /// result = goToPrimElemInRange(pos, num_elements, bm);
                        result = SUCCESS;
                    }*/
                }
                if (result == SUCCESS) {
                    /*int value_type = element_type;
                    if (element_type != PRIMITIVE)
                        value_type = getElementType(pos);*/
                    switch (element_type) {
                        case OBJECT:
                            prev_pos = pos;
                            object(pos, bm);
                            // cout<<"after skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<endl;
                            break;
                        case ARRAY: {
                            /// cout<<"going to array with constraint "<<qa.mCurState<<endl;
                            array(pos, bm);
                        }
                    }
                    --num_elements;
                } else if (result == ARRAY_END) {
                    qa.popStack();
                    return;
                } else if (result == RANGE_END) {
                    if (mRecord[pos] != ']') {
                        if (qa.getStackSize() == 1) return;
                        /// skipArray(pos, bm);
                        skipFollowingElements(pos, bm);
                    }
                    break;
                }
            }
        }
        /////cout<<"out of while loop for array "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 200)<<endl;
        if (mRecord[pos] != ']') {
            if (qa.getStackSize() == 1) return;
            /// skipArray(pos, bm);
            skipFollowingElements(pos, bm);
            /////cout<<"after out of while loop for array "<<substring_200(mRecord, pos, pos + 200)<<endl;
        }
    } else {
    /// cout<<"array state "<<next_state<<" element type "<<element_type<<endl;
    while (hasMoreElements(pos)) {
        ///cout<<"cur state "<<qa.mCurState<<" next token "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
        if (qa.getType(qa.mCurState) == OUTPUT_CANDIDATE) {
            ++mOutputSize;
            long start_pos = pos;
            bool break_while = false;
            int value_type = element_type;
            if (element_type == PRIMITIVE)
                value_type = getElementType(pos);
            ///cout<<"output "<<value_type<<" "<<mRecord[pos]<<" "<<getElementType(pos)<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            switch (value_type) {
                case OBJECT: {
                    skipObject(pos, bm);
                    break;
                }
                case ARRAY: {
                    skipArray(pos, bm);
                    break;
                }
                case PRIMITIVE: {
                    int result = skipPrimitiveAry(pos, bm);
                    if (result == ARRAY_END) {
                        break_while = true;
                    }
                }
            }
            long end_pos = pos;
            long text_length = end_pos - start_pos + 1;
            memcpy(mText, mRecord + start_pos, text_length);
            mText[text_length] = '\0';
            mOutput.append(mText);
            /// if (mOutputSize == 2) cout<<mText<<endl;
            if (break_while) break;
        } else if (qa.mCurState > 0) {
             if (getElementType(pos) != element_type) {
                /// cout<<"element type "<<element_type<<" "<<getElementType(pos)<<endl;
                // reset pos for hasMoreElement, TODO: avoid this in the final code
                /// while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') --pos;
                // --pos;
                int result;
                switch (element_type) {
                    case OBJECT:
                        result = goToObjElem(pos, bm);
                        break;
                    case ARRAY:
                        result = goToAryElem(pos, bm);
                        //break;
                    // impossible
                    /*case PRIMITIVE:
                        result = goToPrimElem(pos, bm);*/
                }
                /// cout<<"after skipping "<<result<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                if (result == ARRAY_END) {
                    qa.popStack();
                    return;
                }
            }
            /*if (getElementType(pos) != element_type) {
                 cout<<"before visit object "<<substring_200(mRecord, prev_pos, prev_pos + 64)<<endl; 
                cout<<pend_wid<<" before skip remaining pairs "<<substring_200(mRecord, pend_wid, pend_wid + 200)<<endl;
                cout<<pend_wid1<<" after skip remaining pairs "<<substring_200(mRecord, pend_wid1, pend_wid1 + 200)<<endl;
                cout<<pos<<" char "<<mRecord[pos]<<"type "<<getElementType(pos)<<" expected type "<<element_type<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            }*/
            /// cout<<"get the target element "<<element_type<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            switch (element_type) {
                case OBJECT:
                    prev_pos = pos;
                    object(pos, bm);
                    // cout<<"after skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    break;
                case ARRAY: {
                    /// cout<<"going to array "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 100)<<endl;
                    array(pos, bm);;
                }
            } 
            
        }
        /// cout<<"before check hasMoreElement "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 64)<<endl; 
    }
    }
    qa.popStack();
    /// cout<<"end array "<<qa.mCurState<<endl; 
}

__attribute__((always_inline)) void SerialBitmap::skipV2() {
    int bracket_cnt = 0;
    if (cur_word == true) {
        while (cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            //if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            //else --bracket_cnt;
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            else --bracket_cnt;
            if (bracket_cnt == 0) return;
        }
        ++start_id;
        cur_word = false;
    }
    unsigned long colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long quotebit, escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long colonbit, commabit;
    unsigned long str_mask;
   unsigned long bracketbit;
    __m256i v_text0, v_text;
   /// unsigned long cb_mask, mask;
    //unsigned long bracket_bit;
    while (start_id < mNumTmpWords) {
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        lbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbrace));
        rbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbrace));
         lbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbracket));
        rbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbracket));
        /*__m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));*/
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            lbracebit0 = lbracebit;
            rbracebit0 = rbracebit;
            lbracketbit0 = lbracketbit;
            rbracketbit0 = rbracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            lbracebit = (lbracebit << 32) | lbracebit0;
            rbracebit = (rbracebit << 32) | rbracebit0;
            lbracketbit = (lbracketbit << 32) | lbracketbit0;
            rbracketbit = (rbracketbit << 32) | rbracketbit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            lbracebit = lbracebit & tmp;
            rbracebit = rbracebit & tmp;
            lbracketbit = lbracketbit & tmp;
            rbracketbit = rbracketbit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = lbracketbit;
            if (cb_mask) {
                first = 1;
                //cout<<"start id "<<start_id<<endl;
                while (cb_mask || first) {
                    //cout<<"cb mask "<<cb_mask<<endl;
                    cb_bit = cb_mask & (-cb_mask);
                    second = cb_bit;
                    if (!cb_mask) {
                        second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                    }
                    mask = second - first;
                    if (!cb_mask) {
                        first = 0;
                        mask = mask | second;
                    }
                    unsigned long rb_mask = rbracketbit & mask;
                    int cnt = __builtin_popcountl(rb_mask);
                    bracket_cnt -= cnt;
                    if (cnt > 0 && bracket_cnt == 0) {
                        cout<<"cnt0 "<<bracket_cnt<<" "<<cnt<<endl;
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        return;
                    }  
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    if (cb_mask) {
                    ++bracket_cnt;
                    //first = second;
                     /*if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                    else --bracket_cnt;*/
                    first = second;
                    cb_mask = cb_mask & (cb_mask - 1);
                    }
                //mask = second - first;
                    /*second = cb_mask & (-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                    }
                    mask = second - first;
                    if (!cb_mask)
                        mask = mask | second;
                    unsigned long rb_mask = rbracketbit & mask;
                    int cnt = __builtin_popcountl(rb_mask);
                    bracket_cnt -= cnt;
                    if (cnt > 0 && bracket_cnt == 0) {
                        cout<<"cnt0 "<<bracket_cnt<<" "<<cnt<<endl;
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        return;
                    } 
                    colon_mask = mask & colonbit;
                    comma_mask = mask & commabit;
                    ++bracket_cnt;*/
                    /*if (mRecord[cur_pos] == '[') ++bracket_cnt;
                    else --bracket_cnt;
                    if (bracket_cnt == 0) {
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        return;
                    }*/
                } 
            } else {
                    int cnt = __builtin_popcountl(rbracketbit);
                    bracket_cnt -= cnt;
                    if (cnt > 0 && bracket_cnt == 0) {
                         cout<<"cnt "<<bracket_cnt<<" "<<cnt<<endl;
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        return;
                    }
                }
            ++start_id;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipV1() {
    int bracket_cnt = 0;
    cout<<"first "<<mRecord[cur_pos]<<endl;
    if (cur_word == true) {
        while (cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            //if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            //else --bracket_cnt;
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            //if (mRecord[cur_pos] == '{' || 
            if (mRecord[cur_pos] == '[') ++bracket_cnt; //|| mRecord[cur_pos] == '{') ++bracket_cnt;
            else if (mRecord[cur_pos] == ']') --bracket_cnt;// || mRecord[cur_pos] =='}')  --bracket_cnt;
            if (bracket_cnt == 0) return;
        }
        /*while (bracket_cnt > 0 && cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            else --bracket_cnt;
            cb_mask = cb_mask & (cb_mask - 1);
        }
        if (bracket_cnt == 0) {
            // information for next interval
            first = second;
            // cb_mask = cb_mask & (cb_mask - 1);
                //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            return;
        }*/
        ++start_id;
        cur_word = false;
    }
    cout<<"initial bracket count "<<bracket_cnt<<endl;
    unsigned long colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long quotebit, escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long colonbit, commabit;
    unsigned long str_mask;
   unsigned long bracketbit;
    __m256i v_text0, v_text;
   /// unsigned long cb_mask, mask;
    //unsigned long bracket_bit;
    while (start_id < mNumTmpWords) {
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
         lbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbrace));
        rbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbrace));
         lbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbracket));
        rbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbracket));
        bracketbit = lbracketbit | rbracketbit | lbracebit | rbracebit;
        /*__m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));*/
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            lbracebit0 = lbracebit;
            rbracebit0 = rbracebit;
            lbracketbit0 = lbracketbit;
            rbracketbit0 = rbracketbit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            lbracebit = (lbracebit << 32) | lbracebit0;
            rbracebit = (rbracebit << 32) | rbracebit0;
            lbracketbit = (lbracketbit << 32) | lbracketbit0;
            rbracketbit = (rbracketbit << 32) | rbracketbit0; 
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            lbracebit = lbracebit & tmp;
            rbracebit = rbracebit & tmp;
            lbracketbit = lbracketbit & tmp;
            rbracketbit = rbracketbit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            if (lbracketbit) {
                first = 1;
                /*while (lbracketbit) {
                    cb_bit = lbracketbit & (-lbracketbit);
                    second = cb_bit;
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    unsigned long rb_mask = rbracketbit & mask;
                    int cnt = __builtin_popcountl(rb_mask);
                    bracket_cnt -= cnt;
                    if (bracket_cnt == 0) {
                        //stop and move onto the next interval (cb_mask)
                    }
                    /*if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                    else --bracket_cnt;*/
                  /*  first = second;
                    lbracketbit = lbracketbit & (lbracketbit - 1);
                //mask = second - first;
                    second = lbracketbit & (-lbracketbit);
                    if (!lbracketbit) {
                        second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                    }
                    mask = second - first;
                    if (!cb_mask)
                        mask = mask | second;
                    colon_mask = mask & colonbit;
                    comma_mask = mask & commabit;
                    //if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                    //else --bracket_cnt;
                    if (bracket_cnt == 0) {
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        return;
                    }
                }*/

                while (lbracketbit) {
                    cb_bit = lbracketbit & (-lbracketbit);
                    // ++bracket_cnt; 
                    second = cb_bit;
                    mask = second - first;
                    unsigned long rb_mask = rbracketbit & mask;
                    int cnt = __builtin_popcountl(rb_mask);
                    bracket_cnt -= cnt;
                    long temp_pos = top_word * 64 + __builtin_ctzll(lbracketbit); ;
                    if (bracket_cnt < 5)  cout<<"bracket cnt "<<bracket_cnt<<" "<<start_id<<" "<<substring_200(mRecord, temp_pos, temp_pos + 100)<<endl;
                    if (bracket_cnt == 0) {
                        // find out ending position
                        cout<<" find "<<start_id<<endl;
                        // leftmost 1
                        int first_lead_zero = __builtin_clzll(rb_mask);
                        unsigned long offset = 64 - first_lead_zero;
                        cur_pos = top_word * 64 + offset - 1;
                        // unsigned long rb_bit = rb_mask &(-rb_mask);
                        // cur_pos = top_word * 64 + __builtin_ctzll(rb_bit);
                        unsigned long mask2 = (1UL << (offset));
                        if (first_lead_zero == 0) {
                            cb_mask = 0;
                            second = (1UL << 63);
                        } else {
                        second = mask2;
                        // unsigned long mask1 = ~mask2;
                        mask2 = mask2 ^ (mask2 - 1);
                        cb_mask = cb_mask & (~mask2);
                        }
                        first = second;
                        second = cb_mask & (-cb_mask);
                        if (!cb_mask) {
                            second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                        }
                        mask = second - first;
                        if (!cb_mask)
                            mask = mask | second;
                        colon_mask = mask & colonbit;
                        comma_mask = mask & commabit;
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        // move onto next interval
                        // second = cb_mask & (-cb_mask);
                        
                        return;
                    }
                    ++bracket_cnt;
                    if (bracket_cnt < 5) {
                        long temp_pos = top_word * 64 + __builtin_ctzll(lbracketbit);
                        cout<<"open bracket "<<substring_200(mRecord, temp_pos, temp_pos + 100)<<endl;
                    }
                    //first = second;
                    // cur_pos = top_word * 64 + __builtin_ctzll(lbracketbit);
                    // cout<<"bracket cnt "<<bracket_cnt<<endl;
                    //lbracketbit = lbracketbit &(lbracketbit - 1);
                     first = second;
                    lbracketbit = lbracketbit & (lbracketbit - 1);
                //mask = second - first;
                    second = lbracketbit & (-lbracketbit);
                    if (!lbracketbit) {
                        second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                    }
                    mask = second - first;
                    if (!cb_mask)
                        mask = mask | second;
                    colon_mask = mask & colonbit;
                    comma_mask = mask & commabit;
                }
                if (mask) {
                    int cnt = __builtin_popcountl(rbracketbit);
                    bracket_cnt -= cnt;
                    //cout<<"bracket cnt "<<bracket_cnt<<endl;
                    if (bracket_cnt == 0) {
                    // find out ending position
                        cout<<" find in word "<<start_id<<endl;
                        // leftmost 1
                        int first_lead_zero = __builtin_clzll(rbracketbit);
                        unsigned long offset = 64 - first_lead_zero;
                        cur_pos = top_word * 64 + offset - 1;
                        cout<<"check "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 100)<<endl;
                        // unsigned long rb_bit = rb_mask &(-rb_mask);
                        // cur_pos = top_word * 64 + __builtin_ctzll(rb_bit);
                        unsigned long mask2 = (1UL << (offset));
                        if (first_lead_zero == 0) {
                            cb_mask = 0;
                            second = (1UL << 63);
                        } else {
                        second = mask2;
                        // unsigned long mask1 = ~mask2;
                        mask2 = mask2 ^ (mask2 - 1);
                        cb_mask = cb_mask & (~mask2);
                        }
                        first = second;
                        second = cb_mask & (-cb_mask);
                        if (!cb_mask) {
                            second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                        }
                        
                        mask = second - first;
                        if (!cb_mask)
                            mask = mask | second;
                        colon_mask = mask & colonbit;
                        comma_mask = mask & commabit;
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        // move onto next interval
                        // second = cb_mask & (-cb_mask);

                        return;
                    }        
                }
                /// int cnt =  __builtin_popcountl(rbracketbit); 
            } else {
                int cnt = __builtin_popcountl(rbracketbit);
                bracket_cnt -= cnt;
                //cout<<"bracket cnt "<<bracket_cnt<<endl;
                if (bracket_cnt == 0) {
                    // find out ending position
                    cout<<" find in word 1 "<<start_id<<endl;
                    // leftmost 1
                    int first_lead_zero = __builtin_clzll(rbracketbit);
                    unsigned long offset = 64 - first_lead_zero;
                    cur_pos = top_word * 64 + offset - 1;
                    cout<<"check "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 100)<<endl;
                        // unsigned long rb_bit = rb_mask &(-rb_mask);
                        // cur_pos = top_word * 64 + __builtin_ctzll(rb_bit);
                    unsigned long mask2 = (1UL << (offset));
                    if (first_lead_zero == 0) {
                        second = 1UL << 63; 
                        cb_mask = 0;
                    } else {
                    ////mask2 = 1UL << 64 - 1;
                    second = mask2;
                        // unsigned long mask1 = ~mask2;
                    mask2 = mask2 ^ (mask2 - 1);
                    bitset<64> tmpmask2(mask2);
                    cout<<"mask2 "<<tmpmask2<<" "<<offset<<endl;
                    cb_mask = cb_mask & (~mask2);
                    }
                    first = second;
                    second = cb_mask & (-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                    }
                    mask = second - first;
                    if (!cb_mask)
                        mask = mask | second;
                    bitset<64> tempbit(rbracketbit);
                    bitset<64> tempbit1(cb_mask);
                    cout<<"bit "<<tempbit<<" "<<tempbit1<<endl;
                    colon_mask = mask & colonbit;
                    comma_mask = mask & commabit;
                    this->colonbit = colonbit;
                    this->commabit = commabit;
                    this->cb_mask = cb_mask;
                    this->mask = mask;
                    cur_word = true;
                    
                        // move onto next interval
                        // second = cb_mask & (-cb_mask);

                    return;
                } 
            }
            /*cb_mask = bracketbit;
            if (cb_mask) {
                first = 1;
                while (cb_mask) {
                    cb_bit = cb_mask & (-cb_mask);
                    second = cb_bit;
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    /*if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                    else --bracket_cnt;*/
              /*      first = second;
                    cb_mask = cb_mask & (cb_mask - 1);
                //mask = second - first;
                    second = cb_mask & (-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                    }
                    mask = second - first;
                    if (!cb_mask)
                        mask = mask | second;
                    colon_mask = mask & colonbit;
                    comma_mask = mask & commabit;
                    if (mRecord[cur_pos] != '[' && mRecord[cur_pos] != ']')
                        cout<<"check "<<mRecord[cur_pos]<<" "<<bracket_cnt<<endl;
                    if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                    else --bracket_cnt;
                    if (bracket_cnt == 0) {
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        return;
                    }
                }
                /*while (bracket_cnt > 0 && cb_mask) {
                    cb_bit = cb_mask & (-cb_mask);
                    second = cb_bit;
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    char ch = mRecord[cur_pos];
                    if (ch == '{' || ch == '[') ++bracket_cnt;
                    else --bracket_cnt;
                   // first = second;
                    cb_mask = cb_mask & (cb_mask - 1);
                }
                if (bracket_cnt == 0) {
                    // update next interval information
                    first = second;
                    second = cb_mask &(-cb_mask); 
                    if (!cb_mask) {
                        second = 1UL<<63;
                    }
                    mask = second - first;
                    if (!cb_mask) {
                        mask = mask | second;
                    }
                    colon_mask = colonbit & mask;
                    comma_mask = commabit & mask; 
                    cur_word = true;
                    // cout<<"finish jump "<<start_id<<endl;
                    return;
                }*/
            //}
            ++start_id;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipV() {
    ///if (start_id > 5000) return;
    int bracket_cnt = 1;
    while (true) {
     ///   cout<<"before jump to next bracket "<<endl;
        jumpToNextBracket();
     ///   cout<<"skip bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
        if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
        else {
            --bracket_cnt;
            if (bracket_cnt == 0) break;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipE() {
    ///if (start_id > 5000) return;
    int bracket_cnt = 0;
    while (true) {
     ///   cout<<"before jump to next bracket "<<endl;
        bitmap bm;
        jumpToNextBracket1(bm);
     ///   cout<<"skip bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
        if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
        else {
            --bracket_cnt;
            if (bracket_cnt == 0) {
         /////       cout<<"ends skipping E"<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
                break;
            }
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipE1() {
    int bracket_cnt = 0;
    if (cur_word == true) {
        while (cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            //if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            //else --bracket_cnt;
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            else {
                --bracket_cnt;
                if (bracket_cnt == 0) return;
            }
        }
         ++start_id;
        cur_word = false;
    }
    unsigned long colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long quotebit, escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long colonbit, commabit;
    unsigned long str_mask;
   unsigned long bracketbit;
    __m256i v_text0, v_text;
   /// unsigned long cb_mask, mask;
    //unsigned long bracket_bit;
    while (start_id < mNumTmpWords) {
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            if (cb_mask) {
                first = 1;
                while (cb_mask) {
                    cb_bit = cb_mask & (-cb_mask);
                    second = cb_bit;
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    /*if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                    else --bracket_cnt;*/
                    first = second;
                    cb_mask = cb_mask & (cb_mask - 1);
                //mask = second - first;
                    second = cb_mask & (-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;  //TODO: set second to be zero later
                        //mask = mask | second;
                    }
                    mask = second - first;
                    if (!cb_mask)
                        mask = mask | second;
                    colon_mask = mask & colonbit;
                    comma_mask = mask & commabit;
                    if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                    else {
                    --bracket_cnt;
                    if (bracket_cnt == 0) {
                        this->colonbit = colonbit;
                        this->commabit = commabit;
                        this->cb_mask = cb_mask;
                        this->mask = mask;
                        cur_word = true;
                        return;
                    }
                    }
                }
            }
            ++start_id;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipKVsAfter1() {
    /// cout<<"start final skipping "<<endl;
    int bracket_cnt = 0;
    if (cur_word == true) {
        while (bracket_cnt >= 0 && cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            else --bracket_cnt;
            // information for next interval
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
        }
        if (bracket_cnt == -1) {
                //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
        ///    cout<<"finish jump "<<start_id<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
            return;
        }
        ++start_id;
        cur_word = false;
    }
    unsigned long colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long quotebit, escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long colonbit, commabit;
    unsigned long str_mask;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
    while (start_id < mNumTmpWords) {
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            if (cb_mask) {
                first = 1;
                while (bracket_cnt >= 0 && cb_mask) {
                    cb_bit = cb_mask & (-cb_mask);
                    second = cb_bit;
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    char ch = mRecord[cur_pos];
                    if (ch == '{' || ch == '[') ++bracket_cnt;
                    else --bracket_cnt;
                    first = second;
                    cb_mask = cb_mask & (cb_mask - 1);
                    // update next interval information
                   // first = second;
                    /*second = cb_mask &(-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;
                    }
                    mask = second - first;
                    if (!cb_mask) {
                        mask = mask | second;
                    }
                    colon_mask = colonbit & mask;
                    comma_mask = commabit & mask;
                    */
                }
                if (bracket_cnt == -1) {
                    // update next interval information
                    first = second;
                    second = cb_mask &(-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;
                    }
                    mask = second - first;
                    if (!cb_mask) {
                        mask = mask | second;
                    }
                    colon_mask = colonbit & mask;
                    comma_mask = commabit & mask;
                    this->colonbit = colonbit;
                    this->commabit = commabit;
                    cur_word = true;
           ///          cout<<"finish jump "<<start_id<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
                    return;
                }
            }
            ++start_id;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipKVsAfter() {
    //if (mRecord[cur_pos] == '}') return;
    // check root level before calling it
    int bracket_cnt = 0;
    while (true) {
        jumpToNextBracket();
        // first check curent word
    /*if (cur_word == true)
    {  // inside current word
        if (cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
           ///  cout<<"jump to bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            /*bitset<64> tempbit(cb_mask);
                bitset<64> tempbit1(colonbit);
                if(start_id > 130 && start_id < 124) cout<<"temp bit "<<tempbit<<" "<<tempbit1<<endl;
            if (start_id > 60 && start_id < 70) cout<<"1 jump to next bracket "<<start_id<<" "<<colonbit<<" "<<colon_mask<<" "<<cb_bit<<endl;
           */
            // return;
      /*      if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            else {
                --bracket_cnt;
                if (bracket_cnt == -1) return;
            }
            continue;
        } else {
            // interval ends with no bracket
            ++start_id;
            cur_word = false;
        }
    }
    unsigned long str_mask;
    unsigned long escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
   unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long cb_mask1 = cb_mask;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
   unsigned long sid = start_id;
   unsigned long colonbit, commabit;
   while (sid < mNumTmpWords) {
        /// if (cur_pos > 63028) cout<<"sid jump "<<sid<<endl;
        //create relevant bitmaps
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = sid * 32;
        if (sid > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(sid % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++sid;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask1 = bracketbit;
            if (cb_mask1) {
                // has jumped to next bracket
                first = 1;
                cb_bit = cb_mask1 & (-cb_mask1);
                second = cb_bit;
                cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                /// cout<<"ch "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
                first = second;
                cb_mask1 = cb_mask1 & (cb_mask1 - 1);
                //mask = second - first;
                second = cb_mask1 & (-cb_mask1);
                if (!cb_mask1) {
                    second = 1UL<<63;  //TODO: set second to be zero later
                    //mask = mask | second;
                }
                mask = second - first;
                if (!cb_mask1)
                    mask = mask | second;
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                cur_word = true;
                 cb_mask = cb_mask1;
                start_id = sid;
                this->colonbit = colonbit;
                this->commabit = commabit;
                //return;
                if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
                else {
                    --bracket_cnt;
                    if (bracket_cnt == -1) return;
                }
                break;
            }
            ++sid;
        }
    }
       
        if (bracket_cnt == -1) break; 
 */
        if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
        else {
            --bracket_cnt;
            if (bracket_cnt == -1) break;
        }
    }
}

__attribute__((always_inline)) bool SerialBitmap::skipUnmatchedKVs() {
    /////cout<<"enter jump "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<mRecord[cur_pos+1]<<mRecord[cur_pos+2]<<" "<<mRecord[cur_pos-1]<<mRecord[cur_pos-2]<<mRecord[cur_pos-3]<<mRecord[cur_pos-4]<<mRecord[cur_pos-5]<<endl;
    ///if (mRecord[cur_pos] == '}') return false;
    int expected_type = qa.getExpectedValueTypeObj();
    if (expected_type != PRIMITIVE) {
        char bracket_ch = '[';
        if (expected_type == OBJECT) bracket_ch = '{';
    ///    cout<<"expected type "<<expected_type<<" "<<qa.mCurState<<endl;
        while (true) {
    ///        cout<<"before jump "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<" "<<cur_pos<<endl;
            jumpToNextBracket();
    ///        cout<<"check next bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<bracket_ch<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
            if (mRecord[cur_pos] == '}') return false;
            // back to the colon position
            //--cur_pos;
            //while (mRecord[cur_pos] == ' ') --cur_pos; 
            if (mRecord[cur_pos] == bracket_ch) {
                // back to the colon position
           /////     cout<<"[before jump]: find colon pos "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<" "<<"true"<<endl; 
                --cur_pos;
                while (mRecord[cur_pos] == ' ') --cur_pos;
           /////     cout<<"[jump]: find colon pos "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<" "<<"true"<<endl;
                return true;
            }
         ///   cout<<"try to skip V "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
            skipV();
        ///    cout<<"after skip V "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
        }
    } else {
     ///  cout<<"expected primitive "<<endl;
       while (hasMoreKV()) {
         /// cout<<"before calling jump next kv ... "<<endl;
           jumpToNextKV();
        /// cout<<qa.mCurState<<"colon pos "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
           int type = getVType(); 
           if (type != PRIMITIVE) {
           ///    cout<<"find unmatched value type "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
               skipE();
           ///    cout<<"skipe "<<qa.mCurState<<"colon pos "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
           } else return true;
       }
    }
    return false;
}

__attribute__((always_inline)) void SerialBitmap::outputV() {
    long start_pos = cur_pos + 1;
    // calculate end pos in the following steps
    unsigned long sid = start_id;
    if (cur_word == true) {
        int offset = cur_pos % 64;
        unsigned long cmask = (1UL << offset);
        unsigned long cmask1 = ~cmask;
        cmask = cmask ^ (cmask - 1);
        cmask = ~(cmask & cmask1);
        unsigned long endbits = (comma_mask | cb_mask) & cmask;
        // find end position of k-prim pair
        if (endbits > 0) {
            cur_pos = top_word * 64 + __builtin_ctzll(endbits);
                long text_length = cur_pos - start_pos + 1;
                memcpy(mText, mRecord + start_pos, text_length);
                mText[text_length] = '\0';
                mOutput.append(mText);
                ++mOutputSize;
            //////if (mOutputSize > 17715) 
            /////cout<<"find current "<<(cur_pos - start_pos + 1)<<" "<<mText<<" "<<qa.mCurState<<" "<<mOutputSize<<" "<<start_id<<" "<<top_word<<endl;
            return; 
        }
     ///   cout<<"no ending position found "<<offset<<endl;
        ++start_id;
        cur_word = false;
    }
    unsigned long str_mask;
    unsigned long escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    // check following words for ending position of interval
    while (start_id < mNumTmpWords) {
        //create relevant bitmaps
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            unsigned long endbits = (commabit | bracketbit);
            if (endbits > 0) {
            ///    cout<<"calculate end bits position"<<endl;
                cur_pos = top_word * 64 + __builtin_ctzll(endbits);
                long text_length = cur_pos - start_pos + 1;
                memcpy(mText, mRecord + start_pos, text_length);
                mText[text_length] = '\0';
                mOutput.append(mText);
                ++mOutputSize;
                /////if (mOutputSize > 17715) 
                ///// cout<<"find "<<mText<<" "<<mOutputSize<<" "<<start_id<<" "<<top_word<<endl;
                /// cout<<"findz "<<(cur_pos - start_pos + 1)<<" "<<substring_200(mRecord, start_pos + 1, cur_pos)<<" "<<mRecord[cur_pos]<<" "<<cb_mask<<endl;
                // end of object
                /*if (mRecord[cur_pos] == '}') {
                    cout<<"end of object"<<endl;          
                }*/
                if (cb_mask) {
                    first = 1;
                    second = cb_mask & (-cb_mask);
                    mask = second - first;
                    colon_mask = colonbit & mask;
                    comma_mask = commabit & mask;
                } else {
                    //cout<<"no bracket in the word "<<endl;
                    colon_mask = colonbit;
                    comma_mask = commabit;
                }
                cur_word = true;
                return;
            }
           /// cout<<"no end bits "<<start_id<<" "<<endbits<<endl;
        }
        ++start_id;
    }


    // start from current word
    /*if (colon_mask) return true;
    if (cb_mask) {  // move to next interval and return false
        cb_bit = cb_mask & (-cb_mask);
        second = cb_bit;
        cur_pos = top_word * 64 + __builtin_ctzll(cb_bit); // no more K-V
        first = second;
        cb_mask = cb_mask & (cb_mask - 1);
        // mask = second - first;
        second = cb_mask & (-cb_mask);
        if (!cb_mask) {
            second = 1UL<<63;  //TODO: set second to be zero later
            // mask = mask | second;
        }
        mask = second - first;
        if (!cb_mask) {
            mask = mask | second;
        }
        colon_mask = mask & colonbit;
        comma_mask = mask & commabit;
        cur_word = true;
        return false;
    }*/

}

void SerialBitmap::proc_obj() {
   /// cout<<"start obj "<<endl;
    qa.iniVisitArray();
    bitset<64> tempbit(colon_mask);
 ///   cout<<"obj: start while loop "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<cur_word<<" word id "<<start_id<<" colon mask "<<tempbit<<" "<<cb_mask<<endl;
    while (skipUnmatchedKVs()) {
       ///if (start_id > 5000) break;
       // TODO: getK (okay)
       long st = 0;
       long ed = 0;
   ///// if(mOutputSize >= 18032)   cout<<" find field quote pos "<<" word id "<<start_id<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
       findFieldQuotePos2(cur_pos, st, ed);
    ///   cout<<"st "<<st<<" ed "<<ed<<endl;
       int key_len = ed - st - 1;
       char* testtt = mRecord + st + 1;
       // memcpy(mKey, testtt, key_len);
       memcpy(mKey, mRecord + st + 1, key_len);
       mKey[key_len] = '\0';
//////   if(qa.mCurState == 6)   
      /////if(mOutputSize >= 18032)     cout<<"substring "<<substring_200(mRecord, st + 1, st + 1 + key_len)<<" "<<st<<" "<<ed<<" "<<key_len<<" "<<testtt[0]<<testtt[1]<<endl;
       int next_state = qa.getNextState(mRecord + st + 1, key_len, KEY);
       /*if (next_state > 0) {
        cout<<"substring "<<substring_200(mRecord, st + 1, st + 1 + key_len)<<endl;
       cout<<"next state "<<next_state<<endl;
       }*/
       if (next_state == 0) {
           int type = getVType();  
        /////   if (mOutputSize >= 18032) cout<<"type "<<type<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<mRecord[cur_pos + 1]<<mRecord[cur_pos +2]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
           if (type == OBJECT || type == ARRAY) {
              cout<<"skip for "<<mKey<<endl;
               if (strcmp(mKey, "routes") == 0) {
                    cout<<"routes "<<endl; 
                    skipV1();
               }
   ///            cout<<" skip V "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<start_id<<endl;
               else skipV();
      ///         cout<<"after  skip V "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<start_id<<endl; 
           } else {
               //TODO: skip primitive and move to next key (okay)
            ///   cout<<"try to jump to next KV "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
               /*if (hasMoreKV()) {
                   cout<<"non matched skip kv "<<endl;
                   jumpToNextKV();
               ///    cout<<"jumped to next KV "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
               }*/
            ///   cout<<"try to jump to next KV after jump "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
           }
           continue;
       } else {
           qa.pushStack(next_state);
      //////     cout<<"state after push "<<qa.mCurState<<" "<<qa.getExpectedValueTypeObj()<<" "<<substring_200(mRecord, st + 1, st + 1 + key_len)<<endl;
           if (qa.getType(next_state) == OUTPUT_CANDIDATE) {
               //TODO: get output content for object/array
          /////    cout<<"before output V "<<endl;
              outputV();
             /// cout<<"after output V "<<endl;
        ///       ++mOutputSize;
             //  start_pos = cur_pos + 1;
             
           } else {
               int type = getVType();
               ///cout<<"check v type "<<type<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
               if (type == OBJECT) proc_obj();
               else if (type == ARRAY) {
                  /// cout<<"process array "<<endl;
                   proc_ary();
               }
           }
           qa.popStack();
           if (qa.hasFoundFields()) {
         ///  cout<<"found matched before break "<<qa.mCurState<<endl;
          ///// if (mOutputSize >= 18032)
          ///// cout<<"before calling skip KV after "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<" "<<start_id<<endl;
           if (qa.getStackSize() == 0) return;
           skipKVsAfter();
         ///// if (mOutputSize >= 18032)
         ///// cout<<"after calling skip KV after "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<" "<<start_id<<endl;
       
           break;
           }
       }
    }
 /////   cout<<"end proc obj "<<qa.mCurState<<" pos "<<mRecord[cur_pos]<<endl;
    /*cout<<"before calling skip KV after "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
    skipKVsAfter();
    cout<<"after calling skip KV after "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
     */
}

__attribute__((always_inline)) void SerialBitmap::skipEsBefore(int idx_begin) {
    ///qa.mArrCounter = -1;
    while (hasMoreElements()) {
        jumpToNextArrayElement();
        qa.addArrayCounter();
      ///  cout<<"counter "<<qa.mArrCounter<<" "<<idx_begin<<" "<<start_id<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<" etype "<<getEType()<<endl;
        if (qa.mArrCounter == idx_begin) break;
        if (getEType() != PRIMITIVE)
            skipE();
         ///cout<<"counter after "<<qa.mArrCounter<<" "<<idx_begin<<" "<<start_id<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
    }
}

__attribute__((always_inline)) int SerialBitmap::skipTypeUnmatchedEs(int idx_end) {
    ///if (mRecord[cur_pos] == ']') return false;
    int expected_type = qa.getExpectedValueType();
    /// cout<<"expected type "<<expected_type<<endl;
    if (expected_type != PRIMITIVE) {
        char bracket_ch = '[';
        if (expected_type == OBJECT) bracket_ch = '{';
        /// cout<<"before calling jump to next "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<" "<<qa.mArrCounter<<endl;
        while (jumpToNextBracketWithIndexChecking()) {
            /// cout<<"jump counter "<<qa.mCurState<<" "<<qa.mArrCounter<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
            if (mRecord[cur_pos] == ']') return END;
            if (mRecord[cur_pos] == bracket_ch) {
                /// cout<<"return "<<mRecord[cur_pos]<<endl;
                return TRUE;
            }
            skipV();
        }
    } else {
        // primitive output indicated by idx_begin
        /*if (qa.mArrCounter > -1) {
            outputV();
        }*/
        /////cout<<"expected a primitive "<<qa.mCurState<<endl;
        bool has_index_constraint = qa.hasIndexConstraints();
        if (has_index_constraint == true) {
            int start_idx = qa.mDfa.trans_ele[qa.mCurState - 1].start_idx;
            if (qa.mArrCounter == start_idx && qa.getType(qa.mCurState) == OUTPUT_CANDIDATE)
                outputV();
        }
        while (hasMoreElements()) {
            jumpToNextArrayElement();
            qa.addArrayCounter();
           ///  cout<<"primitive array counter "<<qa.mCurState<<" "<<qa.mArrCounter<<" "<<cur_pos<<" pos "<<mRecord[cur_pos]<<" end "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
            if (has_index_constraint && qa.mArrCounter >= idx_end) break;
            int type = getEType();
         ///   cout<<"etype "<<type<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
            if (type != PRIMITIVE) {
                skipE();
            } else return TRUE;
        }
        if (mRecord[cur_pos] == ']') return END;
    }
    return FALSE;
}

__attribute__((always_inline)) bool SerialBitmap::hasMoreElements() {
    // the first element
    if (qa.mArrCounter == -1) {
      /////  cout<<"first "<<mRecord[cur_pos]<<" "<<cur_pos<<endl;
      ///   cur_pos = cur_pos + 2;
        return true;
    }
    if (cur_word == true) {
        // start from current word
        if (comma_mask) return true;
        if (cb_mask) {  // move to next interval and return false
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit); // last_colon_pos
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            // mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
                //mask = mask | second;
            }
            mask = second - first;
            if (!cb_mask) {
                mask = mask | second;
            }
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            cur_word = true;
            return false;
        }
        ++start_id;
        cur_word = false;
    }
    unsigned long str_mask;
    unsigned long escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
    // check following words for ending position of interval
    while (start_id < mNumTmpWords) {
        //create relevant bitmaps
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
             uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            if (cb_mask) {
                // decision is based on colon_mask
                // reached the end of interval
                // has jumped to next bracket
                first = 1;
                cb_bit = cb_mask & (-cb_mask);
                second = cb_bit;
                    /// cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                mask = second - first;
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                if (comma_mask) {
                    cur_word = true;
                    return true;
                }
                cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                // move onto next interval
                first = second;
                cb_mask = cb_mask & (cb_mask - 1);
                second = cb_mask & (-cb_mask);
                // mask = second - first;
                if (!cb_mask) {
                    second = 1UL<<63;  //TODO: set second to be zero later
                    ///mask = mask | second;
                }
                mask = second - first;
                if (!cb_mask) {
                    mask = mask | second;
                }
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                cur_word = true;
                return false;
            } else {
                // check colon bit instead
                colon_mask = colonbit;
                comma_mask = commabit;
                if (comma_mask) {
                    cur_word = true;
                    return true;
                }
                // check next word, since result is UNKNOWN
                cur_word = false;
                ++start_id;
            }
        }
    }
    return false;
}

__attribute__((always_inline)) void SerialBitmap::jumpToNextArrayElement() {
    // the first element
    if (qa.mArrCounter == -1) {
        ++cur_pos;
        if (mRecord[cur_pos - 1] == ':') {
        int temp_cur_pos = cur_pos;
        /// cout<<"return the first element "<<mRecord[cur_pos]<<endl;
        /// cur_pos = cur_pos + 1;
        while (mRecord[cur_pos] == ' ') ++cur_pos;
        /// cout<<"next character "<<mRecord[cur_pos]<<endl;
        ++cur_pos;
         // end of array
         if (mRecord[cur_pos] == ']')
         /// cout<<"next character "<<mRecord[cur_pos]<<" "<<mRecord[cur_pos - 1]<<endl;
         cur_pos = temp_cur_pos;
        }
        return;
    }
    cur_pos = top_word * 64 + __builtin_ctzll(comma_mask) + 1;   // last_colon_pos
    comma_mask = comma_mask & (comma_mask - 1);
  /////  cout<<"return enxt "<<cur_pos<<" "<<mRecord[cur_pos]<<endl;
}

__attribute__((always_inline)) bool SerialBitmap::jumpToNextBracketWithIndexChecking() {
    int start_idx = -1, end_idx = -1;
    bool has_index_constraint = qa.hasIndexConstraints();
    ///cout<<"cur state "<<qa.mCurState<<endl;
    if (has_index_constraint) {
        start_idx = qa.mDfa.trans_ele[qa.mCurState - 1].start_idx;
        end_idx = qa.mDfa.trans_ele[qa.mCurState - 1].end_idx;
       ///  cout<<"start idx "<<start_idx<<" end "<<end_idx<<" ini counter "<<qa.mArrCounter<<endl;
    }
    // first check curent word
    if (cur_word == true)
    {  // inside current word
        if (cb_mask) {
            bool res = true;
            if (has_index_constraint) {
                qa.mArrCounter += __builtin_popcountl(comma_mask);
                if (qa.mArrCounter >= end_idx) res = false;
            ///    if (res == false) cout<<"error counter "<<qa.mArrCounter<<endl;
                //// return false;
            }
            // move onto next interval
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
          ///  cout<<"bracket "<<mRecord[cur_pos]<<endl;
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
            second = cb_mask & (-cb_mask);
            // mask = second - first;
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) {
                mask = mask | second;
            }
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
            return res;
        } else {
            // interval ends with no bracket
            if (has_index_constraint) {
                qa.mArrCounter += __builtin_popcountl(comma_mask);
                //if (qa.mArrCounter > end_idx) res = false;
            }
            ++start_id;
            cur_word = false;
        }
    }
    unsigned long str_mask;
    unsigned long escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
   unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
    while (start_id < mNumTmpWords) {
       ///  if (cur_pos > 63028) cout<<"sid "<<start_id<<endl;
        //create relevant bitmaps
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
        colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            if (cb_mask) {
                bool res = true;
                // has jumped to next bracket
                first = 1;
                cb_bit = cb_mask & (-cb_mask);
                second = cb_bit;
                if (has_index_constraint) {
                    mask = second - first;
                    comma_mask = mask & commabit;
                    qa.mArrCounter += __builtin_popcountl(comma_mask);
                    if (qa.mArrCounter >= end_idx) res = false;
              ///      if (res == false) cout<<"error counter "<<qa.mArrCounter<<endl;
                    /// cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    /// return false;
                }
                cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            ///    cout<<"bracket "<<mRecord[cur_pos]<<endl;
                first = second;
                cb_mask = cb_mask & (cb_mask - 1);
                second = cb_mask & (-cb_mask);
                // mask = second - first;
                if (!cb_mask) {
                    second = 1UL<<63;  //TODO: set second to be zero later
                 //   mask = mask | second;
                }
                mask = second - first;
                if (!cb_mask) {
                   mask = mask | second;
                }
                colon_mask = mask & colonbit;
                comma_mask = mask & commabit;
                cur_word = true;
                return res;
            }
        }
        ++start_id;
    }
    return false;
}

__attribute__((always_inline)) void SerialBitmap::skipEsAfter() {
    /////if (mRecord[cur_pos] == '}') return;
    // check root level before calling it
///    cout<<"before jump the last bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<qa.mCurState<<endl; 
    int bracket_cnt = 0;
    while (bracket_cnt >= 0) {
        jumpToNextBracket();
        if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
        else --bracket_cnt;
    }
///    cout<<"jump the last bracket "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<qa.mCurState<<endl;
}

__attribute__((always_inline)) void SerialBitmap::skipEsAfter1() {
    /////if (mRecord[cur_pos] == '}') return;
    // check root level before calling it
 ///   cout<<"before jump the last bracket1 "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<qa.mCurState<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
    int bracket_cnt = 1;
    while (bracket_cnt >= 0) {
        jumpToNextBracket();
        if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
        else --bracket_cnt;
    }
///    cout<<"after jump the last bracket1 "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<qa.mCurState<<endl;
}

__attribute__((always_inline)) void SerialBitmap::skipEsAfter2() {
    /// cout<<"start final skipping "<<endl;
    int bracket_cnt = 0;
    if (cur_word == true) {
        while (bracket_cnt >= 0 && cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            else --bracket_cnt;
            // information for next interval
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
        }
        if (bracket_cnt == -1) {
                //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
        ///    cout<<"finish jump "<<start_id<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
            return;
        }
        ++start_id;
        cur_word = false;
    }
    unsigned long colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long quotebit, escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long colonbit, commabit;
    unsigned long str_mask;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
    while (start_id < mNumTmpWords) {
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
         colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            if (cb_mask) {
                first = 1;
                while (bracket_cnt >= 0 && cb_mask) {
                    cb_bit = cb_mask & (-cb_mask);
                    second = cb_bit;
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    char ch = mRecord[cur_pos];
                    if (ch == '{' || ch == '[') ++bracket_cnt;
                    else --bracket_cnt;
                    first = second;
                    cb_mask = cb_mask & (cb_mask - 1);
                    }
                if (bracket_cnt == -1) {
                    // update next interval information
                    first = second;
                    second = cb_mask &(-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;
                    }
                    mask = second - first;
                    if (!cb_mask) {
                        mask = mask | second;
                    }
                    colon_mask = colonbit & mask;
                    comma_mask = commabit & mask;
                    this->colonbit = colonbit;
                    this->commabit = commabit;
                    cur_word = true;
           ///          cout<<"finish jump "<<start_id<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
                    return;
                }
            }
            ++start_id;
        }
    }
}

__attribute__((always_inline)) void SerialBitmap::skipEsAfter3() {
    /// cout<<"start final skipping "<<endl;
    int bracket_cnt = 1;
    if (cur_word == true) {
        while (bracket_cnt >= 0 && cb_mask) {
            cb_bit = cb_mask & (-cb_mask);
            second = cb_bit;
            cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
            if (mRecord[cur_pos] == '{' || mRecord[cur_pos] == '[') ++bracket_cnt;
            else --bracket_cnt;
            // information for next interval
            first = second;
            cb_mask = cb_mask & (cb_mask - 1);
        }
        if (bracket_cnt == -1) {
                //mask = second - first;
            second = cb_mask & (-cb_mask);
            if (!cb_mask) {
                second = 1UL<<63;  //TODO: set second to be zero later
            }
            mask = second - first;
            if (!cb_mask) mask = mask | second;
            colon_mask = mask & colonbit;
            comma_mask = mask & commabit;
        ///    cout<<"finish jump "<<start_id<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
            return;
        }
        ++start_id;
        cur_word = false;
    }
    unsigned long colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    unsigned long quotebit, escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit;
    unsigned long colonbit, commabit;
    unsigned long str_mask;
    unsigned long bracketbit;
    __m256i v_text0, v_text;
    while (start_id < mNumTmpWords) {
        colonbit = 0, quotebit = 0, escapebit = 0, stringbit = 0, lbracebit = 0, rbracebit = 0, commabit = 0, lbracketbit = 0, rbracketbit = 0;
        unsigned long i = start_id * 32;
        if (start_id > 0) v_text0 = v_text;
        // step 1: build structural character bitmaps
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
         colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
        quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
        escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
        __m256i r2 = _mm256_or_si256(v_text, struct_mask);
        __m256i r3 = _mm256_shuffle_epi8(structural_table, v_text);
        bracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(r2, r3));
        commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
        // first half of the word (lowest 32 bits)
        if(start_id % 2 == 0) {
            colonbit0 = colonbit;
            quotebit0 = quotebit;
            escapebit0 = escapebit;
            commabit0 = commabit;
            bracketbit0 = bracketbit;
            ++start_id;
            continue;
        } else {
            colonbit = (colonbit << 32) | colonbit0;
            quotebit = (quotebit << 32) | quotebit0;
            escapebit = (escapebit << 32) | escapebit0;
            commabit = (commabit << 32) | commabit0;
            bracketbit = (bracketbit << 32) | bracketbit0;
            // step 2: update structural quote bitmaps
            uint64_t bs_bits = escapebit;
            uint64_t start_edges = bs_bits & ~(bs_bits << 1);
            int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
            uint64_t even_starts = start_edges & even_start_mask;
            uint64_t odd_starts = start_edges & ~even_start_mask;
            uint64_t even_carries = bs_bits + even_starts;
            int64_t odd_carries;
            bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
                (unsigned long long *)(&odd_carries));
            odd_carries |= prev_iter_ends_odd_backslash;
            prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
            uint64_t even_carry_ends = even_carries & ~bs_bits;
            uint64_t odd_carry_ends = odd_carries & ~bs_bits;
            uint64_t even_start_odd_end = even_carry_ends & odd_bits;
            uint64_t odd_start_even_end = odd_carry_ends & even_bits;
            uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
            quote_bits = quotebit & ~odd_ends;
            // step 3: build string mask bitmaps
            str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
                _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
            str_mask ^= prev_iter_inside_quote;
            prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
            st_quotebit = quote_bits & str_mask;
            ed_quotebit = quote_bits & (~st_quotebit);
            quote_bits = st_quotebit;//quote_bits & str_mask;
            ++top_word;
            mQuoteBitmap[top_word] = quote_bits;
            // step 4: update structural character bitmaps
            unsigned long tmp = (~str_mask);
            colonbit = colonbit & tmp;
            commabit = commabit & tmp;
            bracketbit = bracketbit & tmp;
            cb_mask = bracketbit;
            if (cb_mask) {
                first = 1;
                while (bracket_cnt >= 0 && cb_mask) {
                    cb_bit = cb_mask & (-cb_mask);
                    second = cb_bit;
                    cur_pos = top_word * 64 + __builtin_ctzll(cb_bit);
                    char ch = mRecord[cur_pos];
                    if (ch == '{' || ch == '[') ++bracket_cnt;
                    else --bracket_cnt;
                    first = second;
                    cb_mask = cb_mask & (cb_mask - 1);
                    }
                if (bracket_cnt == -1) {
                    // update next interval information
                    first = second;
                    second = cb_mask &(-cb_mask);
                    if (!cb_mask) {
                        second = 1UL<<63;
                    }
                    mask = second - first;
                    if (!cb_mask) {
                        mask = mask | second;
                    }
                    colon_mask = colonbit & mask;
                    comma_mask = commabit & mask;
                    this->colonbit = colonbit;
                    this->commabit = commabit;
                    cur_word = true;
                    return;
                }
            }
            ++start_id;
        }
    }
}

void SerialBitmap::proc_ary() {
    ///cout<<"start process array "<<endl;
    int next_state = qa.getNextStateNoKey(ARRAY);
    qa.pushStack(next_state);
    int start_idx = -1, end_idx = -1;
    bool has_index_constraint = qa.hasIndexConstraints();
    if (has_index_constraint) {
        start_idx = qa.mDfa.trans_ele[qa.mCurState - 1].start_idx;
        end_idx = qa.mDfa.trans_ele[qa.mCurState - 1].end_idx;
    ///    cout<<"array idx "<<start_idx<<" "<<end_idx<<" "<<qa.mCurState<<endl; 
        skipEsBefore(start_idx);
    ///    cout<<"after skipping all elements before start_idx "<<qa.mArrCounter<<endl;
        if (qa.mArrCounter < start_idx) {
            qa.popStack();
            return;
        } 
    }
   ///if(mOutputSize >= 18032)  cout<<"start while loop "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<start_id<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
    int skip_flag = 0;
  ///  cout<<"before skipping type unmatched elements"<<endl;
    while ((skip_flag = skipTypeUnmatchedEs(end_idx)) == TRUE) {
        ///if (start_id > 5000) break;
    ///if(mOutputSize >= 18032)   cout<<"enter into "<<qa.mArrCounter<<" "<<end_idx<<" "<<substring_200(mRecord, cur_pos, cur_pos+ 50)<<" "<<cur_pos<<" "<<start_id<<" "<<next_state<<endl;
        if (qa.getType(next_state) == OUTPUT_CANDIDATE) {
            //TODO: get output content
            ///++mOutputSize;
            outputV();
         ///   cout<<"output primitive "<<endl;
        } else {
            int type = getEType();  // TODO: double check position
       ///if(mOutputSize>=18032)     cout<<"element type "<<type<<" "<<qa.mArrCounter<<endl;
            if (type == OBJECT) proc_obj();
            else if (type == ARRAY) proc_ary();
        }
        /*if (has_index_constraint && qa.mArrCounter >= end_idx) {
            cout<<"array ends "<<qa.mCurState<<endl;
            skipEsAfter();
            break;
        }*/
       /// qa.addArrayCounter();
    }
  ///  cout<<"skip flag value "<<skip_flag<<endl;
    if (skip_flag == FALSE) {
        if (qa.getStackSize() == 1) {
            //cout<<"stop early "<<endl;
            return;
        }
     ///if(mOutputSize >= 18032)  cout<<"skip rest of aray elements "<<qa.mCurState<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<" "<<start_id<<endl;
        if (has_index_constraint && qa.mArrCounter == end_idx && getEType() != PRIMITIVE) {
             ///cout<<"vtype "<<getVType()<<" "<<mRecord[cur_pos + 1]<<" "<<mRecord[cur_pos + 2]<<endl;
             skipEsAfter1();// && getVType() != PRIMITIVE) skipEsAfter1();
        }
        else skipEsAfter();
     ///   cout<<"skip rest of aray elements1 "<<qa.mCurState<<" "<<mRecord[cur_pos]<<endl;
    } else {
     /// if(mOutputSize >= 18032)  cout<<"skip flag "<<skip_flag<<" "<<mRecord[cur_pos]<<" "<<cur_pos<<" "<<start_id<<endl;
        /*if (mRecord[cur_pos] == ']') {
            skipEsAfter();
        }*/
    }
 ///   cout<<"before skipping array elements after index range "<<end_idx<<" "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl;
///    skipEsAfter();  //TODO: support this
    qa.popStack(); 
  ///  cout<<"end processing array "<<qa.mCurState<<endl;
 //   cout<<"after skipping array elements after index range "<<end_idx<<" "<<qa.mCurState<<" "<<qa.getStackSize()<<" "<<cur_pos<<" "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos - 50, cur_pos + 50)<<endl; 
}

void SerialBitmap::indexConstruction() {
  /*unsigned long test = (1UL << 0);
  unsigned long test1 = (1UL << 1);
   unsigned long test2 = 0;
   unsigned long test3 = (1UL << 63);*/
  /// cout<<"test "<<test<<" "<<test1<<" "<<__builtin_clzll(test2)<<" "<<__builtin_clzll(1)<<" "<<__builtin_popcountl(test3)<<endl;
  #ifdef INTERFILTER
  {
      int num_str = 1;
      char target[33];
      char* words[10];
      words[0] = "P150";
      int words_len[10];
      words_len[0] = 4;
      for (int i = 0; i < num_str; ++i) {
        char* word = words[i]; //"pric";//str[i].c_str();
        int word_len = words_len[i]; //4;//strlen(word);
        // copy word into target to form 256-bit vector
        for (int j = 0; j < 32; ++j) {
            target[j] = word[j % word_len];
        }
        target[32] = '\0';
        __m256i v_target = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(target));
        bool found = false;
        for (long j = 0; j < mNumTmpWords; ++j) {
            unsigned long k = j * 32;
            int cnt = 0;
            bool match = false;
            __m256i v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
            unsigned matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target)); //v_target
            match = (match || (matchbit > 0));
            ++cnt;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
            matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
            match = (match || matchbit > 0);
            ++cnt;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 2));
            matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
            match = (match || matchbit > 0);
            ++cnt;
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 3));
            matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
            match = (match || matchbit > 0);
            if (match > 0) {
                found = true;
                break;
                //cout<<"match "<<endl;
            }
        }
        if (found == false) return;
        ++mPassed;
      }
  }
  #endif
    qa.reset();
    structural_table =
        _mm256_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '{', 0, '}', 0, 0,
                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '{', 0, '}', 0, 0);
    struct_mask = _mm256_set1_epi8(0x20);
    //for (int iter = 1; iter <= 10; ++iter) {
    struct timeval begin,end;
    double duration;
    gettimeofday(&begin,NULL);
    // vectors for structural characters
    v_quote = _mm256_set1_epi8(0x22);
    v_colon = _mm256_set1_epi8(0x3a);
    v_escape = _mm256_set1_epi8(0x5c);
    v_lbrace = _mm256_set1_epi8(0x7b);
    v_rbrace = _mm256_set1_epi8(0x7d);
    v_comma = _mm256_set1_epi8(0x2c);
    v_lbracket = _mm256_set1_epi8(0x5b);
    v_rbracket = _mm256_set1_epi8(0x5d);
    top_word = -1;
    prev_iter_ends_odd_backslash = 0ULL;
    prev_iter_inside_quote = 0ULL;
    start_id = 0;
    cb_mask = 0, colon_mask = 0, comma_mask = 0;
    cur_word = false;
    char ch = mRecord[0];
    long temp_pos = 0;
    bitmap bm;
    /// cout<<"mRecord "<<substring_200(mRecord, 0, 100)<<" "<<mOutputSize<<endl;
    while (mRecord[temp_pos] == ' ') ++temp_pos;
    if (mRecord[temp_pos] == '{')
        object(temp_pos, bm);
    else if(mRecord[temp_pos] == '[')
        array(temp_pos, bm);
///    cout<<"output size "<<mOutputSize<<endl;

    /// jumpToNextBracket();
    /*if (mRecord[temp_pos] == '{') {
        /// cout<<"process object"<<cur_word<<" "<<start_id<<endl;
        proc_obj();
    } else if (mRecord[temp_pos] == '[') {
        /// cout<<"process array "<<cur_word<<" "<<start_id<<endl;
        proc_ary();
    } else cout<<"input error"<<endl;
    /// cout<<"done "<<endl;*/
    /// skipE();
    /*temp_pos = 1;
    while (mRecord[temp_pos] != '[') ++temp_pos;
    cout<<"temp pos "<<temp_pos<<" "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<endl; 
    */
  /*  temp_pos = 1;
    while (mRecord[temp_pos] != '{') ++temp_pos;
    /// ++temp_pos;
    cout<<"temp pos "<<temp_pos<<" "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<endl;
    bitmap bm;*/
    /*if (mRecord[temp_pos] == '{') skipObject(temp_pos, bm);
    else if (mRecord[temp_pos] == '[') skipArray(temp_pos, bm);
    cout<<"final position "<<temp_pos<<" "<<mRecord[temp_pos]<<" "<<substring_200(mRecord, temp_pos - 100, temp_pos)<<endl;
    */
    // int result = goToObjAttr(temp_pos, bm);
/*    int result = goToAryAttr(temp_pos, bm);
    if (result == SUCCESS) {
        cout<<"jump successfully "<<temp_pos<<" "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<endl;
    } else if (result == OBJECT_END) {
        cout<<"object end "<<temp_pos<<" "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<endl;
    }*/


    ///goToAryAttr(temp_pos, bm);
    /*for (int i = 1; i <= 10; ++i) {
        cout<<"starting pos "<<temp_pos<<endl;
        goToPrimAttr(temp_pos, bm);
        cout<<"jump to a primitive "<<" "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<endl;
        skipPrimitiveObj(temp_pos, bm);
    }*/
    /*for (int i = 0; i < 10; ++i) {
    while (mRecord[temp_pos] != ':') ++temp_pos;
    while (mRecord[temp_pos] == ' ') ++temp_pos;
    ///if (i == 8) cout<<mRecord[temp_pos]<<" before "<<substring_200(mRecord, temp_pos, temp_pos + 10)<<endl;
    skipPrimitiveObj(temp_pos, bm);
    }*/
}


