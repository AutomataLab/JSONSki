#ifndef SERIALBITMAP_H
#define SERIALBITMAP_H
#include <string>
#include <iostream>
#include <vector>
#include <bitset>
#include <cassert>
#include <stack>
#include <algorithm>
#include <unordered_map>
#include <functional>
#include <math.h>
#include <immintrin.h>
#include "Bitmap.h"
#include <unordered_map>
#include <map>
#include "QueryAutomaton.h"
using namespace std;

#define MAX_STACK_DEPTH 100
typedef struct StackElement{
    unsigned long position;
    unsigned long bits;
}StackElement;

typedef struct MatchedBitmapInfo {
    unsigned long bitmap;
    unsigned long carry;
    unsigned long last_index;
};

class SerialBitmap : public Bitmap {
    friend class SerialBitmapIterator;
  private:
    char* mRecord;
    // for a single large record, stream length equals to record length
    long mRecordLength;
    // each temp word has 32 bytes
    long mNumTmpWords;
    // each word has 64 bytes
    long mNumWords;
    // structural character bitmaps
    unsigned long *mEscapeBitmap, *mStrBitmap, *mColonBitmap, *mCommaBitmap, *mLbracketBitmap, *mRbracketBitmap, *mLbraceBitmap, *mRbraceBitmap;
    // structural quote bitmap, used for key field parsing
    unsigned long *mQuoteBitmap;
    // leveled colon bitmap
    unsigned long *mLevColonBitmap[MAX_LEVEL + 1];
    // leveled comma bitmap
    unsigned long *mLevCommaBitmap[MAX_LEVEL + 1];
    // the deepest level of leveled bitmap indexes
    int mDepth;
    // whether to create leveled comma bitmaps
    bool mArraySupported;
    char mKey[1000];
    char* mText;

  public:
    long mOutputSize;
    
  public:
    SerialBitmap();
    SerialBitmap(char* record, int depth, bool array_supported = true);
    ~SerialBitmap();
    // manually create an automaton
    void generateAutomaton(QueryAutomaton& qa);
    void indexConstruction();
    // following three functions are used for evaluation comparison
    void indexConstructionMison(int num_step = 5);
    void indexConstructionMisonPlus(int num_step = 5);
    void indexConstructionSbSPison(int num_step = 5); 
    // mainly used for small records processing
    void setRecordLength(long length);
    void setQuoteBitmap(unsigned long* quote_bitmap);
    unsigned long* getQuoteBitmap() {return mQuoteBitmap;}
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long bitset[], unsigned long& carry);
    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry); 
   // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, map<char, unsigned long>& bitset, unsigned long& carry);
//    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unordered_map<char, unsigned long>& bitset, unsigned long& carry);
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry);
 
  private:
     char* substring_200(char *pText, int begin, int end)
{
    int i,j;
    char * temp=pText;
    char* temp1=NULL;
    temp1=(char*)malloc((end-begin+1)*sizeof(char));
    for (j = 0,i = begin; i < end; i++,j++)
    {
        temp1[j]=temp[i];
    }
    temp1[j]='\0';
    return temp1;
}
    void freeMemory();
    // all following functions are used for evaluation comparison
    void buildStructuralCharacterBitmap();
    void buildStructuralQuoteBitmapMison();
    void buildStructuralQuoteBitmapPison();
    void buildStringMaskBitmapMison();
    void buildStringMaskBitmapPison();
    void updateStructuralCharacterBitmap();
    void buildLeveledBitmapMison();
    void buildLeveledBitmapPison();
    bool findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos);
    // process key-pri pairs within an interval separated by two consecutive brackets
    void processKeyPriPairs(QueryAutomaton& qa, long& word_id, unsigned long& colon_brace_bit, long& last_colon_pos, string& output, long& output_size);
    void processKeyBracket(QueryAutomaton& qa, int type, long& last_colon_pos, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn);
    void processOpenBracket(QueryAutomaton& qa, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn);
    void processCloseBracket(QueryAutomaton& qa, bool& skip_arr_ele);
    // process an array member
    void processArrayMember(QueryAutomaton& qa, long& last_comma_pos, bool& skip_arr_ele);
    // process a candidate array interval separated yb two consecutive brackets
    void processCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& commabit, long& last_comma_pos, bool& skip_arr_ele);
    void processNoKeyInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit);
    void processKeyNoBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, string& output, long& output_size);    
    // void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, bool& match_flag, string& output, long& output_size);
    void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, string& output, long& output_size);
    void processCloseBracketInterval(QueryAutomaton& qa, __m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long &bracketbit, string& output, long& output_size) {
     if (qa.mCurState == UNMATCHED_STATE) return;
     int trans_idx = 0;
     int cur_idx = qa.mCurState - 1;
     int num_trans_str = qa.mDfa.trans_ele[cur_idx].num_trans_str;
     if (num_trans_str == 1) {
         int trans_idx = 0;
         while (trans_idx < 1)//num_trans_str)
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type != KEY) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 if (tmask & carry_mask)
                     qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             // colon
             tmask = tmask & colonbit;
             if (tmask > 0) {
                     unsigned long temp_mask = tmask;
                     unsigned long matchbit = temp_mask & (-temp_mask);
                     // remove the current matched bit and its prior bits from colon mask
                     unsigned long match_mask = matchbit ^ (matchbit - 1);
                     unsigned long tempbit = colonbit & (~match_mask);
                     // process the matched output
                     long offset = (word_id) * 64 + __builtin_ctzll(temp_mask); 
                     if (tempbit) {
                         long next_colon_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                         long st = -1, ed = -1;
                         findFieldQuotePos(next_colon_pos, st, ed);
                         long text_length = st - offset - 1;
                         //char* text = (char*)malloc(text_length + 1);
                         memcpy(mText, mRecord + offset + 1, text_length);
                         mText[text_length] = '\0';
                         output.append(mText);
                         //free(text);
                         ++output_size;
                     } else {
                         //long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                         //last_colon_pos = offset;
                         //temp_state = next_state;
                         long end_pos = (word_id) * 64 + __builtin_ctzll(bracketbit);
                         long st = offset, ed = end_pos;
                         long text_length = ed - st - 1;
                         memcpy(mText, mRecord + st + 1, text_length);
                         mText[text_length] = '\0';
                         //   cout<<"content "<<content<<endl;
                         output.append(mText);
                         ++output_size;
                    //     cout<<"offset0 "<<offset<<" state "<<temp_state<<endl;
                     }
                     continue;
             }
         }
     } else {
         int trans_idx = 0;
         while (trans_idx < num_trans_str)
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type != KEY) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 if (tmask & carry_mask)
                     qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             // colon
             tmask = tmask & colonbit;
             if (tmask > 0) {
                 unsigned long temp_mask = tmask;
                 unsigned long matchbit = temp_mask & (-temp_mask);
                 // remove the current matched bit and its prior bits from colon mask
                 unsigned long match_mask = matchbit ^ (matchbit - 1);
                 unsigned long tempbit = colonbit & (~match_mask);
                 long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                 // process the matched output
                 if (tempbit) {
                     // long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     long next_colon_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                     long st = -1, ed = -1;
                     findFieldQuotePos(next_colon_pos, st, ed);
                     long text_length = st - offset - 1;
                     //char* text = (char*)malloc(text_length + 1);
                     memcpy(mText, mRecord + offset + 1, text_length);
                     mText[text_length] = '\0';
                     output.append(mText);
                    // free(text);
                     ++output_size;
                 } else {
                     /*long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     last_colon_pos = offset;
                     temp_state = next_state;*/
                     long end_pos = (word_id) * 64 + __builtin_ctzll(bracketbit);
                     long st = offset, ed = end_pos;
                     long text_length = ed - st - 1;
                     memcpy(mText, mRecord + st + 1, text_length);
                     mText[text_length] = '\0';
                     //   cout<<"content "<<content<<endl;
                     output.append(mText);
                     ++output_size;
                //     cout<<"offset "<<offset<<" state "<<temp_state<<endl;
                 }
                 continue;
             }
            // ++trans_idx;
         }
     } 
};
    void processNoBracketInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, string& output, long& output_size, long& last_colon_pos, int& temp_state) {
    if (qa.mCurState == UNMATCHED_STATE) return;
     int trans_idx = 0;
    int cur_idx = qa.mCurState - 1;
    int num_trans_str = qa.mDfa.trans_ele[cur_idx].num_trans_str;
    // __m256i v_first = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(record));
    // __m256i v_second = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(record + 32));
    if (num_trans_str == 1) {
        int trans_idx = 0;
         if (cur_idx == 9) cout<<"start last"<<endl;
         while (trans_idx < 1)//num_trans_str)
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type == OBJECT || trans_type == ARRAY || trans_type == OUTPUT_CANDIDATE) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 if (tmask & carry_mask)
                     qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             tmask = tmask & colonbit;
             if (trans_type == KEY) {
                 unsigned long temp_mask = tmask;
                 unsigned long matchbit = temp_mask & (-temp_mask);
                 // remove the current matched bit and its prior bits from colon mask
                 unsigned long match_mask = matchbit ^ (matchbit - 1);
                 unsigned long tempbit = colonbit & (~match_mask);
                 // process the matched output
                 if (tempbit) {
                     long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     long next_colon_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                     long st = -1, ed = -1;
                     findFieldQuotePos(next_colon_pos, st, ed);
                     long text_length = st - offset - 1;
                     if (text_length < 0) cout<<"exception"<<endl;
                     // char* text = (char*)malloc(text_length + 1);
                     memcpy(mText, mRecord + offset + 1, text_length);
                     mText[text_length] = '\0';
                     output.append(mText);
                     // free(text);
                     ++output_size;
                 } else {
                     long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     last_colon_pos = offset;
                     temp_state = next_state;
                    //     cout<<"offset0 "<<offset<<" state "<<temp_state<<endl;
                 } 
                 continue;
             }
             if (tmask == 0 && last_match_idx < key_len + 3) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 3) tmask = tmask | 1;
             // consecutive blank characters
             if (last_match_idx == key_len + 4) tmask = tmask | 1;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
             if (tmask == 0 && last_match_idx < key_len + 4) {
                 continue;
             }
             if (last_match_idx == key_len + 4) tmask = tmask | 1;
         }
    } else {
         int trans_idx = 0;
         while (trans_idx < num_trans_str)
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type == OBJECT || trans_type == ARRAY || trans_type == OUTPUT_CANDIDATE) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 if (tmask & carry_mask)
                     qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             tmask = tmask & colonbit;
             if (trans_type == KEY) {
                 unsigned long temp_mask = tmask;
                 unsigned long matchbit = temp_mask & (-temp_mask);
                 // remove the current matched bit and its prior bits from colon mask
                 unsigned long match_mask = matchbit ^ (matchbit - 1);
                 unsigned long tempbit = colonbit & (~match_mask);
                 // process the matched output
                 if (tempbit) {
                     long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     long next_colon_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                     long st = -1, ed = -1;
                     findFieldQuotePos(next_colon_pos, st, ed);
                     long text_length = st - offset - 1;
                     //char* text = (char*)malloc(text_length + 1);
                     memcpy(mText, mRecord + offset + 1, text_length);
                     mText[text_length] = '\0';
                     output.append(mText);
                     // free(text);
                     ++output_size;
                 } else {
                     long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     last_colon_pos = offset;
                     temp_state = next_state;
                //     cout<<"offset "<<offset<<" state "<<temp_state<<endl;
                 }
                 continue;
             }
             if (tmask == 0 && last_match_idx < key_len + 3) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 3) tmask = tmask | 1;
             // consecutive blank characters
             if (last_match_idx == key_len + 4) tmask = tmask | 1;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
             if (tmask == 0 && last_match_idx < key_len + 4) {
                 continue;
             }
             if (last_match_idx == key_len + 4) tmask = tmask | 1;
        }
    }
    if (cur_idx == 9) cout<<"finish last"<<endl;
};
    void processOpenBracketInterval(QueryAutomaton& qa, __m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long lbracketbit, int& bracket_type, bool& match_flag, bool& skip_unmatched_tkn, string& output, long& output_size)
{
    //match_flag = false;
    if (qa.mCurState == 0) return;
    int cur_idx = qa.mCurState - 1;
    int num_trans_str = qa.mDfa.trans_ele[cur_idx].num_trans_str;
    if (num_trans_str == 1) {
        for (int i = 0; i < 1; ++i) {
            int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
            int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
            if (trans_type == bracket_type) {
                if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                    qa.pushStack(next_state);
                    match_flag = true;
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                }
            }
            else
            {
                char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
                int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
                int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
                qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                unsigned long carry_mask = 1UL<<63;
                // start quote
                unsigned long tmask = st_quotebit;
                if (tmask == 0 && last_match_idx < 0) {
                    continue;
                }
                if (tmask & carry_mask)
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
                tmask = tmask << 1;
                if (last_match_idx == 0) tmask = tmask | 1;
                // check key field
                bool skip_loop = false;
                for (int j = 0; j < key_len; ++j) {
                    char ch = key[j];
                    __m256i v_ch = _mm256_set1_epi8(ch);
                    unsigned long chbit0, chbit;
                    chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                    chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                    chbit = (chbit << 32) | chbit0;
                    tmask = tmask & chbit;
                    if (tmask == 0 && last_match_idx < j + 1) {
                        skip_loop = true;
                        break;
                    }
                    if (tmask & carry_mask)
                        qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                    tmask = tmask << 1;
                    if (last_match_idx == j + 1) tmask = tmask | 1;
                }
                if (skip_loop == true) continue;
                // end quote
                tmask = tmask & ed_quotebit;
                if (tmask == 0 && last_match_idx < key_len + 1) {
                    continue;
                }
                if (tmask & carry_mask)
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 1) tmask = tmask | 1;
                // concecutive blank characters
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                unsigned long blankbit0, blankbit;
                __m256i v_blank = _mm256_set1_epi8(' ');
                blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
                blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
                blankbit = (blankbit << 32) | blankbit0;
                tmask = (tmask + blankbit) & (~blankbit);
                if ((blankbit & carry_mask))
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
                if (tmask == 0 && last_match_idx < key_len + 2) {
                    continue;
                }
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                // colon
                tmask = tmask & colonbit;
                if (trans_type == KEY) {// || lbracketbit == 0) {
                    if (tmask > 0) {
                        unsigned long temp_mask = tmask;
                        unsigned long matchbit = temp_mask & (-temp_mask);
                        // remove the current matched bit and its prior bits from colon mask
                        unsigned long match_mask = matchbit ^ (matchbit - 1);
                        unsigned long tempbit = colonbit & (~match_mask);
                        // process the matched output
                        if (tempbit) {
                            long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                            long next_colon_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                            long st = -1, ed = -1;
                            findFieldQuotePos(next_colon_pos, st, ed);
                            long text_length = st - offset - 1;
                            //char* text = (char*)malloc(text_length + 1);
                            memcpy(mText, mRecord + offset + 1, text_length);
                            mText[text_length] = '\0';
                            output.append(mText);
                            //  cout<<"text "<<text<<endl;
                           // free(text);
                            ++output_size;
                        }
                        //cout<<"matched "<<endl;
                    }
                    continue;
                }
                if (tmask == 0 && last_match_idx < key_len + 3) {
                    continue;
                }
                if (tmask & carry_mask)
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 3) tmask = tmask | 1;
                // consecutive blank characters
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                tmask = (tmask + blankbit) & (~blankbit);
                if ((blankbit & carry_mask))
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
                if (tmask == 0 && last_match_idx < key_len + 4) {
                        continue;
                }
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                // left brace or left bracket
                tmask = tmask & lbracketbit;
                if (tmask > 0) {
                    if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                        qa.pushStack(next_state);
                        match_flag = true;
                    }
                }
            }
        }
    } else {
         int trans_idx = 0;
         while (trans_idx < num_trans_str) {
            int i = trans_idx;
            ++trans_idx;
        //for (int i = 0; i < num_trans_str; ++i) {
            int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
            int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
            if (trans_type == bracket_type) {
                if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                    qa.pushStack(next_state);
                    match_flag = true;
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                }
            }
            else
            {
                char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
                int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
                int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
                qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                unsigned long carry_mask = 1UL<<63;
                // start quote
                unsigned long tmask = st_quotebit;
                if (tmask == 0 && last_match_idx < 0) {
                    // match_flag = false;
                    continue;
                }
                if (tmask & carry_mask)
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
                tmask = tmask << 1;
                if (last_match_idx == 0) tmask = tmask | 1;
                // check key field
                bool skip_loop = false;
                for (int j = 0; j < key_len; ++j) {
                    char ch = key[j];
                    __m256i v_ch = _mm256_set1_epi8(ch);
                    unsigned long chbit0, chbit;
                    chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                    chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                    chbit = (chbit << 32) | chbit0;
                    tmask = tmask & chbit;
                    if (tmask == 0 && last_match_idx < j + 1) {
                        skip_loop = true;
                        break;
                    }
                    if (tmask & carry_mask)
                        qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                    tmask = tmask << 1;
                    if (last_match_idx == j + 1) tmask = tmask | 1;
                }
                if (skip_loop == true) continue;
                // end quote
                tmask = tmask & ed_quotebit;
                if (tmask == 0 && last_match_idx < key_len + 1) {
                    continue;
                }
                if (tmask & carry_mask)
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 1) tmask = tmask | 1;
                // concecutive blank characters
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                unsigned long blankbit0, blankbit;
                __m256i v_blank = _mm256_set1_epi8(' ');
                blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
                blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
                blankbit = (blankbit << 32) | blankbit0;
                tmask = (tmask + blankbit) & (~blankbit);
                if ((blankbit & carry_mask))
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
                if (tmask == 0 && last_match_idx < key_len + 2) {
                    continue;
                }
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                // colon
                tmask = tmask & colonbit;
                if (trans_type == KEY) {// || lbracketbit == 0) {
                    if (tmask > 0) {
                        unsigned long temp_mask = tmask;
                        unsigned long matchbit = temp_mask & (-temp_mask);
                        // remove the current matched bit and its prior bits from colon mask
                        unsigned long match_mask = matchbit ^ (matchbit - 1);
                        unsigned long tempbit = colonbit & (~match_mask);
                        // process the matched output
                        if (tempbit) {
                            long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                            long next_colon_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                            long st = -1, ed = -1;
                            findFieldQuotePos(next_colon_pos, st, ed);
                            long text_length = st - offset - 1;
                            //char* text = (char*)malloc(text_length + 1);
                            memcpy(mText, mRecord + offset + 1, text_length);
                            mText[text_length] = '\0';
                            output.append(mText);
                            //  cout<<"text "<<text<<endl;
                            //free(text);
                            ++output_size;
                        }
                        //cout<<"matched "<<endl;
                    }
                    continue;
                }
                if (tmask == 0 && last_match_idx < key_len + 3) {
                    continue;
                }
                if (tmask & carry_mask)
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 3) tmask = tmask | 1;
                // consecutive blank characters
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                tmask = (tmask + blankbit) & (~blankbit);
                if ((blankbit & carry_mask))
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
                if (tmask == 0 && last_match_idx < key_len + 4) {
                        continue;
                }
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                // left brace or left bracket
                tmask = tmask & lbracketbit;
                if (tmask > 0) {
                    if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                        qa.pushStack(next_state);
                        match_flag = true;
                    }
                }
            }
        }
    }
    };

};
#endif
