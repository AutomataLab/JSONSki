#ifndef SERIALBITMAP_H
#define SERIALBITMAP_H
#include <string>
#include <iostream>
#include <vector>
#include <bitset>
#include <cassert>
#include <stack>
#include <algorithm>
#include <unordered_map>
#include <functional>
#include <math.h>
#include <immintrin.h>
#include "Bitmap.h"
#include <unordered_map>
#include <map>
#include "QueryAutomaton.h"
using namespace std;

#define MAX_STACK_DEPTH 100
typedef struct StackElement{
    unsigned long position;
    unsigned long bits;
}StackElement;

typedef struct MatchedBitmapInfo {
    unsigned long bitmap;
    unsigned long carry;
    unsigned long last_index;
};

class SerialBitmap : public Bitmap {
    friend class SerialBitmapIterator;
  private:
    char* mRecord;
    // for a single large record, stream length equals to record length
    long mRecordLength;
    // each temp word has 32 bytes
    long mNumTmpWords;
    // each word has 64 bytes
    long mNumWords;
    // structural character bitmaps
    unsigned long *mEscapeBitmap, *mStrBitmap, *mColonBitmap, *mCommaBitmap, *mLbracketBitmap, *mRbracketBitmap, *mLbraceBitmap, *mRbraceBitmap;
    // structural quote bitmap, used for key field parsing
    unsigned long *mQuoteBitmap;
    // leveled colon bitmap
    unsigned long *mLevColonBitmap[MAX_LEVEL + 1];
    // leveled comma bitmap
    unsigned long *mLevCommaBitmap[MAX_LEVEL + 1];
    // the deepest level of leveled bitmap indexes
    int mDepth;
    // whether to create leveled comma bitmaps
    bool mArraySupported;
    char mKey[1000];
    char* mText;
    bool mPendingKey = false;
    int mCnt = 0;
    long* mPos;
    long mTopPos = -1;

  public:
    long mOutputSize;
    
  public:
    SerialBitmap();
    SerialBitmap(char* record, int depth, bool array_supported = true);
    ~SerialBitmap();
    // manually create an automaton
    void generateAutomaton(QueryAutomaton& qa);
    void indexConstruction();
    // following three functions are used for evaluation comparison
    void indexConstructionMison(int num_step = 5);
    void indexConstructionMisonPlus(int num_step = 5);
    void indexConstructionSbSPison(int num_step = 5); 
    // mainly used for small records processing
    void setRecordLength(long length);
    void setQuoteBitmap(unsigned long* quote_bitmap);
    unsigned long* getQuoteBitmap() {return mQuoteBitmap;}
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long bitset[], unsigned long& carry);
    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry); 
   // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, map<char, unsigned long>& bitset, unsigned long& carry);
//    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unordered_map<char, unsigned long>& bitset, unsigned long& carry);
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry);
 
  private:
     char* substring_200(char *pText, int begin, int end)
{
    int i,j;
    char * temp=pText;
    char* temp1=NULL;
    temp1=(char*)malloc((end-begin+1)*sizeof(char));
    for (j = 0,i = begin; i < end; i++,j++)
    {
        temp1[j]=temp[i];
    }
    temp1[j]='\0';
    return temp1;
}
    void freeMemory();
    // all following functions are used for evaluation comparison
    void buildStructuralCharacterBitmap();
    void buildStructuralQuoteBitmapMison();
    void buildStructuralQuoteBitmapPison();
    void buildStringMaskBitmapMison();
    void buildStringMaskBitmapPison();
    void updateStructuralCharacterBitmap();
    void buildLeveledBitmapMison();
    void buildLeveledBitmapPison();
    bool findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos, unsigned long& quote_bit) {
        long w_id = colon_pos/64;
   // long offset = colon_pos%64;
   // long start_quote = 0;
  //  long end_quote = 0;
    start_pos = 0; end_pos = 0;
    // long cur_w_id = w_id;
    // end_pos
    uint64_t cur_quote_bit = quote_bit;
    while (cur_quote_bit == 0) {
        --w_id;
        cur_quote_bit = this->mQuoteBitmap[w_id];
    }
    int first_lead_zero = __builtin_clzl(cur_quote_bit);
    end_pos = w_id * 64 + 64 - first_lead_zero - 1;
    if (first_lead_zero == 63) cur_quote_bit = 0;
    else cur_quote_bit = cur_quote_bit << (1 + first_lead_zero) >> (1 + first_lead_zero);
    while (cur_quote_bit == 0) {
        --w_id;
        cur_quote_bit = this->mQuoteBitmap[w_id];
    }
    start_pos = w_id * 64 + 64 - __builtin_clzl(cur_quote_bit) - 1;
        return true;
    }
    //bool findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos);
    // process key-pri pairs within an interval separated by two consecutive brackets
    void processKeyPriPairs(QueryAutomaton& qa, long& word_id, unsigned long& colon_brace_bit, long& last_colon_pos, string& output, long& output_size, unsigned long& quote_bit, unsigned long& last_quote_bit, unsigned long& end_value_bit, unsigned long& comma_brace_bit, bool& is_right_brace);
    void processKeyBracket(QueryAutomaton& qa, int type, long& last_colon_pos, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, unsigned long& last_quote_bit);
    //void processKeyPriPairs(QueryAutomaton& qa, long& word_id, unsigned long& colon_brace_bit, long& last_colon_pos, string& output, long& output_size);
    //void processKeyBracket(QueryAutomaton& qa, int type, long& last_colon_pos, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn);
    void processOpenBracket(QueryAutomaton& qa, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn);
    void processCloseBracket(QueryAutomaton& qa, bool& skip_arr_ele);
    // process an array member
    void processArrayMember(QueryAutomaton& qa, long& last_comma_pos, bool& skip_arr_ele);
    // process a candidate array interval separated by two consecutive brackets
    void processCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& commabit, long& last_comma_pos, bool& skip_arr_ele);//, string& output, long& output_size);
    void processOpenBracketCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& bracketbit, long& last_comma_pos, bool& skip_arr_ele);
    void processCloseBracketCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& comma_brace_bit, long& last_comma_pos, string& output, long& output_size);
    //void processCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& commabit, long& last_comma_pos, bool& skip_arr_ele);
    void processNoKeyInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit);
    //void processKeyNoBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, string& output, long& output_size);    
    // void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, bool& match_flag, string& output, long& output_size);
  //  void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, string& output, long& output_size);
    /*void processCandidateOutputPri(QueryAutomaton& qa, unsigned long& last_colon_pos, int& temp_state, unsigned long& next_tkn_bitmap, int& tkn_type) {
        
    }*/
    void processCloseBracketInterval(QueryAutomaton& qa, __m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long & commabit, unsigned long &bracketbit, string& output, long& output_size) {
     if (qa.mCurState == UNMATCHED_STATE) return;
     int trans_idx = 0;
     int cur_idx = qa.mCurState - 1;
     int num_trans_str = qa.mDfa.trans_ele[cur_idx].num_trans_str;
     if (num_trans_str == 1) {
         int trans_idx = 0;
         while (trans_idx < 1)//num_trans_str)
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type != KEY || qa.getType(next_state) != OUTPUT_CANDIDATE) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             /////if (tmask & carry_mask)
                 /////qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 /////if (tmask & carry_mask)
                     /////qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             /////if (tmask & carry_mask)
                 /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             /////if ((blankbit & carry_mask))
                 /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             // colon
             tmask = tmask & colonbit;
             if (tmask > 0) {
                 unsigned long temp_mask = tmask;
                 unsigned long matchbit = temp_mask & (-temp_mask);
                 // remove the current matched bit and its prior bits from colon mask
                 unsigned long match_mask = matchbit ^ (matchbit - 1);
                 unsigned long tempbit = commabit & (~match_mask);
                 // process the matched output
                 long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                 long end_pos = -1;
                 if (tempbit) {
                     end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                 } else {
                     end_pos = (word_id) * 64 + __builtin_ctzll(bracketbit);
                 }
                 long text_length = end_pos - colon_pos - 1;
                 memcpy(mText, mRecord + colon_pos + 1, text_length);
                 mText[text_length] = '\0';
                 output.append(mText);
                 ++output_size; 
                 continue;
             }
         }
     } /*else {
         int trans_idx = 0;
         while (trans_idx < num_trans_str) //num_trans_str
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type != KEY || qa.getType(next_state) != OUTPUT_CANDIDATE) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             /////if (tmask & carry_mask)
                 /////qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 /////if (tmask & carry_mask)
                     /////qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             /////if (tmask & carry_mask)
                 /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             /////if ((blankbit & carry_mask))
                 /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             // colon
             tmask = tmask & colonbit;
             if (tmask > 0) {
                 unsigned long temp_mask = tmask;
                 unsigned long matchbit = temp_mask & (-temp_mask);
                 // remove the current matched bit and its prior bits from colon mask
                 unsigned long match_mask = matchbit ^ (matchbit - 1);
                 unsigned long tempbit = commabit & (~match_mask);
                 long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                 // process the matched output
                 long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                 long end_pos = -1;
                 if (tempbit) {
                     end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                 } else {
                     end_pos = (word_id) * 64 + __builtin_ctzll(bracketbit);
                 }
                 long text_length = end_pos - colon_pos - 1;
                 memcpy(mText, mRecord + colon_pos + 1, text_length);
                 mText[text_length] = '\0';
                 output.append(mText);
                 ++output_size;
                 continue;
             }
            // ++trans_idx;
         }
     } */
};
    void processNoBracketInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& commabit, string& output, long& output_size, long& last_colon_pos, int& temp_state) {
    if (qa.mCurState == UNMATCHED_STATE) return;
     int trans_idx = 0;
    int cur_idx = qa.mCurState - 1;
    int num_trans_str = qa.mDfa.trans_ele[cur_idx].num_trans_str;
    // __m256i v_first = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(record));
    // __m256i v_second = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(record + 32));
    if (num_trans_str == 1) {
        int trans_idx = 0;
         //if (cur_idx == 9) cout<<"start last"<<endl;
         while (trans_idx < 1)//num_trans_str)
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type == OBJECT || trans_type == ARRAY || trans_type == OUTPUT_CANDIDATE) continue;
             if (trans_type == KEY && qa.getType(next_state) != OUTPUT_CANDIDATE) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 if (tmask & carry_mask)
                     qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             tmask = tmask & colonbit;
             if (trans_type == KEY) {
                 if (tmask > 0) {
                 unsigned long temp_mask = tmask;
                 unsigned long matchbit = temp_mask & (-temp_mask);
                 // remove the current matched bit and its prior bits from colon mask
                 unsigned long match_mask = matchbit ^ (matchbit - 1);
                 unsigned long tempbit = commabit & (~match_mask);
                 // process the matched output
                 if (tempbit) {
                     long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                     // long st = -1, ed = -1;
                     //findFieldQuotePos(next_colon_pos, st, ed);
                     long text_length = end_pos - colon_pos - 1;
                    // if (text_length < 0) cout<<"exception"<<endl;
                     // char* text = (char*)malloc(text_length + 1);
                     memcpy(mText, mRecord + colon_pos + 1, text_length);
                     mText[text_length] = '\0';
                     output.append(mText);
                     // free(text);
                     ++output_size;
                 } else {
                     long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     last_colon_pos = offset;
                     temp_state = next_state;
                    //     cout<<"offset0 "<<offset<<" state "<<temp_state<<endl;
                 }
                 }
                 continue;
             }
             if (tmask == 0 && last_match_idx < key_len + 3) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 3) tmask = tmask | 1;
             // consecutive blank characters
             if (last_match_idx == key_len + 4) tmask = tmask | 1;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
             /*if (tmask == 0 && last_match_idx < key_len + 4) {
                 continue;
             }
             if (last_match_idx == key_len + 4) tmask = tmask | 1;*/
         }
    } else {
         int trans_idx = 0;
         while (trans_idx < num_trans_str)
         {
             int i = trans_idx;
             ++trans_idx;
             int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
             int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
             if (trans_type == OBJECT || trans_type == ARRAY || trans_type == OUTPUT_CANDIDATE) continue;
             if (trans_type == KEY && qa.getType(next_state) != OUTPUT_CANDIDATE) continue;
             char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
             int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
             //unsigned long mask = 0;
             int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
             qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             unsigned long carry_mask = 1UL<<63;
             // start quote
             unsigned long tmask = st_quotebit;
             if (tmask == 0 && last_match_idx < 0) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
             tmask = tmask << 1;
             if (last_match_idx == 0) tmask = tmask | 1;
             // check key field
             bool skip_loop = false;
             for (int j = 0; j < key_len; ++j) {
                 char ch = key[j];
                 __m256i v_ch = _mm256_set1_epi8(ch);
                 unsigned long chbit0, chbit;
                 chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                 chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                 chbit = (chbit << 32) | chbit0;
                 tmask = tmask & chbit;
                 if (tmask == 0 && last_match_idx < j + 1) {
                     skip_loop = true;
                     break;
                 }
                 if (tmask & carry_mask)
                     qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                 tmask = tmask << 1;
                 if (last_match_idx == j + 1) tmask = tmask | 1;
             }
             if (skip_loop == true) continue;
             // end quote
             tmask = tmask & ed_quotebit;
             if (tmask == 0 && last_match_idx < key_len + 1) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 1) tmask = tmask | 1;
             // concecutive blank characters
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             unsigned long blankbit0, blankbit;
             __m256i v_blank = _mm256_set1_epi8(' ');
             blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
             blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
             blankbit = (blankbit << 32) | blankbit0;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
             if (tmask == 0 && last_match_idx < key_len + 2) {
                 continue;
             }
             if (last_match_idx == key_len + 2) tmask = tmask | 1;
             tmask = tmask & colonbit;
             if (trans_type == KEY) {
                 if (tmask > 0) {
                 unsigned long temp_mask = tmask;
                 unsigned long matchbit = temp_mask & (-temp_mask);
                 // remove the current matched bit and its prior bits from colon mask
                 unsigned long match_mask = matchbit ^ (matchbit - 1);
                 unsigned long tempbit = commabit & (~match_mask);
                 // process the matched output
                 if (tempbit) {
                     long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                     /*long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     long next_colon_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                     long st = -1, ed = -1;
                     findFieldQuotePos(next_colon_pos, st, ed);*/
                     long text_length = end_pos - colon_pos - 1;
                     //char* text = (char*)malloc(text_length + 1);
                     memcpy(mText, mRecord + colon_pos + 1, text_length);
                     mText[text_length] = '\0';
                     output.append(mText);
                     // free(text);
                     ++output_size;
                 } else {
                     long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                     last_colon_pos = offset;
                     temp_state = next_state;
                //     cout<<"offset "<<offset<<" state "<<temp_state<<endl;
                 }
                 }
                 continue;
             }
             if (tmask == 0 && last_match_idx < key_len + 3) {
                 continue;
             }
             if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
             tmask = tmask << 1;
             if (last_match_idx == key_len + 3) tmask = tmask | 1;
             // consecutive blank characters
             if (last_match_idx == key_len + 4) tmask = tmask | 1;
             tmask = (tmask + blankbit) & (~blankbit);
             if ((blankbit & carry_mask))
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
             /*if (tmask == 0 && last_match_idx < key_len + 4) {
                 continue;
             }
             if (last_match_idx == key_len + 4) tmask = tmask | 1;*/
        }
    }
    //if (cur_idx == 9) cout<<"finish last"<<endl;
};
    void processOpenBracketInterval(QueryAutomaton& qa, __m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& commabit, unsigned long lbracketbit, int& bracket_type, bool& match_flag, bool& skip_unmatched_tkn, string& output, long& output_size)
{
    //match_flag = false;
    if (qa.mCurState == 0) return;
    int cur_idx = qa.mCurState - 1;
    int num_trans_str = qa.mDfa.trans_ele[cur_idx].num_trans_str;
    if (num_trans_str == 1) {
        for (int i = 0; i < 1; ++i) {
            int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
            int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
            if (trans_type == bracket_type) {
                if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                    qa.pushStack(next_state);
                    match_flag = true;
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                }
            }
            else if (trans_type == KEY && qa.getType(next_state) != OUTPUT_CANDIDATE) {
                continue;
            } else {
                char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
                int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
                int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
                qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                unsigned long carry_mask = 1UL<<63;
                // start quote
                unsigned long tmask = st_quotebit;
                if (tmask == 0 && last_match_idx < 0) {
                    continue;
                }
                /////if (tmask & carry_mask)
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
                tmask = tmask << 1;
                if (last_match_idx == 0) tmask = tmask | 1;
                // check key field
                bool skip_loop = false;
                for (int j = 0; j < key_len; ++j) {
                    char ch = key[j];
                    __m256i v_ch = _mm256_set1_epi8(ch);
                    unsigned long chbit0, chbit;
                    chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                    chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                    chbit = (chbit << 32) | chbit0;
                    tmask = tmask & chbit;
                    if (tmask == 0 && last_match_idx < j + 1) {
                        skip_loop = true;
                        break;
                    }
                    /////if (tmask & carry_mask)
                        /////qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                    tmask = tmask << 1;
                    if (last_match_idx == j + 1) tmask = tmask | 1;
                }
                if (skip_loop == true) continue;
                // end quote
                tmask = tmask & ed_quotebit;
                if (tmask == 0 && last_match_idx < key_len + 1) {
                    continue;
                }
                /////if (tmask & carry_mask)
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 1) tmask = tmask | 1;
                // concecutive blank characters
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                unsigned long blankbit0, blankbit;
                __m256i v_blank = _mm256_set1_epi8(' ');
                blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
                blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
                blankbit = (blankbit << 32) | blankbit0;
                tmask = (tmask + blankbit) & (~blankbit);
                /////if ((blankbit & carry_mask))
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
                if (tmask == 0 && last_match_idx < key_len + 2) {
                    continue;
                }
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                // colon
                tmask = tmask & colonbit;
                if (trans_type == KEY) {// || lbracketbit == 0) {
                    if (tmask > 0) {
                        unsigned long temp_mask = tmask;
                        unsigned long matchbit = temp_mask & (-temp_mask);
                        // remove the current matched bit and its prior bits from colon mask
                        unsigned long match_mask = matchbit ^ (matchbit - 1);
                        unsigned long tempbit = commabit & (~match_mask);
           
                        long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                        // process the matched output
                        if (tempbit) {
                            long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                            long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                            long text_length = end_pos - colon_pos - 1;
                            //char* text = (char*)malloc(text_length + 1);
                            memcpy(mText, mRecord + colon_pos + 1, text_length);
                            mText[text_length] = '\0';
                            output.append(mText);
                           // cout<<"text "<<mText<<endl;
                           // free(text);
                            ++output_size;
                        }
                        //cout<<"matched "<<endl;
                    }
                    continue;
                }
                if (tmask == 0 && last_match_idx < key_len + 3) {
                    continue;
                }
                /////if (tmask & carry_mask)
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 3) tmask = tmask | 1;
                // consecutive blank characters
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                tmask = (tmask + blankbit) & (~blankbit);
                /////if ((blankbit & carry_mask))
                    ////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
                if (tmask == 0 && last_match_idx < key_len + 4) {
                    continue;
                }
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                // left brace or left bracket
                tmask = tmask & lbracketbit;
                if (tmask > 0) {
                    if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                        qa.pushStack(next_state);
                        match_flag = true;
                    }
                }
            }
        }
    } else {
         int trans_idx = 0;
         while (trans_idx < num_trans_str) {
            int i = trans_idx;
            ++trans_idx;
        //for (int i = 0; i < num_trans_str; ++i) {
            int trans_type = qa.mDfa.trans_ele[cur_idx].t_str_info[i].type;
            int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
            if (trans_type == bracket_type) {
                if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                    qa.pushStack(next_state);
                    match_flag = true;
                    qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                }
            } else if (trans_type == KEY && qa.getType(next_state) != OUTPUT_CANDIDATE) {
                continue;
            } else {
                char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
                int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
                int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
                qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
                unsigned long carry_mask = 1UL<<63;
                // start quote
                unsigned long tmask = st_quotebit;
                if (tmask == 0 && last_match_idx < 0) {
                    // match_flag = false;
                    continue;
                }
                /////if (tmask & carry_mask)
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
                tmask = tmask << 1;
                if (last_match_idx == 0) tmask = tmask | 1;
                // check key field
                bool skip_loop = false;
                for (int j = 0; j < key_len; ++j) {
                    char ch = key[j];
                    __m256i v_ch = _mm256_set1_epi8(ch);
                    unsigned long chbit0, chbit;
                    chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
                    chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
                    chbit = (chbit << 32) | chbit0;
                    tmask = tmask & chbit;
                    if (tmask == 0 && last_match_idx < j + 1) {
                        skip_loop = true;
                        break;
                    }
                    /////if (tmask & carry_mask)
                        /////qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
                    tmask = tmask << 1;
                    if (last_match_idx == j + 1) tmask = tmask | 1;
                }
                if (skip_loop == true) continue;
                // end quote
                tmask = tmask & ed_quotebit;
                if (tmask == 0 && last_match_idx < key_len + 1) {
                    continue;
                }
                /////if (tmask & carry_mask)
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 1;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 1) tmask = tmask | 1;
                // concecutive blank characters
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                unsigned long blankbit0, blankbit;
                __m256i v_blank = _mm256_set1_epi8(' ');
                blankbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_blank));
                blankbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_blank));
                blankbit = (blankbit << 32) | blankbit0;
                tmask = (tmask + blankbit) & (~blankbit);
                /////if ((blankbit & carry_mask))
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 2;
                if (tmask == 0 && last_match_idx < key_len + 2) {
                    continue;
                }
                if (last_match_idx == key_len + 2) tmask = tmask | 1;
                // colon
                tmask = tmask & colonbit;
                if (trans_type == KEY) {// || lbracketbit == 0) {
                    if (tmask > 0) {
                        unsigned long temp_mask = tmask;
                        unsigned long matchbit = temp_mask & (-temp_mask);
                        // remove the current matched bit and its prior bits from colon mask
                        unsigned long match_mask = matchbit ^ (matchbit - 1);
                        unsigned long tempbit = commabit & (~match_mask);
                        // process the matched output
                        if (tempbit) {
                            long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                            long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                            long text_length = end_pos - colon_pos - 1;
                            //char* text = (char*)malloc(text_length + 1);
                            memcpy(mText, mRecord + colon_pos + 1, text_length);
                            mText[text_length] = '\0';
                            output.append(mText);
                           // cout<<"text "<<mText<<endl;
                           // free(text);
                            ++output_size;
                        }
                    }
                    continue;
                }
                if (tmask == 0 && last_match_idx < key_len + 3) {
                    continue;
                }
                /////if (tmask & carry_mask)
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 3;
                tmask = tmask << 1;
                if (last_match_idx == key_len + 3) tmask = tmask | 1;
                // consecutive blank characters
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                tmask = (tmask + blankbit) & (~blankbit);
                ////if ((blankbit & carry_mask))
                    /////qa.mStateMaskInfo.state_masks[i].last_match_idx = key_len + 4;
                if (tmask == 0 && last_match_idx < key_len + 4) {
                    continue;
                }
                if (last_match_idx == key_len + 4) tmask = tmask | 1;
                // left brace or left bracket
                tmask = tmask & lbracketbit;
                if (tmask > 0) {
                    if (next_state != UNMATCHED_STATE || skip_unmatched_tkn == false) {
                        qa.pushStack(next_state);
                        match_flag = true;
                    }
                }
            }
        }
    }
    };

};
#endif
