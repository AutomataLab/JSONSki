#ifndef SERIALBITMAP_H
#define SERIALBITMAP_H
#include <string>
#include <iostream>
#include <vector>
#include <bitset>
#include <cassert>
#include <stack>
#include <algorithm>
#include <unordered_map>
#include <functional>
#include <math.h>
#include <immintrin.h>
#include "Bitmap.h"
#include <unordered_map>
#include <map>
#include "QueryAutomaton.h"
using namespace std;

#define MAX_STACK_DEPTH 100
typedef struct StackElement{
    unsigned long position;
    unsigned long bits;
}StackElement;

typedef struct MatchedBitmapInfo {
    unsigned long bitmap;
    unsigned long carry;
    unsigned long last_index;
};

class SerialBitmap : public Bitmap {
    friend class SerialBitmapIterator;
  private:
    char* mRecord;
    // for a single large record, stream length equals to record length
    long mRecordLength;
    // each temp word has 32 bytes
    long mNumTmpWords;
    // each word has 64 bytes
    long mNumWords;
    // structural character bitmaps
    unsigned long *mEscapeBitmap, *mStrBitmap, *mColonBitmap, *mCommaBitmap, *mLbracketBitmap, *mRbracketBitmap, *mLbraceBitmap, *mRbraceBitmap;
    // structural quote bitmap, used for key field parsing
    unsigned long *mQuoteBitmap;
    // leveled colon bitmap
    unsigned long *mLevColonBitmap[MAX_LEVEL + 1];
    // leveled comma bitmap
    unsigned long *mLevCommaBitmap[MAX_LEVEL + 1];
    // the deepest level of leveled bitmap indexes
    int mDepth;
    // whether to create leveled comma bitmaps
    bool mArraySupported;
    char mKey[1000];
    long mTempState;
    char* mText;
    bool mUnmatched = false;

  public:
    long mOutputSize;
    
  public:
    SerialBitmap();
    SerialBitmap(char* record, int depth, bool array_supported = true);
    ~SerialBitmap();
    // manually create an automaton
    void generateAutomaton(QueryAutomaton& qa);
    void indexConstruction();
    // following three functions are used for evaluation comparison
    void indexConstructionMison(int num_step = 5);
    void indexConstructionMisonPlus(int num_step = 5);
    void indexConstructionSbSPison(int num_step = 5); 
    // mainly used for small records processing
    void setRecordLength(long length);
    void setQuoteBitmap(unsigned long* quote_bitmap);
    unsigned long* getQuoteBitmap() {return mQuoteBitmap;}
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long bitset[], unsigned long& carry);
    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry); 
   // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, map<char, unsigned long>& bitset, unsigned long& carry);
//    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unordered_map<char, unsigned long>& bitset, unsigned long& carry);
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry);
 
  private:
     char* substring_200(char *pText, int begin, int end)
{
    int i,j;
    char * temp=pText;
    char* temp1=NULL;
    temp1=(char*)malloc((end-begin+1)*sizeof(char));
    for (j = 0,i = begin; i < end; i++,j++)
    {
        temp1[j]=temp[i];
    }
    temp1[j]='\0';
    return temp1;
}
    void freeMemory();
    // all following functions are used for evaluation comparison
    void buildStructuralCharacterBitmap();
    void buildStructuralQuoteBitmapMison();
    void buildStructuralQuoteBitmapPison();
    void buildStringMaskBitmapMison();
    void buildStringMaskBitmapPison();
    void updateStructuralCharacterBitmap();
    void buildLeveledBitmapMison();
    void buildLeveledBitmapPison();
    bool findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos, unsigned long& quote_bit);
    // process key-pri pairs within an interval separated by two consecutive brackets
    void processKeyPriPairs(QueryAutomaton& qa, long& word_id, unsigned long& colon_brace_bit, long& last_colon_pos, string& output, long& output_size, unsigned long& quote_bit, unsigned long& last_quote_bit, unsigned long& end_value_bit, unsigned long& comma_brace_bit, bool& is_right_brace);
    void processKeyBracket(QueryAutomaton& qa, int type, long& last_colon_pos, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, unsigned long& last_quote_bit);
    void processOpenBracket(QueryAutomaton& qa, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn);
    void processCloseBracket(QueryAutomaton& qa, bool& skip_arr_ele);
    // process an array member
    void processArrayMember(QueryAutomaton& qa, long& last_comma_pos, bool& skip_arr_ele);
    // process a candidate array interval separated yb two consecutive brackets
    void processCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& commabit, long& last_comma_pos, bool& skip_arr_ele);
    void processNoKeyInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit);
    void processKeyNoBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, string& output, long& output_size);    
    // void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, bool& match_flag, string& output, long& output_size);
    void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, string& output, long& output_size);
};
#endif
