#ifndef SERIALBITMAP_H
#define SERIALBITMAP_H
#include <string>
#include <iostream>
#include <vector>
#include <bitset>
#include <cassert>
#include <stack>
#include <algorithm>
#include <unordered_map>
#include <functional>
#include <math.h>
#include <immintrin.h>
#include "Bitmap.h"
#include <unordered_map>
#include <map>
#include <string>
#include "QueryAutomaton.h"
#include "rdtsc.h"
using namespace std;

#ifndef unlikely
#define unlikely(x) __builtin_expect(!!(x), 0)
#endif

#define MAX_STACK_DEPTH 100
typedef struct StackElement{
    unsigned long position;
    unsigned long bits;
}StackElement;

typedef struct MatchedBitmapInfo {
    unsigned long bitmap;
    unsigned long carry;
    unsigned long last_index;
};

class SerialBitmap : public Bitmap {
    friend class SerialBitmapIterator;
  private:
    unsigned long mPendMask = 0;
    char* mRecord;
    // for a single large record, stream length equals to record length
    long mRecordLength;
    // each temp word has 32 bytes
    long mNumTmpWords;
    // each word has 64 bytes
    long mNumWords;
    // structural character bitmaps
    unsigned long *mEscapeBitmap, *mStrBitmap, *mColonBitmap, *mCommaBitmap, *mLbracketBitmap, *mRbracketBitmap, *mLbraceBitmap, *mRbraceBitmap;
    // structural quote bitmap, used for key field parsing
    unsigned long *mQuoteBitmap;
    // leveled colon bitmap
    unsigned long *mLevColonBitmap[MAX_LEVEL + 1];
    // leveled comma bitmap
    unsigned long *mLevCommaBitmap[MAX_LEVEL + 1];
    // the deepest level of leveled bitmap indexes
    int mDepth;
    // whether to create leveled comma bitmaps
    bool mArraySupported;
    char mKey[1000];
    long mTempState;
    char* mText;
    bool mUnmatched = false;
    unsigned long mColonBit = 0;
    long mWordId;
    bool mSmallRec = false;
    QueryAutomaton qa;
    long mSubstrSearchCost = 0;

  public:
    long mOutputSize;
    string mOutput;
    
  public:
    SerialBitmap();
    SerialBitmap(char* record, int depth, bool array_supported = true);
    ~SerialBitmap();
    // manually create an automaton
    void generateAutomaton(QueryAutomaton& qa);
    void indexConstruction();
    // following three functions are used for evaluation comparison
    void indexConstructionMison(int num_step = 5);
    void indexConstructionMisonPlus(int num_step = 5);
    void indexConstructionSbSPison(int num_step = 5); 
    // mainly used for small records processing
    void smallRecordInitialize();
    void setRecord(char* record);
    void setRecordLength(long length);
    void setQuoteBitmap(unsigned long* quote_bitmap);
    unsigned long* getQuoteBitmap() {return mQuoteBitmap;}
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long bitset[], unsigned long& carry);
    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry); 
    __attribute__((always_inline)) bool substrSearch_4(string* str, int num_str);
    __attribute__((always_inline)) bool substrSearch_2(string* str, int num_str);
    __attribute__((always_inline)) bool substrSearch(string* str, int num_str);

   // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, map<char, unsigned long>& bitset, unsigned long& carry);
//    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unordered_map<char, unsigned long>& bitset, unsigned long& carry);
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry);
 
  private:
     char* substring_200(char *pText, int begin, int end)
{
    int i,j;
    char * temp=pText;
    char* temp1=NULL;
    temp1=(char*)malloc((end-begin+1)*sizeof(char));
    for (j = 0,i = begin; i < end; i++,j++)
    {
        temp1[j]=temp[i];
    }
    temp1[j]='\0';
    return temp1;
}
    void freeMemory();
    // all following functions are used for evaluation comparison
    void buildStructuralCharacterBitmap();
    void buildStructuralQuoteBitmapMison();
    void buildStructuralQuoteBitmapPison();
    void buildStringMaskBitmapMison();
    void buildStringMaskBitmapPison();
    void updateStructuralCharacterBitmap();
    void buildLeveledBitmapMison();
    void buildLeveledBitmapPison();
    bool findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos, unsigned long& quote_bit);
    // process key-pri pairs within an interval separated by two consecutive brackets
    void processKeyPriPairs(QueryAutomaton& qa, long& word_id, unsigned long& colon_brace_bit, long& last_colon_pos, string& output, long& output_size, unsigned long& quote_bit, unsigned long& last_quote_bit, unsigned long& end_value_bit, unsigned long& comma_brace_bit, bool& is_right_brace);
    void processKeyBracket(QueryAutomaton& qa, int type, long& last_colon_pos, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, unsigned long& last_quote_bit);
    void processOpenBracket(QueryAutomaton& qa, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn);
    void processCloseBracket(QueryAutomaton& qa, bool& skip_arr_ele);
    // process an array member
    void processArrayMember(QueryAutomaton& qa, long& last_comma_pos, bool& skip_arr_ele);
    // process a candidate array interval separated yb two consecutive brackets
    void processCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& commabit, long& last_comma_pos, bool& skip_arr_ele);
    void processNoKeyInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit);
    void processKeyNoBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, string& output, long& output_size);    
    // void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, bool& match_flag, string& output, long& output_size);
    void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, string& output, long& output_size);


__attribute__((always_inline)) void measureSubstrSearchCost(QueryAutomaton& qa, __m256i& v_first, __m256i& v_second, long& word_id, unsigned long& ini_mask) {
    
    if (qa.mCurState == UNMATCHED_STATE) return;
    int i = 0;
    int cur_idx = qa.mCurState - 1;
    int num_keys = qa.mDfa.trans_ele[cur_idx].num_keys;
    for (int idx = 0; idx < num_keys; ++idx) {
        i = idx;
        int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
        if (qa.getType(next_state) == OUTPUT_CANDIDATE) {
            // visit all candidtate substrings
            int num_predicates = qa.mMatchedStateInfo[next_state]->num_predicates;
            for (int j = 0; j < num_predicates; ++j) {
                char* predicate = mMatchedStateInfo[next_state]->predicates[j];
                int len_predicate = mMatchedStateInfo[next_state]->len_predicates[j];
                long start = rdtsc();
                // perform substring searching based on the predicate length
                if (len_predicate == 2 || len_predicate == 4) {
                    // Method in Sparser
                    // check all candidates ++mMatchedStateInfo[next_state]->num_key_candidates[j]; 
 
                } else {
                    // Proposed Method based on icgrep
                    // check all candidates ++mMatchedStateInfo[next_state]->num_key_candidates[j]; 
                }
                long end = rdtsc();
                mMatchedStateInfo[next_state]->costs[j] += (end - start);
            }
        }
   //     char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
   //     char* target_key = key;
   //      int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
   //     int target_key_len = key_len;
        /*char** predicates = qa.mDfa.trans_ele[cur_idx].t_str_info[i].predicates[i];
        int* len_predicates = qa.mDfa.trans_ele[cur_idx].t_str_info[i].len_predicates[i];
        int num_predicates = qa.mDfa.trans_ele[cur_idx].t_str_info[i].num_predicates[i];
        for (int j = 0; j < num_predicates; ++j) {
            char* predicate = predicates[j];
            int len_predicate = len_predicates[j];
            long start = rdtsc();
            // 2-byte RF
            if (len_predicate == 2) {
                
            } else if (len_predicate == 4) {  //4-byte RF

            } else {  // 8-byte RF
                
            }
            long end = rdtsc();
            qa.mDfa.trans_ele[cur_idx].t_str_info[i].costs[j] += (end - start);
            qa.mDfa.trans_ele[cur_idx].t_str_info[i].num_candidates[j] += 1; 
        }*/
        /*int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
        qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;*/
    }
}


#ifdef FILTER5
__attribute__((always_inline)) void processNoBracketInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& commabit, string& output, long& output_size, long& last_colon_pos, int& temp_state, unsigned long& ini_mask) {
        if (qa.mCurState == UNMATCHED_STATE) return;
        if (last_colon_pos > -1 && commabit) {
            if (qa.getType(temp_state) == OUTPUT_CANDIDATE) {
                long end_pos = (word_id) * 64 + __builtin_ctzll(commabit);
                long text_length = end_pos - last_colon_pos - 1;
                //cout<<"text length "<<text_length<<endl;
                long temp_len = text_length;
                char* temp_start = mRecord + last_colon_pos + 1;
                char* ttext = mText;
                __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                ttext += 32;
                temp_len -= 32;
                temp_start += 32;
                if (unlikely(temp_len > 0)) {
                    while (temp_len > 0) {
                        __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                        _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                        ttext += 32;
                        temp_len -= 32;
                        temp_start += 32;
                    }
                } 
            //    memcpy(mText, mRecord + last_colon_pos + 1, text_length);
                mText[text_length] = '\0';
               // mText = mText + text_length + 1;
                output.append(mText);
            ///    cout<<mText<<endl;
             ///   ++output_size;
                #ifdef FILTER3
                mUnmatched = true;
                #endif
            }
            last_colon_pos = -1;
            if (qa.mDfa.trans_ele[qa.mCurState - 1].num_matched_keys == qa.mDfa.trans_ele[qa.mCurState - 1].num_keys) {
                ///cout<<"return "<<endl;
                return;
            }
        }
        int cur_idx = qa.mCurState - 1;
        int i = 0;
        int num_keys = 2;//qa.mDfa.trans_ele[cur_idx].num_keys;
  ///      if (qa.mCurState != 4) cout<<"exception state "<<qa.mCurState<<endl;
       /// cout<<"num keys "<<num_keys<<endl;
        for (int idx = 0; idx < num_keys; ++idx) {
        i = idx;//qa.mDfa.trans_ele[cur_idx].key_idx[idx];
        #ifdef MULFILTER3
        /*if (qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == false) {
            cout<<"unvisited state "<<qa.mCurState<<" "<<(qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == false)<<" "<<i<<endl;
        }*/
        if (qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == true) {
            qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
             continue;
        }
        #endif
        int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
        char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
        char* target_key = key;
        int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
        int target_key_len = key_len;
        int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
        qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;

        if (mPendMask == next_state) {
            /// cout<<"pend mask "<<endl;
            /// unsigned long matchbit = mPendMask & (-mPendMask);
            /// mPendMask = 0;
            unsigned long tempcolonbit = colonbit;// & (~(matchbit ^ (matchbit - 1)));
            tempcolonbit = tempcolonbit & (-tempcolonbit);
            if (tempcolonbit) {
                mPendMask = 0;
                // unsigned long matchstartquotebit = st_quotebit & (matchbit ^ (matchbit - 1));
                // long match_start_pos = word_id * 64 + __builtin_ctzll(matchstartquotebit);
                /// last_quote_bit = st_quotebit & (tempcolonbit ^ (tempcolonbit - 1));
                long cur_colon_pos = word_id * 64 + __builtin_ctzll(tempcolonbit);
                long st = -1, ed = -1;
                unsigned long tmpbit = 0;
                findFieldQuotePos(cur_colon_pos, st, ed, tmpbit);
                /// cout<<" pos "<<cur_colon_pos<<" "<<st<<" "<<ed<<endl;
                if ((ed - st - 1 == target_key_len) && memcmp(mRecord + st + 1, target_key, target_key_len) == 0) {
                    if (qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == true) {
                        cout<<"repetitive "<<target_key<<endl;
                    }
                    ++output_size;
                    unsigned long match_mask = tempcolonbit ^ (tempcolonbit - 1);
                    unsigned long tempbit = commabit & (~match_mask);
                    if (tempbit) {
                        long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                        long text_length = end_pos - cur_colon_pos - 1;
                        memcpy(mText, mRecord + cur_colon_pos + 1, text_length);
                        mText[text_length] = '\0';
                        ///cout<<mText<<" "<<text_length<<endl;
                        output.append(mText);
                       /// ++output_size;
                    } else {
                        /// long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                        last_colon_pos = cur_colon_pos;
                        temp_state = next_state;
                    }
                    #ifdef MULFILTER3
                    qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited = true;
                    ++qa.mDfa.trans_ele[cur_idx].num_matched_keys;
                    #endif
                    continue;
                }
                /*long temp_pos = word_id * 64 + __builtin_ctzll(matchbit);
                bitset<64> quotebitmap(st_quotebit);
                bitset<64> colonbitmap(tempcolonbit);
                bitset<64> ocolonbitmap(colonbit);
                bitset<64> matchbitmap(matchbit);
                cout<<"cur colon pos "<<cur_colon_pos<<" "<<st<<" "<<ed<<" temp_pos "<<temp_pos<<endl;
                cout<<"quotebitmap "<<quotebitmap<<endl;
                cout<<"colonbitmap "<<colonbitmap<<endl;
                cout<<"oricolonbitmap "<<ocolonbitmap<<endl;
                cout<<"match bitmap "<<matchbitmap<<endl;
                */
                /// cout<<substring_200(mRecord, st + 1, ed)<<endl;
            } /*else {
               cout<<"pend mask not done "<<endl;
            }*/
        }
        // start quote
       /* unsigned long tmask = st_quotebit;
        if (tmask == 0 && last_match_idx < 0) {
            //return;
            continue;
        }
        //if (last_match_idx > -1)
        //++output_size;
        if (tmask & carry_mask)
            qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
        tmask = tmask << 1;
        if (last_match_idx == 0) tmask = tmask | 1;*/
        if (i == 0) {
        //if (qa.mCurState == 3) {
            key = "id";
            key_len = 2;
        } else { //if (qa.mCurState == 6) {
            key = "la";
            key_len = 2;
       }
        unsigned long tmask = 0xffffffffffffffff & ini_mask;
        // check key field
        int j = 0;
        for (j = 0; j < key_len; ++j) {
            char ch = key[j];
            __m256i v_ch = _mm256_set1_epi8(ch);
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit;
            if (tmask == 0 && last_match_idx < j + 1) {
                //cout<<"unmatched "<<ch<<endl;
                ///return;
                break;
            }
            if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
            tmask = tmask << 1;
            if (last_match_idx == j + 1) tmask = tmask | 1;
        }
        if (j < key_len) continue;
        unsigned long tempcolonbit = colonbit;// & (~(matchbit ^ (matchbit - 1)));
        unsigned long last_quote_bit;// = quote_bit & (colon_brace_bit ^ (colon_brace_bit - 1));
        unsigned long pendcolonbit;     

        while (tmask) {
            unsigned long matchbit = tmask & (-tmask);
            tempcolonbit = colonbit & (~(matchbit ^ (matchbit - 1)));
            tempcolonbit = tempcolonbit & (-tempcolonbit);
            if (tempcolonbit) {
                // unsigned long matchstartquotebit = st_quotebit & (matchbit ^ (matchbit - 1));
                // long match_start_pos = word_id * 64 + __builtin_ctzll(matchstartquotebit);
                last_quote_bit = st_quotebit & (tempcolonbit ^ (tempcolonbit - 1));
                long cur_colon_pos = word_id * 64 + __builtin_ctzll(tempcolonbit);
                long st = -1, ed = -1;
                findFieldQuotePos(cur_colon_pos, st, ed, last_quote_bit);
                if ((ed - st - 1 == target_key_len) && memcmp(mRecord + st + 1, target_key, target_key_len) == 0) {
                    if (qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == true) {
                        cout<<"repetitive "<<target_key<<endl;
                    }
                    ++output_size;
                    unsigned long match_mask = tempcolonbit ^ (tempcolonbit - 1);
                    unsigned long tempbit = commabit & (~match_mask);
                    if (tempbit) {
                        long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                        long text_length = end_pos - cur_colon_pos - 1; 
                        memcpy(mText, mRecord + cur_colon_pos + 1, text_length);
                        mText[text_length] = '\0';
                        ///cout<<mText<<" "<<text_length<<endl;
                        output.append(mText);
                    ///   ++output_size;
                    } else {
                        /// long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                        last_colon_pos = cur_colon_pos;
                        temp_state = next_state; 
                    }
                    #ifdef MULFILTER3
                    qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited = true;
                    ++qa.mDfa.trans_ele[cur_idx].num_matched_keys;
                    #endif
                    break;
                }
                /*long temp_pos = word_id * 64 + __builtin_ctzll(matchbit);
                bitset<64> quotebitmap(st_quotebit);
                bitset<64> colonbitmap(tempcolonbit);
                bitset<64> ocolonbitmap(colonbit);
                bitset<64> matchbitmap(matchbit);
                cout<<"cur colon pos "<<cur_colon_pos<<" "<<st<<" "<<ed<<" temp_pos "<<temp_pos<<endl;
                cout<<"quotebitmap "<<quotebitmap<<endl;
                cout<<"colonbitmap "<<colonbitmap<<endl;
                cout<<"oricolonbitmap "<<ocolonbitmap<<endl;
                cout<<"match bitmap "<<matchbitmap<<endl;
                cout<<substring_200(mRecord, st + 1, ed)<<endl;
                */

            } /*else {
                cout<<"no colon for the current match "<<endl;
                mPendMask = tmask;
            }*/
            tmask = tmask & (tmask - 1);
            if (!tempcolonbit && !tmask) {
             ///   cout<<" last one no colon for the current match "<<endl;
                mPendMask = next_state;
            }
        }

        /*if (1==2 && tmask > 0) { //++output_size;
            #ifdef MULFILTER3
            qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited = true;
            #endif
            // match is detected
            unsigned long temp_mask = tmask;
            unsigned long matchbit = temp_mask & (-temp_mask);
            // remove the current matched bit and its prior bits from colon mask
            unsigned long match_mask = matchbit ^ (matchbit - 1);
            unsigned long tempbit = commabit & (~match_mask);
            // process the matched output
            if (tempbit) {
                long colon_pos = (word_id) * 64 + __builtin_ctzll(temp_mask);
                long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                long text_length = end_pos - colon_pos - 1;
                //cout<<"text length "<<text_length<<endl;
                long temp_len = text_length;
                char* temp_start = mRecord + colon_pos + 1;
                char* ttext = mText;
                __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                ttext += 32;
                temp_len -= 32;
                temp_start += 32;
                if (unlikely(temp_len > 0)) {
                    while (temp_len > 0) {
                        __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                        _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                        ttext += 32;
                        temp_len -= 32;
                        temp_start += 32;
                    }
                }
                //memcpy(mText, mRecord + colon_pos + 1, text_length);
                mText[text_length] = '\0';
                ///cout<<mText<<" "<<text_length<<endl;
                output.append(mText);
           //     mText = mText + text_length + 1;
           //     cout<<mText<<endl;
                ++output_size;
                #ifdef FILTER3
                mUnmatched = true;
                #endif
            } else {
                long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                last_colon_pos = offset;
                temp_state = next_state;
            }
          //  qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
        }*/
        }
        //qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
    }
#endif

};
#endif
