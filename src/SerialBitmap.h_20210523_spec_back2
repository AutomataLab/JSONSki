#ifndef SERIALBITMAP_H
#define SERIALBITMAP_H
#include <string>
#include <iostream>
#include <vector>
#include <bitset>
#include <cassert>
#include <stack>
#include <algorithm>
#include <unordered_map>
#include <functional>
#include <math.h>
#include <immintrin.h>
#include "Bitmap.h"
#include <unordered_map>
#include <map>
#include <string>
#include "QueryAutomaton.h"
///#include "rdtsc.h"
using namespace std;

#ifndef unlikely
#define unlikely(x) __builtin_expect(!!(x), 0)
#endif

#define MAX_STACK_DEPTH 100
typedef struct StackElement{
    unsigned long position;
    unsigned long bits;
}StackElement;

typedef struct MatchedBitmapInfo {
    unsigned long bitmap;
    unsigned long carry;
    unsigned long last_index;
};

typedef struct Tuple {
    int state;
    int trans_idx;
} Tuple;

class SerialBitmap : public Bitmap {
    friend class SerialBitmapIterator;
  private:
    int mMapIdx = 0;
    int mIntervalState = 1;
    int map[1000];
    std::map<int, int> mMap;
    unsigned long mPendMask = 0;
    char* mRecord;
    // for a single large record, stream length equals to record length
    long mRecordLength;
    // each temp word has 32 bytes
    long mNumTmpWords;
    // each word has 64 bytes
    long mNumWords;
    // structural character bitmaps
    unsigned long *mEscapeBitmap, *mStrBitmap, *mColonBitmap, *mCommaBitmap, *mLbracketBitmap, *mRbracketBitmap, *mLbraceBitmap, *mRbraceBitmap;
    // structural quote bitmap, used for key field parsing
    unsigned long *mQuoteBitmap;
    // leveled colon bitmap
    unsigned long *mLevColonBitmap[MAX_LEVEL + 1];
    // leveled comma bitmap
    unsigned long *mLevCommaBitmap[MAX_LEVEL + 1];
    // the deepest level of leveled bitmap indexes
    int mDepth;
    // whether to create leveled comma bitmaps
    bool mArraySupported;
    char mKey[1000];
    long mTempState;
    char* mText;
    bool mUnmatched = false;
    unsigned long mColonBit = 0;
    long mWordId;
    bool mSmallRec = false;
    // QueryAutomaton qa;
    long mSubstrSearchCost = 0;

  public:
    QueryAutomaton qa;
    long mOutputSize;
    string mOutput;
    
  public:
    SerialBitmap();
    SerialBitmap(char* record, int depth, bool array_supported = true);
    ~SerialBitmap();
    // manually create an automaton
    void generateAutomaton(QueryAutomaton& qa);
    void indexConstruction();
    // following three functions are used for evaluation comparison
    void indexConstructionMison(int num_step = 5);
    void indexConstructionMisonPlus(int num_step = 5);
    void indexConstructionSbSPison(int num_step = 5); 
    // mainly used for small records processing
    void smallRecordInitialize();
    void setRecord(char* record);
    void setRecordLength(long length);
    void setQuoteBitmap(unsigned long* quote_bitmap);
    unsigned long* getQuoteBitmap() {return mQuoteBitmap;}
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long bitset[], unsigned long& carry);
    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry); 

    // Sparser
    __attribute__((always_inline)) int substrCnt_2RF(__m256i& v_target, int word_id, unsigned long& ini_mask) {
        unsigned long k = word_id * 64;
        int cnt = 0;
        __m256i v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
        unsigned long matchbit1 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
        // matchbit = matchbit & (ini_mask >> 32);
       //  cnt += __builtin_popcountll(matchbit1) / 2;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
        unsigned long matchbit2 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target)); 
        // matchbit = matchbit & ((ini_mask >> 33) | (1 << 31));
       //  cnt += __builtin_popcountll(matchbit2) / 2;
        k += 32;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
        unsigned long matchbit11 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
        matchbit1 = (matchbit11 << 32) | matchbit1;
    ///    matchbit1 = ((unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target)) << 32) | matchbit1;
        // matchbit = matchbit & ini_mask;
    ///     cnt += __builtin_popcountll(matchbit1) / 2;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
        unsigned long matchbit22 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
         matchbit2 = (matchbit22 << 32) | matchbit2;
    ///    matchbit2 = ((unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target)) << 32) | matchbit2;
        // matchbit = matchbit & ((ini_mask >> 1) | (1 << 31));
    ///     cnt += __builtin_popcountll(matchbit2) / 2; 
        matchbit1 = matchbit1 & ini_mask;
        cnt += __builtin_popcountll(matchbit1) / 2;
        int cnt_bit1 = __builtin_popcountll(matchbit1);
        if (cnt_bit1 % 2 == 1) ++cnt;
       matchbit2 = (matchbit2 << 1) & ini_mask; //((ini_mask >> 1) | (1UL << 63));
        int cnt_bit2 = __builtin_popcountll(matchbit2);
        if (cnt_bit2 % 2 == 1) ++cnt;
        cnt += __builtin_popcountll(matchbit2) / 2;
     ///   if (cnt != 0) cout<<" cnt_2 "<<cnt<<endl;
        
        return cnt;
    }

     __attribute__((always_inline)) int substrCnt_2RF1(char* substr, __m256i& v_first, __m256i& v_second, unsigned long& ini_mask, int trans_str_idx) {
        unsigned long tmask = ini_mask;
        int cur_idx = qa.mCurState - 1;
        int last_match_idx = qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx;
        qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;
        int cnt = 0;
        int l = 0;
        // first character
        char ch = substr[0];
                   // cout<<"ch "<<ch<<" "<<l<<endl;
        __m256i v_ch = _mm256_set1_epi8(ch);
        unsigned long chbit0, chbit;
        chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
        chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
        chbit = (chbit << 32) | chbit0;
        tmask = tmask & chbit;
        if (tmask == 0 && last_match_idx < 1) {
            return 0;
        }
    ///    cout<<" trans indx "<<trans_str_idx<<endl;
        if (tmask & carry_mask)
            qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = 1;
        tmask = tmask << 1UL;
        if (last_match_idx == 1) tmask = tmask | 1;   
        if (tmask) {
            ++l;
            ch = substr[1];
            v_ch = _mm256_set1_epi8(ch);
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;   
            tmask = tmask & chbit;
            cnt = __builtin_popcountll(tmask);
        }
        //}
     ///   cnt = __builtin_popcount(tmask); 
        /*for (int l = 0; l < 2; ++l) { //word_len
            char ch = substr[l];
                   // cout<<"ch "<<ch<<" "<<l<<endl;
            __m256i v_ch = _mm256_set1_epi8(ch);
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit;
            if (tmask == 0 && last_match_idx < l + 1) {
                /// cout<<"jump out of the loop "<<endl;
                break;
            }
            if (l == 1) break;
            if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = l + 1;
            tmask = tmask << 1;
 ///           if (last_match_idx == l + 1) tmask = tmask | 1;
        }
        cnt = __builtin_popcountl(tmask);*/
      /// if (cnt != 0) cout<<"cnt_8 "<<cnt<<endl;
        return cnt;
    }

    __attribute__((always_inline)) int substrCnt_2RF2(char* substr, __m256i& v_first, __m256i& v_second, unsigned long& ini_mask, int trans_str_idx) {
        unsigned long tmask = ini_mask;
        int last_match_idx = qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx;
        //////cout<<"cur state "<<qa.mCurState<<" trans str idx "<<trans_str_idx<<endl;
        qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;
        int cnt = 0;
        for (int l = 0; l < 1; ++l) { //word_len
            /*if (last_match_idx == l) {
                tmask = tmask | 1;
            }*/
            char ch = substr[l];
                   // cout<<"ch "<<ch<<" "<<l<<endl;
            __m256i v_ch = _mm256_set1_epi8(ch);
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit;
            /*if (tmask == 0 && last_match_idx < l + 1) {
                /// cout<<"jump out of the loop "<<endl;
                break;
            }*/
            // cout<<"match first character "<<ch<<endl;
            if (tmask & carry_mask)
                qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = l + 1;
            tmask = tmask << 1;
            /*if (l < 1) {
                if (tmask & carry_mask)
                    qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = l + 1;
                tmask = tmask << 1UL;
                if (last_match_idx == l + 1) tmask = tmask | 1;
            }*/
        }
        if (last_match_idx == 1) {
            tmask = tmask | 1;
        }
        if (tmask) {
            char ch = substr[1];
            __m256i v_ch = _mm256_set1_epi8(ch); 
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit; 
            /// tmask = tmask << 1; 
            cnt = __builtin_popcount(tmask);
        }
        ///if (cnt != 0) cout<<"cnt_2 "<<cnt<<endl;
        return cnt;
    }

    __attribute__((always_inline)) int substrCnt_4RF(__m256i& v_target, int word_id, unsigned long& ini_mask) {
        unsigned long k = word_id * 64;
        int cnt = 0;
        __m256i v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
        unsigned long matchbit1 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
     ///   cnt += __builtin_popcountll(matchbit1) / 4; 
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
        unsigned long matchbit2 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
     ///   cnt += __builtin_popcountll(matchbit2) / 4;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 2));
        unsigned long matchbit3 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit3) / 4;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 3));
        unsigned long matchbit4 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit4) / 4;
        k += 32;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
        unsigned long matchbit11 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit11) / 4;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
        unsigned long matchbit22 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit22) / 4;
         v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 2));
        unsigned long matchbit33 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit33) / 4;
         v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 3));
        unsigned long matchbit44 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit44) / 4;
        matchbit1 = (matchbit11 << 32) | matchbit1;
        matchbit2 = (matchbit22 << 32) | matchbit2;
        matchbit3 = (matchbit33 << 32) | matchbit3;
        matchbit4 = (matchbit44 << 32) | matchbit4;
        /*cnt += __builtin_popcountll(matchbit1) / 4;
        cnt += __builtin_popcountll(matchbit2) / 4;
        cnt += __builtin_popcountll(matchbit3) / 4;
        cnt += __builtin_popcountll(matchbit4) / 4;*/
       /* matchbit1 = matchbit1 & ini_mask;
        cnt += __builtin_popcountll(matchbit1) / 4;
        matchbit2 = (matchbit2 << 1) & ini_mask;
        int cnt_bit2 = __builtin_popcountll(matchbit2);
        if (cnt_bit2 % 4 > 0) ++cnt;
        cnt += __builtin_popcountll(matchbit2) / 4; 
        matchbit3 = (matchbit3 << 2) & ini_mask;
        int cnt_bit3 = __builtin_popcountll(matchbit3);
        if (cnt_bit3 % 4 > 0) ++cnt;
        cnt += __builtin_popcountll(matchbit3) / 4; 
        matchbit4 = (matchbit4 << 3) & ini_mask;
        int cnt_bit4 = __builtin_popcountll(matchbit4);
        if (cnt_bit4 % 4 > 0) ++cnt;
        cnt += cnt_bit4 / 4;
*/
        cnt = 0;
        matchbit1 = matchbit1 & 0x1111111111111111;
        matchbit2 = matchbit2 & 0x1111111111111111;
        matchbit3 = matchbit3 & 0x1111111111111111;
        /*if (matchbit4) {
            bitset<64> tempbit(matchbit4);
            cout<<"temp bit "<<tempbit<<endl;
        }*/
        matchbit4 = matchbit4 & 0x1111111111111111;
        /*if (matchbit4) {
            bitset<64> tempbit(matchbit4);
            cout<<"after temp bit "<<tempbit<<endl;
        } */
        matchbit1 = matchbit1 & ini_mask;
        matchbit2 = (matchbit2 << 1) & (ini_mask);
        matchbit3 = (matchbit3 << 2) & (ini_mask);
        matchbit4 = (matchbit4 << 3) & (ini_mask);
        /*cnt += __builtin_popcountll(matchbit1);
        cnt += __builtin_popcountll(matchbit2);
        cnt += __builtin_popcountll(matchbit3);
        cnt += __builtin_popcountll(matchbit4); 
        */while (matchbit1) {
            ++cnt;
            matchbit1 = matchbit1 & (matchbit1 - 1);
        }
        while (matchbit2) {
            ++cnt;
            matchbit2 = matchbit2 & (matchbit2 - 1);
        }
        while (matchbit3) {
            ++cnt;
            matchbit3 = matchbit3 & (matchbit3 - 1);
        }
        while (matchbit4) {
            ++cnt;
            matchbit4 = matchbit4 & (matchbit4 - 1);
        }


        /*matchbit2 = matchbit2 & ((ini_mask << 1) | 1);
        cnt += __builtin_popcount(matchbit2) / 4;
        matchbit3 = matchbit3 & ((ini_mask << 2) | 3);
        cnt += __builtin_popcount(matchbit3) / 4;
        matchbit4 = matchbit4 & ((ini_mask << 3) | 7);
        cnt += __builtin_popcount(matchbit4) / 4;*/
       /// if (cnt != 0) cout<<" cnt_4 "<<cnt<<endl; 
        return cnt;
    }

     __attribute__((always_inline)) int substrCnt_4RF1(char* substr, __m256i& v_first, __m256i& v_second, unsigned long& ini_mask, int trans_str_idx) {
        unsigned long tmask = ini_mask;
        int cur_idx = qa.mCurState - 1;
        int last_match_idx = qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx;
        qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;
        int cnt = 0;
        for (int l = 0; l < 3; ++l) { //word_len
            char ch = substr[l];
                   // cout<<"ch "<<ch<<" "<<l<<endl;
            __m256i v_ch = _mm256_set1_epi8(ch);
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit;
            if (tmask == 0 && last_match_idx < l + 1) {
                /// cout<<"jump out of the loop "<<endl;
                break;
            }
            /// if (l == 3) break;
            if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = l + 1;
            tmask = tmask << 1;
            if (last_match_idx == l + 1) tmask = tmask | 1;
        }
        if (tmask) {
        char ch = substr[3];
        __m256i v_ch = _mm256_set1_epi8(ch);
        unsigned long chbit0, chbit;
        chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
        chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
        chbit = (chbit << 32) | chbit0;
        tmask = tmask & chbit; 
    ///    cnt = __builtin_popcountll(tmask);
        cnt = 0;
        while (tmask) {
            ++cnt;
            tmask = tmask & (tmask - 1);
        }

        }
        ///cnt = __builtin_popcountll(tmask); 
       /// if (cnt != 0) cout<<"cnt_8 "<<cnt<<endl;
        return cnt;
    }

     __attribute__((always_inline)) int substrCnt_8RF(char* substr, __m256i& v_first, __m256i& v_second, unsigned long& ini_mask, int trans_str_idx) {
        unsigned long tmask = ini_mask;
        int cur_idx = qa.mCurState - 1;
        int last_match_idx = qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx;
        qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;
        int cnt = 0;
        for (int l = 0; l < 7; ++l) { //word_len
            char ch = substr[l];
                   // cout<<"ch "<<ch<<" "<<l<<endl;
            __m256i v_ch = _mm256_set1_epi8(ch);
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit;
            if (tmask == 0 && last_match_idx < l + 1) {
                /// cout<<"jump out of the loop "<<endl;
                break;
            }
            if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = l + 1;
            tmask = tmask << 1;
            if (last_match_idx == l + 1) tmask = tmask | 1;
        }
        if (tmask) {
        char ch = substr[7];
         __m256i v_ch = _mm256_set1_epi8(ch);
        unsigned long chbit0, chbit;
        chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
        chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
        chbit = (chbit << 32) | chbit0;
        tmask = tmask & chbit; 
        cnt = __builtin_popcount(tmask); 
        }
       /// if (cnt != 0) cout<<"cnt_8 "<<cnt<<endl;
        return cnt;
    }


    __attribute__((always_inline)) unsigned long substrBitmapFromWord_4(__m256i& v_target, int word_id, unsigned long& ini_mask) {
        unsigned long k = word_id * 64;
        unsigned long matchbits = 0;
        for (int j = 1; j <= 2; ++j) {
            __m256i v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
            unsigned matchbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
            matchbit = matchbit | (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 2));
            matchbit = matchbit | (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
            v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 3));
            matchbit = matchbit | (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi16(v_text, v_target));
            if (j == 1)
                matchbits = matchbit;
            else matchbits = (matchbits << 32) | matchbit;
            k += 32;
        }
        return matchbits & ini_mask;
    }

    __attribute__((always_inline)) unsigned long substrBitmapFromWord_8(char* substr, __m256i& v_first, __m256i& v_second, unsigned long& ini_mask, int trans_str_idx) {
        unsigned long tmask = ini_mask;
        int cur_idx = qa.mCurState - 1;
        int last_match_idx = qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx;
        qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;
        for (int l = 0; l < 8; ++l) { //word_len
            char ch = substr[l];
                   // cout<<"ch "<<ch<<" "<<l<<endl;
            __m256i v_ch = _mm256_set1_epi8(ch);
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit;
            if (tmask == 0 && last_match_idx < l + 1) {
                /// cout<<"jump out of the loop "<<endl;
                break;
            }
            if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[trans_str_idx].last_match_idx = l + 1;
            tmask = tmask << 1;
            if (last_match_idx == l + 1) tmask = tmask | 1;
        }
        return tmask;
    }

    __attribute__((always_inline)) bool substrSearch_4(string* str, int num_str);
    __attribute__((always_inline)) bool substrSearch_2(string* str, int num_str);
    __attribute__((always_inline)) bool substrSearch(string* str, int num_str);

   // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, map<char, unsigned long>& bitset, unsigned long& carry);
//    MatchedBitmapInfo findMatchedBitmap(char* record, char* key, int st_idx, unordered_map<char, unsigned long>& bitset, unsigned long& carry);
    // MatchedBitmapInfo findMatchedBitmap(char* record, char* key, unsigned long& quotebit, unsigned long& colonbit, unsigned long& lbbit, unsigned long& carry);
 
  private:
     char* substring_200(char *pText, int begin, int end)
{
    int i,j;
    char * temp=pText;
    char* temp1=NULL;
    temp1=(char*)malloc((end-begin+1)*sizeof(char));
    for (j = 0,i = begin; i < end; i++,j++)
    {
        temp1[j]=temp[i];
    }
    temp1[j]='\0';
    return temp1;
}
    void freeMemory();
    // all following functions are used for evaluation comparison
    void buildStructuralCharacterBitmap();
    void buildStructuralQuoteBitmapMison();
    void buildStructuralQuoteBitmapPison();
    void buildStringMaskBitmapMison();
    void buildStringMaskBitmapPison();
    void updateStructuralCharacterBitmap();
    void buildLeveledBitmapMison();
    void buildLeveledBitmapPison();
    bool findFieldQuotePos(long colon_pos, long& start_pos, long& end_pos, unsigned long& quote_bit);
    // process key-pri pairs within an interval separated by two consecutive brackets
    void processKeyPriPairs(QueryAutomaton& qa, long& word_id, unsigned long& colon_brace_bit, long& last_colon_pos, string& output, long& output_size, unsigned long& quote_bit, unsigned long& last_quote_bit, unsigned long& end_value_bit, unsigned long& comma_brace_bit, bool& is_right_brace);
    void processKeyBracket(QueryAutomaton& qa, int type, long& last_colon_pos, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, unsigned long& last_quote_bit);
    void processOpenBracket(QueryAutomaton& qa, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn);
    void processCloseBracket(QueryAutomaton& qa, bool& skip_arr_ele);
    // process an array member
    void processArrayMember(QueryAutomaton& qa, long& last_comma_pos, bool& skip_arr_ele);
    // process a candidate array interval separated yb two consecutive brackets
    void processCandidateArrayInterval(QueryAutomaton& qa, long& word_id, unsigned long& commabit, long& last_comma_pos, bool& skip_arr_ele);
    void processNoKeyInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit);
    void processKeyNoBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, string& output, long& output_size);    
    // void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, bool& match_flag, string& output, long& output_size);
    void processKeyWithBracket(QueryAutomaton& qa, long& word_id, __m256i& v_first, __m256i& v_second, long& last_colon_pos, int& temp_state, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& lbracketbit, int type, bool& match_flag, bool& skip_arr_ele, bool& skip_unmatched_tkn, string& output, long& output_size);


/*__attribute__((always_inline)) void measureSubstrSearchCost(QueryAutomaton& qa, __m256i& v_first, __m256i& v_second, long& word_id, unsigned long& ini_mask) {
    
    if (qa.mCurState == UNMATCHED_STATE) return;
    int i = 0;
    int cur_idx = qa.mCurState - 1;
    int num_keys = qa.mDfa.trans_ele[cur_idx].num_keys;
 ///   cout<<"cur state "<<qa.mCurState<<" num_keys "<<num_keys<<endl;
    for (int idx = 0; idx < num_keys; ++idx) {
        i = idx;
        int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
        if (qa.getType(next_state) == OUTPUT_CANDIDATE) {
            // visit all candidtate substrings
            int num_predicates = qa.mMatchedStateInfo[next_state].num_predicates;
            /// cout<<"next state "<<next_state<<" num predicates "<<num_predicates<<endl;
            for (int j = 0; j < num_predicates; ++j) {
                char* predicate = qa.mMatchedStateInfo[next_state].predicates[j];
                int len_predicate = qa.mMatchedStateInfo[next_state].len_predicates[j];
                __m256i vec_predicate = qa.mMatchedStateInfo[next_state].vec_predicates[j];
                int matched_cnt = 0;
                long start = rdtsc();
                // perform substring searching based on the predicate length
                if (len_predicate == 2) {
                    // Method in Sparser
                    // check all candidates ++mMatchedStateInfo[next_state]->num_key_candidates[j]; 
                    ////// matched_bitmap = substrBitmapFromWord_2(vec_predicate, word_id, ini_mask);
                    matched_cnt = substrCnt_2RF(vec_predicate, word_id, ini_mask);
          //////          matched_cnt = substrCnt_2RF1(predicate, v_first, v_second, ini_mask, j);
                } else if (len_predicate == 4) {
                    // Method in Sparser
                 ///   matched_cnt = substrCnt_4RF(vec_predicate, word_id, ini_mask);
                    matched_cnt = substrCnt_4RF1(predicate, v_first, v_second, ini_mask, j);

                    ////// matched_bitmap = substrBitmapFromWord_4(vec_predicate, word_id, ini_mask); 
                } else {
                    // Proposed Method based on icgrep
                    // check all candidates ++mMatchedStateInfo[next_state]->num_key_candidates[j]; 
                    /// matched_bitmap = substrBitmapFromWord_8(predicate, v_first, v_second, ini_mask, idx);
                    matched_cnt = substrCnt_8RF(predicate, v_first, v_second, ini_mask, j);
                    /// if (matched_cnt > 0) cout<<"matched cnt "<<matched_cnt<<endl;
                }
                long end = rdtsc();
                qa.mMatchedStateInfo[next_state].costs[j] += (end - start);
                qa.mMatchedStateInfo[next_state].num_key_candidates[j] += matched_cnt;
               ////// if (matched_cnt > 0 && j == 30) cout<<"predicate "<<predicate<<" state "<<next_state<<" matched cnt "<<qa.mMatchedStateInfo[next_state].num_key_candidates[j]<<endl;
                //////if (strcmp(predicate, "hlyR") == 0)
                        //////cout<<"before find "<<predicate<<" len "<<len_predicate<<endl;
                // post processing 
                /*while (matched_bitmap) {
                    if (strcmp(predicate, "hlyR") == 0) 
                        cout<<"find "<<predicate<<" len "<<len_predicate<<endl;
                    ++qa.mMatchedStateInfo[next_state].num_key_candidates[j];
                    matched_bitmap = matched_bitmap & (matched_bitmap - 1);
                }*/
  /*          }
        }
    }
}*/


#ifdef FILTER5
__attribute__((always_inline)) void processNoBracketInterval(QueryAutomaton& qa,__m256i& v_first, __m256i& v_second, long& word_id, unsigned long& st_quotebit, unsigned long& ed_quotebit, unsigned long& colonbit, unsigned long& commabit, string& output, long& output_size, long& last_colon_pos, int& temp_state, unsigned long& ini_mask) {
        if (qa.mCurState == UNMATCHED_STATE) return;
        if (qa.mCurState > mIntervalState) {
            // mIntervalState = qa.mCurState;
            mMapIdx = mMapIdx + qa.mDfa.trans_ele[mIntervalState - 1].num_keys;
            mIntervalState = qa.mCurState; 
            //cout<<"map idx "<<mMapIdx<<" "<<mIntervalState<<" "<<qa.mDfa.trans_ele[mIntervalState - 1].num_keys<<endl;
        } else if (qa.mCurState < mIntervalState) {
            //mIntervalState = qa.mCurState;
            mMapIdx -= qa.mDfa.trans_ele[mIntervalState - 1].num_keys;
            mIntervalState = qa.mCurState;
            //cout<<"map idx smaller "<<mMapIdx<<endl;
        }
        if (last_colon_pos > -1 && commabit) {
            if (qa.getType(temp_state) == OUTPUT_CANDIDATE) {
                long end_pos = (word_id) * 64 + __builtin_ctzll(commabit);
                long text_length = end_pos - last_colon_pos - 1;
                //cout<<"text length "<<text_length<<endl;
                long temp_len = text_length;
                char* temp_start = mRecord + last_colon_pos + 1;
                char* ttext = mText;
                __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                ttext += 32;
                temp_len -= 32;
                temp_start += 32;
                if (unlikely(temp_len > 0)) {
                    while (temp_len > 0) {
                        __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(temp_start));
                        _mm256_storeu_si256(reinterpret_cast<__m256i *>(ttext), v);
                        ttext += 32;
                        temp_len -= 32;
                        temp_start += 32;
                    }
                } 
            //    memcpy(mText, mRecord + last_colon_pos + 1, text_length);
                mText[text_length] = '\0';
               // mText = mText + text_length + 1;
                output.append(mText);
            ///    cout<<mText<<endl;
             ///   ++output_size;
                #ifdef FILTER3
                mUnmatched = true;
                #endif
            }
            last_colon_pos = -1;
            if (qa.mDfa.trans_ele[qa.mCurState - 1].num_matched_keys == qa.mDfa.trans_ele[qa.mCurState - 1].num_keys) {
                ///cout<<"return "<<endl;
                return;
            }
        }
        int cur_idx = qa.mCurState - 1;
        int i = 0;
        int num_keys = 1;//qa.mDfa.trans_ele[cur_idx].num_keys;
  ///      if (qa.mCurState != 4) cout<<"exception state "<<qa.mCurState<<endl;
       /// cout<<"num keys "<<num_keys<<endl;
        for (int idx = 0; idx < num_keys; ++idx) {
        i = idx;//qa.mDfa.trans_ele[cur_idx].key_idx[idx];
        #ifdef FILTER3
        /*if (qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == false) {
            cout<<"unvisited state "<<qa.mCurState<<" "<<(qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == false)<<" "<<i<<endl;
        }*/
        /*if (qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == true) {
            qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
            continue;
           /// return;
        }*/
        #endif
        int next_state = qa.mDfa.trans_ele[cur_idx].t_str_info[i].next_state;
        char* key = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key;
        char* target_key = key;
        int key_len = qa.mDfa.trans_ele[cur_idx].t_str_info[i].key_len;
        int target_key_len = key_len;
        int last_match_idx = qa.mStateMaskInfo.state_masks[i].last_match_idx;
        qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
        unsigned long carry_mask = 1UL<<63;

        if (mPendMask == next_state) {
            /// cout<<"pend mask "<<endl;
            /// unsigned long matchbit = mPendMask & (-mPendMask);
            /// mPendMask = 0;
            unsigned long tempcolonbit = colonbit;// & (~(matchbit ^ (matchbit - 1)));
            tempcolonbit = tempcolonbit & (-tempcolonbit);
            if (tempcolonbit) {
                mPendMask = 0;
                // unsigned long matchstartquotebit = st_quotebit & (matchbit ^ (matchbit - 1));
                // long match_start_pos = word_id * 64 + __builtin_ctzll(matchstartquotebit);
                /// last_quote_bit = st_quotebit & (tempcolonbit ^ (tempcolonbit - 1));
                long cur_colon_pos = word_id * 64 + __builtin_ctzll(tempcolonbit);
                long st = -1, ed = -1;
                unsigned long tmpbit = 0;
                findFieldQuotePos(cur_colon_pos, st, ed, tmpbit);
                /// cout<<" pos "<<cur_colon_pos<<" "<<st<<" "<<ed<<endl;
                if ((ed - st - 1 == target_key_len) && memcmp(mRecord + st + 1, target_key, target_key_len) == 0) {
                    ++output_size;
                    unsigned long match_mask = tempcolonbit ^ (tempcolonbit - 1);
                    unsigned long tempbit = commabit & (~match_mask);
                    if (tempbit) {
                        long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                        long text_length = end_pos - cur_colon_pos - 1;
                        memcpy(mText, mRecord + cur_colon_pos + 1, text_length);
                        mText[text_length] = '\0';
                        ///cout<<mText<<" "<<text_length<<endl;
                        output.append(mText);
                       /// ++output_size;
                    } else {
                        /// long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                        last_colon_pos = cur_colon_pos;
                        temp_state = next_state;
                    }
                    #ifdef FILTER3
                   // qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited = true;
                   // ++qa.mDfa.trans_ele[cur_idx].num_matched_keys;
                    #endif
                    continue;
                }
                /// cout<<substring_200(mRecord, st + 1, ed)<<endl;
            } 
        }
        // start quote
       /* unsigned long tmask = st_quotebit;
        if (tmask == 0 && last_match_idx < 0) {
            //return;
            continue;
        }
        //if (last_match_idx > -1)
        //++output_size;
        if (tmask & carry_mask)
            qa.mStateMaskInfo.state_masks[i].last_match_idx = 0;
        tmask = tmask << 1;
        if (last_match_idx == 0) tmask = tmask | 1;*/
      /*  if (i == 0) {
        //if (qa.mCurState == 3) {
            key = "id";
            key_len = 2;
        } else { //if (qa.mCurState == 6) {
            key = "la";
            key_len = 2;
       }*/
        int map_idx = mMapIdx;//map[cur_idx * 10 + i];//qa.mDfa.trans_ele[cur_idx].t_str_info[i].map_idx;
       /// cout<<"map idx "<<mMapIdx<<endl;
        key = qa.bestInfo[map_idx].best_subkey; //qa.mDfa.trans_ele[cur_idx].t_str_info[i].best_subkey;
        key_len = qa.bestInfo[map_idx].best_subkey_len; //qa.mDfa.trans_ele[cur_idx].t_str_info[i].best_subkey_len;
        __m256i v_target = qa.bestInfo[map_idx].best_subkey_vec;
        unsigned long tmask = 0xffffffffffffffff & ini_mask;
        // check key field
    /*    unsigned long k = word_id * 64;
        int cnt = 0;
        __m256i v_text = v_first;//_mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
        unsigned long matchbit1 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
     ///   cnt += __builtin_popcountll(matchbit1) / 4;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
        unsigned long matchbit2 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
     ///   cnt += __builtin_popcountll(matchbit2) / 4;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 2));
        unsigned long matchbit3 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit3) / 4;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 3));
        unsigned long matchbit4 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
       ///cnt += __builtin_popcountll(matchbit4) / 4;
        k += 32;
        v_text = v_second; //_mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k));
        unsigned long matchbit11 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit11) / 4;
        v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 1));
        unsigned long matchbit22 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit22) / 4;
         v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 2));
        unsigned long matchbit33 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit33) / 4;
         v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + k + 3));
        unsigned long matchbit44 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi32(v_text, v_target));
        ///cnt += __builtin_popcountll(matchbit44) / 4;
        matchbit1 = (matchbit11 << 32) | matchbit1;
        matchbit2 = (matchbit22 << 32) | matchbit2;
        matchbit3 = (matchbit33 << 32) | matchbit3;
        matchbit4 = (matchbit44 << 32) | matchbit4;
        matchbit1 = matchbit1 & 0x1111111111111111;
        matchbit2 = matchbit2 & 0x1111111111111111;
        matchbit3 = matchbit3 & 0x1111111111111111;
        matchbit4 = matchbit4 & 0x1111111111111111;
        matchbit1 = matchbit1 & ini_mask;
        matchbit2 = (matchbit2 << 1) & (ini_mask);
        matchbit3 = (matchbit3 << 2) & (ini_mask);
        matchbit4 = (matchbit4 << 3) & (ini_mask);
         
        tmask = matchbit1 | matchbit2 | matchbit3 | matchbit4; */
    /*   matchbit1 = matchbit1 & 0x5555555555555555;
        matchbit2 = matchbit2 & 0x5555555555555555;
        matchbit1 = matchbit1 & ini_mask;
        matchbit2 = (matchbit2 << 1) & (ini_mask);
       tmask = matchbit1 | matchbit2;
 */     /*  matchbit3 = (matchbit3 << 2) & (ini_mask);
        matchbit4 = (matchbit4 << 3) & (ini_mask);
      */ /* tmask = matchbit1;// | matchbit2 | matchbit3 | matchbit4;
        if (matchbit2) tmask = tmask | matchbit2;
      /*  if (matchbit3) tmask = tmask | matchbit3;
        if (matchbit4) tmask = tmask | matchbit4;
      */  /*if (tmask) {
            bitset<64> tmpmask(tmask);
            cout<<"tmpmask "<<tmpmask<<endl;
        }*/
        int j = 0;
        for (j = 0; j < key_len; ++j) {
            char ch = key[j];
            __m256i v_ch = _mm256_set1_epi8(ch);
            unsigned long chbit0, chbit;
            chbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_first, v_ch));
            chbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_second, v_ch));
            chbit = (chbit << 32) | chbit0;
            tmask = tmask & chbit;
            if (tmask == 0 && last_match_idx < j + 1) {
                //cout<<"unmatched "<<ch<<endl;
                ///return;
                break;
            }
            if (j == key_len - 1) break;
            if (tmask & carry_mask)
                 qa.mStateMaskInfo.state_masks[i].last_match_idx = j + 1;
            tmask = tmask << 1;
            if (last_match_idx == j + 1) tmask = tmask | 1;
        }
      ///  if (j < key_len - 1) continue;
        unsigned long tempcolonbit = colonbit;// & (~(matchbit ^ (matchbit - 1)));
        unsigned long last_quote_bit;// = quote_bit & (colon_brace_bit ^ (colon_brace_bit - 1));
        unsigned long pendcolonbit;     

        while (tmask) {
            unsigned long matchbit = tmask & (-tmask);
            tempcolonbit = colonbit & (~(matchbit ^ (matchbit - 1)));
            tempcolonbit = tempcolonbit & (-tempcolonbit);
            if (tempcolonbit) {
                // unsigned long matchstartquotebit = st_quotebit & (matchbit ^ (matchbit - 1));
                // long match_start_pos = word_id * 64 + __builtin_ctzll(matchstartquotebit);
                last_quote_bit = st_quotebit & (tempcolonbit ^ (tempcolonbit - 1));
                long cur_colon_pos = word_id * 64 + __builtin_ctzll(tempcolonbit);
                long st = -1, ed = -1;
                findFieldQuotePos(cur_colon_pos, st, ed, last_quote_bit);
                if ((ed - st - 1 == target_key_len) && memcmp(mRecord + st + 1, target_key, target_key_len) == 0) {
                    /*if (qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited == true) {
                        cout<<"repetitive "<<target_key<<endl;
                    }*/
                    ++output_size;
                    unsigned long match_mask = tempcolonbit ^ (tempcolonbit - 1);
                    unsigned long tempbit = commabit & (~match_mask);
                    if (tempbit) {
                        long end_pos = (word_id) * 64 + __builtin_ctzll(tempbit);
                        long text_length = end_pos - cur_colon_pos - 1; 
                        memcpy(mText, mRecord + cur_colon_pos + 1, text_length);
                        mText[text_length] = '\0';
                        ///cout<<mText<<" "<<text_length<<endl;
                        output.append(mText);
                        #ifdef FILTER3
                        mUnmatched = true;
                        #endif
                    ///   ++output_size;
                    } else {
                        /// long offset = (word_id) * 64 + __builtin_ctzll(temp_mask);
                        last_colon_pos = cur_colon_pos;
                        temp_state = next_state; 
                    }
                    #ifdef FILTER3
                  ///  qa.mDfa.trans_ele[cur_idx].t_str_info[i].visited = true;
                 ///   ++qa.mDfa.trans_ele[cur_idx].num_matched_keys;
                    #endif
                    break;
                }
            } /*else {
                cout<<"no colon for the current match "<<endl;
                mPendMask = tmask;
            }*/
            tmask = tmask & (tmask - 1);
            if (!tempcolonbit && !tmask) {
             ///   cout<<" last one no colon for the current match "<<endl;
                mPendMask = next_state;
            }
        }

        }
        //qa.mStateMaskInfo.state_masks[i].last_match_idx = -1;
    }
#endif

};
#endif
