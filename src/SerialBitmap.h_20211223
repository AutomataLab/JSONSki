#ifndef SERIALBITMAP_H
#define SERIALBITMAP_H
#include <string>
#include <iostream>
#include <vector>
#include <bitset>
#include <cassert>
#include <stack>
#include <algorithm>
#include <unordered_map>
#include <functional>
#include <math.h>
#include <immintrin.h>
#include "Bitmap.h"
#include <unordered_map>
#include <map>
#include "QueryAutomaton.h"
using namespace std;

#define SUCCESS 1001
#define ARRAY_END 1002
#define OBJECT_END 1003
#define RANGE_END 1004
#define PARTIAL_SKIP 1005

#ifndef unlikely
#define unlikely(x) __builtin_expect(!!(x), 0)
#endif

#define MAX_STACK_DEPTH 20
typedef struct StackElement{
    unsigned long position;
    unsigned long bits;
}StackElement;

typedef struct MatchedBitmapInfo {
    unsigned long bitmap;
    unsigned long carry;
    unsigned long last_index;
};

typedef struct bitmap{
    unsigned long colonbit = 0;
    unsigned long commabit = 0;
    unsigned long lbracebit = 0;
    unsigned long rbracebit = 0;
    unsigned long lbracketbit = 0;
    unsigned long rbracketbit = 0;
    // unsigned long combinedbit = 0;
    //bool has_basic = false;
    bool has_colon = false;
    bool has_comma = false;
    bool has_lbrace = false;
    bool has_rbrace = false;
    bool has_lbracket = false;
    bool has_rbracket = false;
    // bool has_combined = false;
} bitmap;

typedef struct IntervalInfo {
    unsigned long intervalbit = 0;
    bool is_complete = true;
} IntervalInfo;

struct JumpInfo {
    int status;
    int num_comma;
    JumpInfo(int s, int n = 0) {
        status = s;
        num_comma = n;
    }
};

class SerialBitmap : public Bitmap {
    friend class SerialBitmapIterator;
  private:
    long skipper1 = 0, skipper2 = 0, skipper3 = 0, skipper4 = 0, skipper5 = 0;
    bool tflag=false;
    unsigned long str_mask;
    unsigned long escapebit, stringbit, lbracebit, rbracebit, lbracketbit, rbracketbit; 
   unsigned long bracketbit0, colonbit0, quotebit0, escapebit0, stringbit0, lbracebit0, rbracebit0, commabit0, lbracketbit0, rbracketbit0;
    long start_id = 0;
    __m256i v_text0, v_text;
    int64_t quote_bits; unsigned long st_quotebit; unsigned long ed_quotebit; unsigned long cb_bit;
    __m256i struct_mask;// = _mm256_set1_epi8(0x20);
    __m256i structural_table, v_quote, v_colon, v_escape, v_lbrace, v_rbrace, v_comma, v_lbracket, v_rbracket;
    uint64_t prev_iter_ends_odd_backslash = 0ULL;
    uint64_t prev_iter_inside_quote = 0ULL;
    const uint64_t even_bits = 0x5555555555555555ULL;
    const uint64_t odd_bits = ~even_bits;
    int temp_cnt = 0;
    unsigned long first, second;
    long top_word = -1;
    long pend_wid = -1;
    long pend_wid1 = -1;
    unsigned long cb_mask = 0;
    unsigned long colonbit = 0;
    unsigned long quotebit = 0;
    unsigned long commabit = 0;
    unsigned long bracketbit = 0;
    bool cur_word = false;
    long cur_pos = 0;
    unsigned long mask = 0;
    unsigned long colon_mask = 0;
    unsigned long comma_mask = 0;
    //long word_id = 0;

    char* mRecord;
    // for a single large record, stream length equals to record length
    long mRecordLength;
    // each temp word has 32 bytes
    long mNumTmpWords;
    // each word has 64 bytes
    long mNumWords;
    // the deepest level of leveled bitmap indexes
    int mDepth;
    // whether to create leveled comma bitmaps
    bool mArraySupported;
    char mKey[1000];
    long mTempState;
    char* mText;
    bool mUnmatched = false;
    unsigned long mColonBit = 0;
    long mWordId;
    bool mSmallRec = false;
    QueryAutomaton qa;
    bool mStop = false;

    int cur_type = 0;
  public:
    int mPassed = 0;
    long mOutputSize;
    string mOutput;
    
  public:
    SerialBitmap();
    SerialBitmap(char* record, int depth, bool array_supported = true);
    ~SerialBitmap();
    void object(long& pos, bitmap& bm);
    void array(long& pos, bitmap& bm);
    void array_range(long& pos, bitmap& bm);
    __attribute__((always_inline)) void skipObject(long& pos, bitmap& bm);
    __attribute__((always_inline)) void skipArray(long& pos, bitmap& bm);
    __attribute__((always_inline)) void skipPrimitiveObj(long& pos, bitmap& bm);
    __attribute__((always_inline)) int skipPrimitiveAry(long& pos, bitmap& bm); 
    __attribute__((always_inline)) void skipFollowingAttributes(long& pos, bitmap& bm);
    __attribute__((always_inline)) void skipFollowingElements(long& pos, bitmap& bm);
    __attribute__((always_inline)) int skipElements(long& pos, int num_elements, bitmap& bm);
    __attribute__((always_inline)) JumpInfo skipPrimElemInRange(long& pos, int num_elements, bitmap& bm);
    __attribute__((always_inline)) JumpInfo skipPrimElemInRangeEPos(long& pos, int num_elements, bitmap& bm);
    __attribute__((always_inline)) int goToObjElemInRange(long& pos, int& num_elements, bitmap& bm);
    __attribute__((always_inline)) int goToAryElemInRange(long& pos, int& num_elements, bitmap& bm);
    __attribute__((always_inline)) int goToPrimElemInRange(long& pos, int& num_elements, bitmap& bm);
    __attribute__((always_inline)) int goToObjAttr1(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToObjAttr(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToAryAttr(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToAryAttr1(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToAryAttr2(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToPrimAttr(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToObjElem(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToAryElem(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToPrimElem(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToObjElem1(long& pos, bitmap& bm);
    __attribute__((always_inline)) int goToAryElem2(long& pos, bitmap& bm);
    __attribute__((always_inline)) int skipPrimPairs(long& pos, bitmap& bm);
    __attribute__((always_inline)) int skipPrimElements(long& pos, bitmap& bm); 
    __attribute__((always_inline)) bool hasMoreElements(long& pos);
    __attribute__((always_inline)) int getElementType(long& pos);
    __attribute__((always_inline)) bool hasMoreAttributes(long& pos);
    __attribute__((always_inline)) int getAttributeType(long& pos); 
    __attribute__((always_inline)) void resetBitmap(bitmap& bm) {
        bm.has_colon = false;
        bm.has_comma = false;
        bm.has_lbrace = false;
        bm.has_rbrace = false;
        bm.has_lbracket = false;
        bm.has_rbracket = false;
        // bm.has_combined = false;
    }
    


   // first three steps of structral index construction, get string mask bitmap
    __attribute__((always_inline)) void build_bitmap_basic(); 
    __attribute__((always_inline)) void build_bitmap_colon(bitmap& bm);
    __attribute__((always_inline)) void build_bitmap_comma(bitmap& bm);
    __attribute__((always_inline)) void build_bitmap_lbrace(bitmap& bm);
    __attribute__((always_inline)) void build_bitmap_rbrace(bitmap& bm);
    __attribute__((always_inline)) void build_bitmap_lbracket(bitmap& bm);
    __attribute__((always_inline)) void build_bitmap_rbracket(bitmap& bm);
    // __attribute__((always_inline)) void build_combined_bitmap(bitmap& bm);
    __attribute__((always_inline)) void get_bitmap_colon(bitmap& bm);
    __attribute__((always_inline)) void get_bitmap_comma(bitmap& bm);
    __attribute__((always_inline)) void get_bitmap_lbrace(bitmap& bm);
    __attribute__((always_inline)) void get_bitmap_rbrace(bitmap& bm);
    __attribute__((always_inline)) void get_bitmap_lbracket(bitmap& bm);
    __attribute__((always_inline)) void get_bitmap_rbracket(bitmap& bm);
    //__attribute__((always_inline)) void get_combined_bitmap(bitmap& bm); 

    __attribute__((always_inline)) IntervalInfo get_interval_new_word(unsigned long& bitmap);
    __attribute__((always_inline)) IntervalInfo get_interval(long& pos, unsigned long& bitmap);
    __attribute__((always_inline)) IntervalInfo next_interval(unsigned long& bitmap);
    __attribute__((always_inline)) long get_position(unsigned long& bitmap, int number); 
    __attribute__((always_inline)) long interval_end(unsigned long& interval);

    __attribute__((always_inline)) void get_interval_brace(long& pos, bitmap& bm, IntervalInfo& itv_info);
    __attribute__((always_inline)) void next_interval_brace(bitmap& bm, IntervalInfo& itv_info);
    __attribute__((always_inline)) void get_interval_bracket(long& pos, bitmap& bm, IntervalInfo& itv_info);
    __attribute__((always_inline)) void next_interval_bracket(bitmap& bm, IntervalInfo& itv_info); 
    __attribute__((always_inline)) long get_position_brace(bitmap& bm, int number);
    __attribute__((always_inline)) long get_position_bracket(bitmap& bm, int number);

    __attribute__((always_inline)) void next_interval(char ch);
    // oNOTE: optional function, can call SIMD instruction directly
    __attribute__((always_inline)) int count(unsigned long& interval, unsigned long& bitmap);
    __attribute__((always_inline)) long object_end(unsigned long& interval, unsigned long& bitmap);
    //__attribute__((always_inline)) long interval_end(unsigned long& interval);

    // manually create an automaton
    void generateAutomaton(QueryAutomaton& qa);
    void indexConstruction();
    void indexConstruction1();
    // mainly used for small records processing
    void smallRecordInitialize();
    void setData(char* record, int depth);
    void setRecord(char* record);
    void setRecordLength(long length);
    void setQuoteBitmap(unsigned long* quote_bitmap);
 
  private:
     char* substring_200(char *pText, long begin, long end)
{
    long i,j;
    char * temp=pText;
    char* temp1=NULL;
    temp1=(char*)malloc((end-begin+1)*sizeof(char));
    for (j = 0,i = begin; i < end; i++,j++)
    {
        temp1[j]=temp[i];
    }
    temp1[j]='\0';
    return temp1;
}
    void freeMemory();
};
#endif
