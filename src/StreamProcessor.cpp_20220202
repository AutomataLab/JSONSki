#include "StreamProcessor.h"
#include <immintrin.h>

#include <emmintrin.h>
#include <string.h>

#include <sys/time.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <pthread.h>
#include <malloc.h>
#include <sys/time.h>
#include <sys/file.h>
#include <unistd.h>
#include <sched.h>
#include <unordered_map>

using namespace std;

StreamProcessor::StreamProcessor(QueryAutomaton& qa) {
    this->qa = qa;
    this->mOutput.clear();
    this->mOutputSize = 0;
    this->mText = new char[MAX_TEXT_LENGTH];
    init(); 
}

StreamProcessor::StreamProcessor(char* record, long record_length, QueryAutomaton& qa) {
    this->setRecord(record, record_length);
    this->qa = qa;
    this->mOutput.clear();
    this->mOutputSize = 0;
    this->mText = new char[MAX_TEXT_LENGTH];
    init();
}

void StreamProcessor::init() {
    structural_table =
        _mm256_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '{', 0, '}', 0, 0,
                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '{', 0, '}', 0, 0);
    struct_mask = _mm256_set1_epi8(0x20);
    // vectors for structural characters
    v_quote = _mm256_set1_epi8(0x22);
    v_colon = _mm256_set1_epi8(0x3a);
    v_escape = _mm256_set1_epi8(0x5c);
    v_lbrace = _mm256_set1_epi8(0x7b);
    v_rbrace = _mm256_set1_epi8(0x7d);
    v_comma = _mm256_set1_epi8(0x2c);
    v_lbracket = _mm256_set1_epi8(0x5b);
    v_rbracket = _mm256_set1_epi8(0x5d);
    // some global variables among internal functions
    top_word = -1;
    prev_iter_ends_odd_backslash = 0ULL;
    prev_iter_inside_quote = 0ULL;
    even_bits = 0x5555555555555555ULL;
    odd_bits = ~even_bits;
    start_id = 0;
    cb_mask = 0, colon_mask = 0, comma_mask = 0; mask = 0;
    colonbit = 0; quotebit = 0; commabit = 0; bracketbit = 0;
    cur_word = false;
    top_word = -1;
    cur_pos = 0; 
}

StreamProcessor::~StreamProcessor()
{
    if (mText) {
        free(mText);
        mText = NULL;
    }
}

void StreamProcessor::setRecord(char* record, long length) {
    this->mRecord = record;
    this->mRecordLength = length;
    this->mNumTmpWords = length / 32;
    this->mNumWords = length / 64; 
}

// build quote bitmap and string mask bitmap for the current word
__attribute__((always_inline)) void StreamProcessor::build_bitmap_basic() {
    unsigned long quotebit0, escapebit0;
    unsigned long quotebit, escapebit;
    // step 1: build structural quote and escape bitmaps for the current word
    // first half of bitmap
    top_word = start_id / 2; // word id 
    unsigned long i = start_id * 32;
    v_text0 = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
    quotebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_quote));
    escapebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_escape));
    // second half of bitmap 
    ++start_id;
    i = (start_id) * 32;
    v_text = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(mRecord + i));
    quotebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_quote));
    escapebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_escape));
    quotebit = (quotebit << 32) | quotebit0;
    escapebit = (escapebit << 32) | escapebit0;
    // step 2: update structural quote bitmaps
    uint64_t bs_bits = escapebit;
    uint64_t start_edges = bs_bits & ~(bs_bits << 1);
    int64_t even_start_mask = even_bits ^ prev_iter_ends_odd_backslash;
    uint64_t even_starts = start_edges & even_start_mask;
    uint64_t odd_starts = start_edges & ~even_start_mask;
    uint64_t even_carries = bs_bits + even_starts;
    int64_t odd_carries;
    bool iter_ends_odd_backslash = __builtin_uaddll_overflow(bs_bits, odd_starts,
        (unsigned long long *)(&odd_carries));
    odd_carries |= prev_iter_ends_odd_backslash;
    prev_iter_ends_odd_backslash = iter_ends_odd_backslash ? 0x1ULL : 0x0ULL;
    uint64_t even_carry_ends = even_carries & ~bs_bits;
    uint64_t odd_carry_ends = odd_carries & ~bs_bits;
    uint64_t even_start_odd_end = even_carry_ends & odd_bits;
    uint64_t odd_start_even_end = odd_carry_ends & even_bits;
    uint64_t odd_ends = even_start_odd_end | odd_start_even_end;
    quote_bits = quotebit & ~odd_ends;
     // step 3: build string mask bitmaps
    str_mask = _mm_cvtsi128_si64(_mm_clmulepi64_si128(
        _mm_set_epi64x(0ULL, quote_bits), _mm_set1_epi8(0xFFu), 0));
    str_mask ^= prev_iter_inside_quote;
    prev_iter_inside_quote = static_cast<uint64_t>(static_cast<int64_t>(str_mask) >> 63);
}

__attribute__((always_inline)) void StreamProcessor::build_bitmap_colon(bitmap& bm) {
    unsigned long colonbit0, colonbit;
    colonbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_colon));
    colonbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_colon));
    bm.colonbit = (colonbit << 32) | colonbit0;
    bm.colonbit = bm.colonbit & (~str_mask);
}

__attribute__((always_inline)) void StreamProcessor::get_bitmap_colon(bitmap& bm) {
    if (bm.has_colon == false) {
        build_bitmap_colon(bm);
        bm.has_colon = true;
    }
}

__attribute__((always_inline)) void StreamProcessor::build_bitmap_comma(bitmap& bm) {
    unsigned long commabit0, commabit;
    commabit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_comma));
    commabit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_comma));
    bm.commabit = (commabit << 32) | commabit0;
    bm.commabit = bm.commabit & (~str_mask);
}

__attribute__((always_inline)) void StreamProcessor::get_bitmap_comma(bitmap& bm) {
    if (bm.has_comma == false) {
        build_bitmap_comma(bm);
        bm.has_comma = true;
    }
}

__attribute__((always_inline)) void StreamProcessor::build_bitmap_lbrace(bitmap& bm) {
    unsigned long lbracebit0, lbracebit;
    lbracebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_lbrace));
    lbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbrace));
    bm.lbracebit = (lbracebit << 32) | lbracebit0;
    bm.lbracebit = bm.lbracebit & (~str_mask);
}

__attribute__((always_inline)) void StreamProcessor::get_bitmap_lbrace(bitmap& bm) {
    if (bm.has_lbrace == false) {
        build_bitmap_lbrace(bm);
        bm.has_lbrace = true;
    }
}

__attribute__((always_inline)) void StreamProcessor::build_bitmap_rbrace(bitmap& bm) {
    unsigned long rbracebit0, rbracebit;
    rbracebit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_rbrace));
    rbracebit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbrace));
    bm.rbracebit = (rbracebit << 32) | rbracebit0;
    bm.rbracebit = bm.rbracebit & (~str_mask);
}

__attribute__((always_inline)) void StreamProcessor::get_bitmap_rbrace(bitmap& bm) {
    if (bm.has_rbrace == false) {
        build_bitmap_rbrace(bm);
        bm.has_rbrace = true;
    }
}

__attribute__((always_inline)) void StreamProcessor::build_bitmap_lbracket(bitmap& bm) {
    unsigned long lbracketbit0, lbracketbit;
    lbracketbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_lbracket));
    lbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_lbracket));
    bm.lbracketbit = (lbracketbit << 32) | lbracketbit0;
    bm.lbracketbit = bm.lbracketbit & (~str_mask);
}

__attribute__((always_inline)) void StreamProcessor::get_bitmap_lbracket(bitmap& bm) {
    if (bm.has_lbracket == false) {
        build_bitmap_lbracket(bm);
        bm.has_lbracket = true;
    }
}

__attribute__((always_inline)) void StreamProcessor::build_bitmap_rbracket(bitmap& bm) {
    unsigned long rbracketbit0, rbracketbit;
    rbracketbit0 = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text0, v_rbracket));
    rbracketbit = (unsigned)_mm256_movemask_epi8(_mm256_cmpeq_epi8(v_text, v_rbracket));
    bm.rbracketbit = (rbracketbit << 32) | rbracketbit0;
    bm.rbracketbit = bm.rbracketbit & (~str_mask);
}

__attribute__((always_inline)) void StreamProcessor::get_bitmap_rbracket(bitmap& bm) {
    if (bm.has_rbracket == false) {
        build_bitmap_rbracket(bm);
        bm.has_rbracket = true;
    }
}

__attribute__((always_inline)) IntervalInfo StreamProcessor::get_interval(long& pos, unsigned long& bitmap) {
    IntervalInfo itv_info;
    int relative_pos = pos % 64;
    unsigned long w_start = (1UL << relative_pos);
    unsigned long mask_start = w_start ^ (w_start - 1);
    bitmap = bitmap & (~mask_start);
    if (bitmap) {
        unsigned long w_end = bitmap & (-bitmap);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval & (~mask_start);
        itv_info.is_complete = true;
    } else {
        // include the last character inside the word (incomplete interval)
        unsigned long w_end = (1UL << 63);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval & (~mask_start);
        itv_info.is_complete = false;
    }
    return itv_info;
}

__attribute__((always_inline)) IntervalInfo StreamProcessor::get_interval_new_word(unsigned long& bitmap) {
    IntervalInfo itv_info;
    unsigned long w_start = 1;
    if (bitmap) {
        unsigned long w_end = bitmap & (-bitmap);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = true;
    } else {
        // include the last character inside the word (incomplete interval)
        unsigned long w_end = (1UL << 63);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = false;
    }
    return itv_info;
}

__attribute__((always_inline)) IntervalInfo StreamProcessor::next_interval(unsigned long& bitmap) {
    IntervalInfo itv_info;
    unsigned long w_start = bitmap & (-bitmap);
    bitmap = bitmap & (bitmap - 1);
    if (bitmap) {
        unsigned long w_end = bitmap & (-bitmap);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = true;
    } else {
        // include the last character inside the word (incomplete interval)
        unsigned long w_end = (1UL << 63);
        unsigned long w_interval = (w_end - w_start) | w_end;
        itv_info.intervalbit = w_interval;
        itv_info.is_complete = false;
    }
    return itv_info;
}

__attribute__((always_inline)) long StreamProcessor::get_position(unsigned long& bitmap, int number) {
    while (number > 1) {
        bitmap = bitmap & (bitmap - 1);
        --number;
    }
    unsigned long pos = top_word * 64 + __builtin_ctzll(bitmap);
    return pos;
}

__attribute__((always_inline)) int StreamProcessor::count(unsigned long& interval, unsigned long& bitmap) {
    return __builtin_popcountl(bitmap & interval); 
}

__attribute__((always_inline)) long StreamProcessor::object_end(unsigned long& interval, unsigned long& bitmap) {
    return top_word * 64 + 64 - __builtin_clzll(bitmap & interval);
}

__attribute__((always_inline)) long StreamProcessor::interval_end(unsigned long& interval) {
    return top_word * 64 + 63 - __builtin_clzll(interval);
}

__attribute__((always_inline)) void StreamProcessor::goOverObj(long& pos, bitmap& bm) {
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            } 
            get_bitmap_lbrace(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    interval = get_interval_new_word(bm.lbracebit);
                } else {
                    interval = get_interval(pos, bm.lbracebit);
                }
                first_interval = true;
            } else {
                interval = next_interval(bm.lbracebit);
            }
            get_bitmap_rbrace(bm);
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            num_close = __builtin_popcountl(bitmap_rbrace);
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbrace, num_open);
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) void StreamProcessor::goOverAry(long& pos, bitmap& bm) {
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_lbracket(bm);
        ///     bitset<64> tempbit4(bm.lbracketbit);
        ///     cout<<"left bit0 "<<tempbit4<<endl;
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    // interval.intervalbit = 0;
                    // interval.is_complete = true;
                    interval = get_interval_new_word(bm.lbracketbit);
                    //bitset<64> tempbit(interval.intervalbit);
                    //cout<<"interval "<<tempbit<<" "<<interval.is_complete<<" "<<substring_200(mRecord, word_id * 64, word_id * 64 + 64)<<endl;
                } else {
                interval = get_interval(pos, bm.lbracketbit);
                    // first_interval = true;
                } 
                first_interval = true;
            } else { //if (new_word == false) {
                interval = next_interval(bm.lbracketbit);
            } /*else {
                interval = get_interval_new_word(bm.lbracketbit);
                new_word = false; 
            }*/
           /* bitset<64> tempbit3(bm.lbracketbit);
            cout<<"left bit "<<tempbit3<<endl;
            bitset<64> tempbit(interval.intervalbit);
            cout<<"interval "<<tempbit<<" "<<interval.is_complete<<" "<<substring_200(mRecord, word_id * 64, word_id * 64 + 64)<<endl;
          */get_bitmap_rbracket(bm);
            unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
            bitset<64> tempbit1(bm.rbracketbit);
          ///  cout<<"right bit "<<tempbit1<<endl;
            num_close = __builtin_popcountl(bitmap_rbracket);
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbracket, num_open);  //bm.rbracebit
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            // ++start_id;
            first_interval = false;
            //relevant_pos = 0;
            new_word = true;
            ///cout<<"new word "<<word_id<<" "<<num_open<<" "<<num_close<<" "<<mNumWords<<endl;
        }
    }
}

__attribute__((always_inline)) void StreamProcessor::goToObjEnd(long& pos, bitmap& bm) {
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            } 
            get_bitmap_lbrace(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    interval = get_interval_new_word(bm.lbracebit);
                } else {
                    interval = get_interval(pos, bm.lbracebit);
                }
                first_interval = true;
            } else {
                interval = next_interval(bm.lbracebit);
            }
            get_bitmap_rbrace(bm);
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            num_close = __builtin_popcountl(bitmap_rbrace);
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbrace, num_open);
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) void StreamProcessor::goToAryEnd(long& pos, bitmap& bm) {
    int num_open = 1;
    int num_close = 0;
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_lbracket(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    interval = get_interval_new_word(bm.lbracketbit);
                } else {
                    interval = get_interval(pos, bm.lbracketbit);
                }
                first_interval = true;
            } else {
                interval = next_interval(bm.lbracketbit);
            }
            get_bitmap_rbracket(bm);
            unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
            num_close = __builtin_popcountl(bitmap_rbracket);
            if (num_close < num_open) {
                if (interval.is_complete == true) {
                    num_open = num_open - num_close + 1;
                    break;
                } else {
                    num_open = num_open - num_close;
                }
            } else {  // results found
                pos = get_position(bitmap_rbracket, num_open);
                return;
            }
            // interval is incomplete in the current word
            ++word_id;
            first_interval = false;
            new_word = true;
        }
    }
}

__attribute__((always_inline)) void StreamProcessor::goOverPriAttr(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    bool first_interval = false;
    /// int relevant_pos = pos % 64;
    bool new_word = false;
    // cout<<"*** word id "<<word_id<<" "<<start_id<<endl;
    // in general case it can only pass one word
    /*if (start_id > 0 && start_id != 2 * word_id + 1) {
        cout<<"*** special word id "<<word_id<<" "<<start_id<<endl; 
        ++start_id;
    }*/
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            /// if (start_id == 31722552) cout<<"word id build primitive "<<word_id<<" "<<top_word<<endl;
            build_bitmap_basic();
            // if (word_id == 15861276) cout<<"lbrace flag "<<bm.has_lbrace<<endl;
        }
        get_bitmap_comma(bm);
        IntervalInfo interval;
        if (first_interval == false) {
            if (new_word == true) {
                interval = get_interval_new_word(bm.commabit);
            } else {
            ///    bitset<64> tempbit1(bm.commabit);
             ///   cout<<"prior tempbit "<<tempbit1<<" "<<substring_200(mRecord, word_id * 64, word_id * 64 + 10)<<endl;
                interval = get_interval(pos, bm.commabit);
           ///     bitset<64> tempbit(bm.commabit);
           ///     cout<<"intialization "<<pos<<" "<<relevant_pos<<" "<<mRecord[pos]<<" "<<tempbit<<" "<<substring_200(mRecord, pos - relevant_pos, pos-relevant_pos + 10)<<endl;
           ///     unsigned long test1 = (1UL << (pos % 64));
            ///    bitset<64> tempbit2(test1);
            ///    cout<<"intialization1 "<<tempbit2<<endl;
            }
            first_interval = true;
        } else {
            interval = next_interval(bm.commabit);
        }
        get_bitmap_rbrace(bm);
        unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
        if (bitmap_rbrace) {
            // end of object
            pos = get_position(bitmap_rbrace, 1) - 1;
            return;
        }
        if (interval.is_complete) {
            // position before comma
            ///if (interval.intervalbit == 0) 
                ///interval.intervalbit = 0UL;
            pos = interval_end(interval.intervalbit) - 1;
            /// if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
            /// pos = pos - 1;
            /// bitset<64> tempbit(interval.intervalbit);
            /// unsigned long test = interval.intervalbit;
         //////   if (word_id == 15861276) cout<<"*** lbrace flag "<<bm.has_lbrace<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            ///cout<<"word id "<<top_word<<" offset "<<__builtin_clzll(test)<<endl;
            /// cout<<"successfully skip an object primitive "<<" "<<(interval.intervalbit == 0)<<" "<<__builtin_clzll(test)<<" "<<word_id<<" "<<pos<<" "<<relevant_pos<<" "<<mRecord[pos]<<" "<<substring_200(mRecord, pos - 5, pos + 1)<<" "<<tempbit<<" "<<endl;
            return;
        } 
        // interval is incomplete in the current word
        ++word_id;
        // ++start_id;
        first_interval = false;
        //relevant_pos = 0;
        new_word = true;
    }  
}

__attribute__((always_inline)) int StreamProcessor::goOverPriElem(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    bool first_interval = false;
    // int relevant_pos = pos % 64;
    bool new_word = false;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_comma(bm);
        IntervalInfo interval;
        if (first_interval == false) {
            if (new_word == true) {
                interval = get_interval_new_word(bm.commabit);
            } else {
                interval = get_interval(pos, bm.commabit);
            }
            first_interval = true;
        } else {
            interval = next_interval(bm.commabit);
        }
        get_bitmap_rbracket(bm);
        unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
        if (bitmap_rbracket) {
            //TODO: make the corresponding changes inside object & skip elements in range
            // end of array
            pos = get_position(bitmap_rbracket, 1); // - 1;
            /// long temp_pos = get_position(bitmap_rbracket, 1);
            /// cout<<"end of array "<<substring_200(mRecord, temp_pos, pos + 64)<<endl;
            return ARRAY_END;
        }
        if (interval.is_complete) {
            // position before comma
            pos = interval_end(interval.intervalbit);
            /// if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
            pos = pos - 1;
            // cout<<"ending position of output array "<<substring_200(mRecord, pos, pos + 64)<<endl;
            return SUCCESS;
        }
        // interval is incomplete in the current word
        ++word_id;
        // ++start_id;
        first_interval = false;
        // relevant_pos = 0;
        new_word = true;
    }
}

__attribute__((always_inline)) int StreamProcessor::goOverPriElems(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    // bool first_interval = false;
    bool new_word = false;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_lbrace(bm);
        get_bitmap_lbracket(bm);
        unsigned long bitmap_bracket = bm.lbracebit | bm.lbracketbit;
        IntervalInfo interval;
        /// if (first_interval == false) {
            if (new_word == true) {
                interval = get_interval_new_word(bitmap_bracket);
            } else {
                interval = get_interval(pos, bitmap_bracket);
            }
            /// first_interval = true;
        ///} else {
        ///    interval = next_interval(bitmap_bracket);
        ///}
        get_bitmap_rbracket(bm);
        unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
        if (bitmap_rbracket) {
            pos = get_position(bitmap_rbracket, 1);
            return ARRAY_END;
        }
        if (interval.is_complete) {
            pos = interval_end(interval.intervalbit);
            //  find cloest colon
            /// while (mRecord[pos] != ':') --pos;
            return SUCCESS;
        }
        ++word_id;
        /// first_interval = false;
        new_word = true;
    }
}

__attribute__((always_inline)) int StreamProcessor::goToObjElem(long& pos, bitmap& bm) {
    do {
        // TODO: remove the temporarliy added code
        if (mRecord[pos] != '{' || mRecord[pos] != '[') {
        int result = goOverPriElems(pos, bm);
        if (result == ARRAY_END) {
            return result;
        }
        }
        int element_type = getElementType(pos);
        if (element_type == OBJECT) {
            return SUCCESS;
        }
        goOverAry(pos, bm);
    } while (hasMoreElements(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int StreamProcessor::goToAryElem(long& pos, bitmap& bm) {
    do {
        /// cout<<"pos needs to skip "<<substring_200(mRecord, pos, pos + 64)<<endl;
        // TODO: remove the temporarliy added code
        if (mRecord[pos] != '{' || mRecord[pos] != '[') {
            /// cout<<"skip prim elements "<<substring_200(mRecord, pos, pos + 64)<<endl;
            int result = goOverPriElems(pos, bm);
            /// cout<<"check skip prim elements result "<<result<<endl;
            if (result == ARRAY_END) {
                return result;
            }
        }
        int element_type = getElementType(pos);
        /// cout<<"next element type "<<element_type<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
        if (element_type == ARRAY) {
            return SUCCESS;
        }
        goOverObj(pos, bm);
    } while (hasMoreElements(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int StreamProcessor::goOverPriAttrs(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    // bool first_interval = false;
    bool new_word = false;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_lbrace(bm);
        get_bitmap_lbracket(bm);
        unsigned long bitmap_bracket = bm.lbracebit | bm.lbracketbit; 
        IntervalInfo interval;
        /// if (first_interval == false) {
        if (new_word == true) {
            interval = get_interval_new_word(bitmap_bracket);
        } else {
            interval = get_interval(pos, bitmap_bracket);
        }
            /// first_interval = true;
        ///} else {
        ///    interval = next_interval(bitmap_bracket);
        ///}
        get_bitmap_rbrace(bm);
        unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
        if (bitmap_rbrace) {
            pos = get_position(bitmap_rbrace, 1);
            return OBJECT_END;
        }
        if (interval.is_complete) {
            pos = interval_end(interval.intervalbit);
            //  find cloest colon
            /// while (mRecord[pos] != ':') --pos;
            return SUCCESS;
        }
        ++word_id;
        /// first_interval = false;
        new_word = true; 
    }
}

__attribute__((always_inline)) int StreamProcessor::goToObjAttr(long& pos, bitmap& bm) {
    do {
        int result = goOverPriAttrs(pos, bm);
        if (result == OBJECT_END) {
            return result;
        }
        int attribute_type = getAttributeType(pos);
        if (attribute_type == OBJECT) {
            return SUCCESS;
        }
        goOverAry(pos, bm);
    } while (hasMoreAttributes(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int StreamProcessor::goToAryAttr(long& pos, bitmap& bm) {
    do {
        int result = goOverPriAttrs(pos, bm);
        if (result == OBJECT_END) {
            return result;
        }
        int attribute_type = getAttributeType(pos);
        if (attribute_type == ARRAY) {
            return SUCCESS;
        }
        goOverObj(pos, bm);
    } while (hasMoreAttributes(pos));
    return OBJECT_END;
}

__attribute__((always_inline)) int StreamProcessor::goToPrimAttr(long& pos, bitmap& bm) {
    long word_id = pos / 64;
    bool first_interval = false;
    bool new_word = false;
    while (true) {
        while (word_id < mNumWords) {
            if (word_id > top_word) {
                /// cout<<"build basic "<<word_id<<" "<<top_word<<endl;
                // build basic bitmaps for the next word
                resetBitmap(bm);
                start_id = word_id * 2;
                build_bitmap_basic();
            }
            get_bitmap_colon(bm);
            IntervalInfo interval;
            if (first_interval == false) {
                if (new_word == true) {
                    /// cout<<"get interval new word "<<pos<<endl;
                    interval = get_interval_new_word(bm.colonbit);
                    new_word = false;
                } else {
                    /// cout<<"get interval "<<pos<<endl;
                    interval = get_interval(pos, bm.colonbit);
                }
                first_interval = true;
            } else {
                /// cout<<"next interval "<<pos<<endl;
                interval = next_interval(bm.colonbit);
            }
            //bitset<64> tempbit(bm.colonbit);
            //bitset<64> tempbit1(interval.intervalbit);
            /// cout<<"colon bitmap "<<tempbit<<" "<<tempbit1<<endl;
            get_bitmap_rbrace(bm);
            unsigned long bitmap_rbrace = bm.rbracebit & interval.intervalbit;
            if (bitmap_rbrace > 0) {
                // object ends
                pos = get_position(bitmap_rbrace, 1);
                ///// cout<<"object end "<<substring_200(mRecord, pos , pos + 64)<<endl;
                return OBJECT_END;
            }
            if (interval.is_complete) {
                pos = interval_end(interval.intervalbit);
                /// if (interval.intervalbit == 0 && pos % 64 == 0) pos = pos - 1;
                pos += 1;
                int type = getAttributeType(pos);
                if (type == OBJECT) {
                    //// cout<<"before skipping an object "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    goOverObj(pos, bm);
                    word_id = pos / 64;  // update word id 
                    first_interval = false;
                    //// cout<<"after skipping an object "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                }
                else if (type == ARRAY) {
                    ///  cout<<"before skipping an array "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                    goOverAry(pos, bm);
                    word_id = pos / 64; // update word id 
                    first_interval = false;
                    /// cout<<"after skipping an array "<<substring_200(mRecord, pos, pos + 64)<<" "<<pos<<endl;
                }
                else {
                    /// cout<<"word id "<<word_id<<" "<<top_word<<endl;
                    /////  cout<<"successfully skip to a primitive "<<pos<<" "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    return SUCCESS;
                }
                break;
            }
            ++word_id;
            //++start_id;
            first_interval = false;
            new_word = true;
        }
    }
}

// TODO: when jumping operation happens, returned position needs to be consistent with others
__attribute__((always_inline)) JumpInfo StreamProcessor::goOverPrimElemsInRange(long& pos, int num_elements, bitmap& bm) {
    int word_id = pos / 64;
    bool new_word = false;
    int num_comma = 0;
    bool flag = false;
    if (mRecord[pos] != '"') flag = true;
    while (word_id < mNumWords) {
        if (word_id > top_word) {
            // build basic bitmaps for the next word
            resetBitmap(bm);
            start_id = word_id * 2;
            build_bitmap_basic();
        }
        get_bitmap_lbrace(bm);
        get_bitmap_lbracket(bm);
        unsigned long bitmap_bracket = bm.lbracebit | bm.lbracketbit;
        IntervalInfo interval;
        if (new_word == true) {
            interval = get_interval_new_word(bitmap_bracket);
        } else {
            interval = get_interval(pos, bitmap_bracket);
        }
        build_bitmap_rbracket(bm);
        unsigned long bitmap_rbracket = bm.rbracketbit & interval.intervalbit;
        get_bitmap_comma(bm);
        unsigned long bitmap_comma = bm.commabit & interval.intervalbit;
        if (bitmap_rbracket) {
            bitmap_comma = bitmap_comma & (bitmap_rbracket ^ (bitmap_rbracket - 1));
        }
        num_comma = num_comma +__builtin_popcountl(bitmap_comma);
        if (num_comma >= num_elements) {
            long temp_pos = word_id * 64 + __builtin_ctzll(bitmap_comma);
            pos = get_position(bitmap_comma, num_elements);
            JumpInfo ji(SUCCESS);
            return ji;
        }
        if (bitmap_rbracket) {
            // end of array
            pos = get_position(bitmap_rbracket, 1);
            JumpInfo ji(ARRAY_END);
            return ji;
        } else {
            if (interval.is_complete) {
                pos = interval_end(interval.intervalbit);// + 1;
                JumpInfo ji(PARTIAL_SKIP, num_comma);
                return ji;
            }
            num_elements -= num_comma;
        }
        // interval is incomplete in the current word
        ++word_id;
        //++start_id;
        new_word = true;
    }
}


__attribute__((always_inline)) int StreamProcessor::goOverElem(long& pos, int num_elements, bitmap& bm) {
    while (num_elements > 0) {
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
        /// cout<<"skip elements before inside "<<substring_200(mRecord, pos, pos + 200)<<" "<<num_elements<<endl; 
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                bool flag = false;
                /*if (mRecord[pos] != '"') {
                    cout<<"skip primitives "<<num_elements<<" "<<substring_200(mRecord, pos, pos + 200)<<endl;
                    flag = true;
                    long word_id = pos / 64;
                    cout<<"word id "<<word_id<<" "<<top_word<<endl;
                }*/
                JumpInfo res = goOverPrimElemsInRange(pos, num_elements, bm);
                ///if (flag == true)
                ///    cout<<"after skipping primitives "<<num_elements<<" "<<substring_200(mRecord, pos, pos + 200)<<endl; 
                if (res.status == ARRAY_END || res.status == SUCCESS) {
                    // cout<<"skip to array end "<<endl;
                    return res.status;
                }
                if (res.status == PARTIAL_SKIP) {
                    num_elements = num_elements - res.num_comma + 1;
                }
                /// skipPrimitiveAry(pos, bm);
                /*int result = skipPrimitiveAry(pos, bm);
                if (result == ARRAY_END)
                    return ARRAY_END;*/
                break;
            }
            case OBJECT:
                goOverObj(pos, bm);
                break;
            case ARRAY:
                goOverAry(pos, bm);
                break;
        }
        --num_elements;
    }
    return SUCCESS;
}

__attribute__((always_inline)) int StreamProcessor::goToObjElemInRange(long& pos, int& num_elements, bitmap& bm) {
     do {
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                JumpInfo res = goOverPrimElemsInRange(pos, num_elements, bm);
                if (res.status == ARRAY_END) {
                    return res.status;
                }
                if (res.status == SUCCESS) {
                    return RANGE_END;
                }
                if (res.status == PARTIAL_SKIP) {
                    num_elements = num_elements - res.num_comma + 1;
                }
                break;
            }
            case OBJECT:
                return SUCCESS;
                // break;
            case ARRAY:
                goOverAry(pos, bm);
                break;
        }
        --num_elements;
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
    } while (num_elements > 0);
    return RANGE_END;
}

__attribute__((always_inline)) int StreamProcessor::goToAryElemInRange(long& pos, int& num_elements, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                JumpInfo res = goOverPrimElemsInRange(pos, num_elements, bm);
                if (res.status == ARRAY_END) {
                    return res.status;
                }
                if (res.status == SUCCESS) {
                    return RANGE_END;
                }
                if (res.status == PARTIAL_SKIP) {
                    num_elements = num_elements - res.num_comma + 1;
                }
                break;
            }
            case OBJECT:
                goOverObj(pos, bm);
                break;
            case ARRAY:
                return SUCCESS;
        }
        --num_elements;
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
    } while (num_elements > 0);
    return RANGE_END;
}

__attribute__((always_inline)) int StreamProcessor::goToPrimElemInRange(long& pos, int& num_elements, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        int result = 0;
        switch(element_type) {
            case PRIMITIVE: {
                return SUCCESS;
            }
            case OBJECT:
                goOverObj(pos, bm);
                break;
            case ARRAY:
                goOverAry(pos, bm);
        }
        --num_elements;
        if (!hasMoreElements(pos)) {
            return ARRAY_END;
        }
    } while (num_elements > 0);
    return RANGE_END;
}

// TODO: check whether pos after using skippers points to the correct position
// e.g. pos = get_position() - 1 when reaching to end of object/array
__attribute__((always_inline)) bool StreamProcessor::hasMoreElements(long& pos) {
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') ++pos;
    ++pos;
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') ++pos; 
    if (mRecord[pos] == ']') {
        return false;
    }
    if (mRecord[pos] == ',') ++pos;
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') ++pos;
    return true;
}

__attribute__((always_inline)) int StreamProcessor::getElementType(long& pos) {
    while (mRecord[pos] == ' ') ++pos;
    if (mRecord[pos] == '{') return OBJECT;
    if (mRecord[pos] == '[') return ARRAY;
    return PRIMITIVE;
}

__attribute__((always_inline)) int StreamProcessor::goToPrimElem(long& pos, bitmap& bm) {
    do {
        int element_type = getElementType(pos);
        switch (element_type) {
            case PRIMITIVE:
                return SUCCESS;
            case OBJECT:
                goOverObj(pos, bm);
                break;
            case ARRAY:
                goOverAry(pos, bm);
        }
    } while (hasMoreElements(pos));
    return ARRAY_END;
}

// TODO: check whether pos after using skippers points to the correct position
// e.g. pos = get_position() - 1 when reaching to end of object/array
__attribute__((always_inline)) bool StreamProcessor::hasMoreAttributes(long& pos) {
    // if current character is blank, skip this character until meeting a non-blank character
    while (mRecord[pos] == ' ') ++pos;
    ++pos;
    while (mRecord[pos] == ' ') {
        ++pos;
    }
    if (mRecord[pos] == '}') {
        return false;
    }
    if (mRecord[pos] == ',') ++pos;
    while (mRecord[pos] == ' ' || mRecord[pos] == '\n') ++pos; 
    return true;
}

__attribute__((always_inline)) int StreamProcessor::getAttributeType(long& pos) {
    while (mRecord[pos] == ' ') ++pos;
    if (mRecord[pos] == '{') return OBJECT;
    if (mRecord[pos] == '[') return ARRAY;
    return PRIMITIVE;
}

void StreamProcessor::object(long& pos, bitmap& bm) {
    //TODO: change the following function name into typeExpectedInObj
    int attribute_type = qa.typeExpectedInObj();
    while (hasMoreAttributes(pos)) {
        /// cout<<"attribute pos "<<substring_200(mRecord, pos, pos + 100)<<endl;
        int result = 0;
        int next_state = 0;
        int element_type = attribute_type;
        switch (attribute_type) {
            case OBJECT:
                result = goToObjAttr(pos, bm);
                break;
            case ARRAY:
                result = goToAryAttr(pos, bm);
                break;
            case PRIMITIVE: {
                 ///cout<<"before going next primitive "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 100)<<endl;
                /// result = goToPrimAttr(pos, bm);
                long st = pos;
                // while (mRecord[st] != ':') --st;
                while (mRecord[st] != '"') ++st;
                long ed = st + 1;
                while (mRecord[ed] != '"') ++ed;
                int key_len = ed - st - 1;
                memcpy(mKey, mRecord + st + 1, key_len);
                mKey[key_len] = '\0';
                /// cout<<"key "<<mKey<<" len "<<key_len<<" "<<pos<<endl;
                next_state = qa.getNextState(mRecord + st + 1, key_len);
                while (mRecord[ed] != ':') ++ed; 
                pos = ed + 1;
                element_type = getElementType(pos);
                ///cout<<"before next primitive "<<substring_200(mRecord, pos, pos +100)<<endl;
            }
        }
        if (result == OBJECT_END)
            return;
        // int next_state = 0;
        /*if (attribute_type != PRIMITIVE) {
        long st = 0;
        long ed = 0;
        long cur_pos = pos;
        // find the previous colon
        /// cout<<qa.mCurState<<" "<<attribute_type<<" before colon check "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
        while (mRecord[cur_pos] != ':') --cur_pos; 
        /// cout<<"colon check "<<mRecord[cur_pos]<<" "<<substring_200(mRecord, cur_pos, cur_pos + 50)<<endl;
        findFieldQuotePos2(cur_pos, st, ed);
        int key_len = ed - st - 1;
        next_state = qa.getNextState(mRecord + st + 1, key_len, KEY);
        } */
        if (attribute_type != PRIMITIVE) {
            long st = pos;
            while (mRecord[st] != ':') --st;
            while (mRecord[st] != '"') --st;
            long ed = st - 1;
            while (mRecord[ed] != '"') --ed;
            int key_len = st - ed - 1;
            memcpy(mKey, mRecord + ed + 1, key_len);
            mKey[key_len] = '\0';
            /// cout<<"key "<<mKey<<" len "<<key_len<<" "<<pos<<endl;
            next_state = qa.getNextState(mRecord + ed + 1, key_len);
        }
         //memcpy(mKey, mRecord + st + 1, key_len);
        // mKey[key_len] = '\0';
       /// if (strcmp(mKey, "timestamp_ms") != 0) 
         ///cout<<"key "<<mKey<<" "<<next_state<<" cur state "<<qa.mCurState<<" "<<attribute_type<<" "<<pos<<endl;
        /// int element_type = getElementType(pos);
        /*cout<<"element type "<<element_type<<" "<<substring_200(mRecord, pos, pos + 100)<<endl;
        if (element_type != attribute_type) {
            cout<<"ele type "<<element_type<<" "<<attribute_type<<endl;
        }*/
        if (next_state == UNMATCHED_STATE) {
            switch (element_type) {
                case OBJECT:
                    goOverObj(pos, bm);
                    break;
                case ARRAY:
                    goOverAry(pos, bm);
                    break;
                case PRIMITIVE: {
                    ///cout<<"before skipping primitive "<<substring_200(mRecord, pos, pos + 100)<<endl;
                    goOverPriAttr(pos, bm);
                    //++pos;
                    /// cout<<"after skipping primitive "<<substring_200(mRecord, pos, pos + 100)<<endl;

                }
            }
        } else if (qa.isAccept(next_state) == true) { //ACCEPT
            ++mOutputSize;
            long start_pos = pos;
            switch (element_type) {
                case OBJECT: {
                    goOverObj(pos, bm);
                    break;
                }
                case ARRAY: {
                    goOverAry(pos, bm);
                    break;
                }
                case PRIMITIVE:
                    goOverPriAttr(pos, bm);
                    ++pos;
            }
            long end_pos = pos;
            long text_length = end_pos - start_pos + 1;
            memcpy(mText, mRecord + start_pos, text_length);
            mText[text_length] = '\0';
            mOutput.append(mText);
            /// cout<<"text "<<mText<<endl;
            ///cout<<"going to skip remaining pairs1 "<<substring_200(mRecord, pos, pos + 64)<<endl;
            if (mRecord[pos] != '}') {
                if (qa.getStackSize() == 0) return;
                /// cout<<"prev pos "<<pos<<endl;
                goToObjEnd(pos, bm);
                /// cout<<"after pos "<<pos<<endl;
                // skipObject(pos, bm);
            }
            ///cout<<"after skip remaining pairs1 "<<substring_200(mRecord, pos, pos + 64)<<endl;  
            break;
        } else {  // in-progress
            qa.pushStack(next_state);
            switch (attribute_type) {
                case OBJECT:
                    object(pos, bm);
                    break;
                case ARRAY:
                    array(pos, bm);
                //case PRIMITIVE:
                //    skipPrimitiveObj(pos, bm);
            }
            qa.popStack(); // virtual token "value"
           /// cout<<"going to skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<endl;
            /// pend_wid = pos;
            if (qa.getStackSize() == 0) return;
            goToObjEnd(pos, bm);
            /// skipObject(pos, bm);
            /// pend_wid1 = pos;
            ///cout<<"after after skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<" st "<<(pend_wid % 64)<<" ed "<<(pend_wid1 % 64)<<endl;
            break;
        }
    }
    // if (hasMoreAttributes(pos))
       // skipObject(pos, bm); 
}

void StreamProcessor::array(long& pos, bitmap& bm) {
    ///if (mRecord[pos + 2] == 'n')
    /// cout<<"process array "<<substring_200(mRecord, pos, pos + 200)<<endl;
    int next_state = qa.getNextStateNoKey();
    qa.pushStack(next_state);
    int element_type = qa.typeExpectedInArr();
    long prev_pos = -1; // only use for debugging
    bool flag = false;
    if (qa.hasIndexConstraints()) {
        IndexInfo idx_info = qa.getIndexInfo(qa.mCurState);
        int start_idx = idx_info.start_idx; //qa.mDfa.trans_ele[qa.mCurState - 1].start_idx;
        int end_idx = idx_info.end_idx; //qa.mDfa.trans_ele[qa.mCurState - 1].end_idx;
        /////cout<<"process index constraint "<<start_idx<<" "<<end_idx<<endl;
        int num_elements = end_idx - start_idx;
        if (start_idx > 0) {
            /// if (flag == false) cout<<qa.mCurState<<" jump start index "<<start_idx<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            int result = goOverElem(pos, start_idx, bm);
            if (result == ARRAY_END) {
                /////cout<<"array end "<<substring_200(mRecord, pos, pos + 64)<<endl;
                qa.popStack();
                return; 
            }
            /// if(flag == false) cout<<"skip elements before "<<qa.mCurState<<" "<<(start_idx + 1)<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
        }
        while (hasMoreElements(pos) && num_elements > 0) {
            if (qa.isAccept(qa.mCurState) == true) {
                ++mOutputSize;
                long start_pos = pos;
                bool break_while = false;
                int value_type = element_type;
                if (element_type == PRIMITIVE) {
                    /// cout<<"state "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    value_type = getElementType(pos); 
                    /*if (value_type != PRIMITIVE) { 
                        cout<<"******value type "<<value_type<<" "<<substring_200(mRecord, pos, pos + 64)<<" "<<start_idx<<" "<<num_elements<<endl;
                        flag = true;
                        long temp_pos = pos  + 3;
                        int result = skipElements(temp_pos, start_idx, bm);
                        cout<<"******check after result "<<qa.mCurState<<" "<<substring_200(mRecord, temp_pos, temp_pos + 64)<<" "<<result<<endl; 
                    }*/
                }
                switch (value_type) {
                    case OBJECT: {
                        goOverObj(pos, bm);
                        break;
                    }
                    case ARRAY: {
                        goOverAry(pos, bm);
                        break;
                    }
                    case PRIMITIVE: {
                        int result = goOverPriElem(pos, bm);
                        if (result == ARRAY_END) {
                            break_while = true;
                            /////cout<<"break array "<<substring_200(mRecord, pos, pos + 64)<<" "<<num_elements<<endl;
                        }
                    }
                }
                long end_pos = pos;
                long text_length = end_pos - start_pos + 1;
                memcpy(mText, mRecord + start_pos, text_length);
                mText[text_length] = '\0';
                mOutput.append(mText);
                ///if (mOutputSize == 1) 
                  ///cout<<mText<<endl;
                if (break_while) {
                    // TODO: check whether the following condition check is needed.
                    if (mRecord[pos] != ']')
                        goToAryEnd(pos, bm);
                        ///skipArray(pos, bm);
                    break;
                }
                --num_elements;
            } else if (qa.mCurState > 0) {
                int result; 
                switch (element_type) {
                    case OBJECT: {
                        /// cout<<"prior pos "<<pos<<endl;
                        result = goToObjElemInRange(pos, num_elements, bm);
                        /// cout<<"after find object pos "<<pos<<endl;
                        break;
                    }
                    case ARRAY: {
                        result = goToAryElemInRange(pos, num_elements, bm);
                        /// break;
                    }
                }
                if (result == SUCCESS) {
                    /*int value_type = element_type;
                    if (element_type != PRIMITIVE)
                        value_type = getElementType(pos);*/
                    switch (element_type) {
                        case OBJECT:
                            prev_pos = pos;
                            object(pos, bm);
                            // cout<<"after skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<endl;
                            break;
                        case ARRAY: {
                            /// cout<<"going to array with constraint "<<qa.mCurState<<endl;
                            array(pos, bm);
                        }
                    }
                    --num_elements;
                } else if (result == ARRAY_END) {
                    qa.popStack();
                    return;
                } else if (result == RANGE_END) {
                    if (mRecord[pos] != ']') {
                        if (qa.getStackSize() == 1) return;
                        /// skipArray(pos, bm);
                        goToAryEnd(pos, bm);
                    }
                    break;
                }
            }
        }
        /////cout<<"out of while loop for array "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 200)<<endl;
        if (mRecord[pos] != ']') {
            if (qa.getStackSize() == 1) return;
            /// skipArray(pos, bm);
            goToAryEnd(pos, bm);
            /////cout<<"after out of while loop for array "<<substring_200(mRecord, pos, pos + 200)<<endl;
        }
    } else {
    /// cout<<"array state "<<next_state<<" element type "<<element_type<<endl;
        while (hasMoreElements(pos)) {
        ///cout<<"cur state "<<qa.mCurState<<" next token "<<mRecord[pos]<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            if (qa.isAccept(qa.mCurState) == true) {
                ++mOutputSize;
                long start_pos = pos;
                bool break_while = false;
                int value_type = element_type;
                if (element_type == PRIMITIVE)
                    value_type = getElementType(pos);
            ///cout<<"output "<<value_type<<" "<<mRecord[pos]<<" "<<getElementType(pos)<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                switch (value_type) {
                    case OBJECT: {
                        goOverObj(pos, bm);
                        break;
                    }
                    case ARRAY: {
                        goOverAry(pos, bm);
                        break;
                    }
                    case PRIMITIVE: {
                        int result = goOverPriElem(pos, bm);
                        if (result == ARRAY_END) {
                            break_while = true;
                        }
                    }
                }
                long end_pos = pos;
                long text_length = end_pos - start_pos + 1;
                memcpy(mText, mRecord + start_pos, text_length);
                mText[text_length] = '\0';
                mOutput.append(mText);
                /// if (mOutputSize == 2) cout<<mText<<endl;
                if (break_while) break;
            } else if (qa.mCurState > 0) {
                if (getElementType(pos) != element_type) {
                /// cout<<"element type "<<element_type<<" "<<getElementType(pos)<<endl;
                // reset pos for hasMoreElement, TODO: avoid this in the final code
                /// while (mRecord[pos] == ' ' || mRecord[pos] == '\n' || mRecord[pos] == '\r') --pos;
                // --pos;
                    int result;
                    switch (element_type) {
                        case OBJECT:
                            result = goToObjElem(pos, bm);
                            break;
                        case ARRAY:
                            result = goToAryElem(pos, bm);
                        //break;
                    // impossible
                    /*case PRIMITIVE:
                        result = goToPrimElem(pos, bm);*/
                    }
                /// cout<<"after skipping "<<result<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                    if (result == ARRAY_END) {
                        qa.popStack();
                        return;
                    }
                }
            /*if (getElementType(pos) != element_type) {
                 cout<<"before visit object "<<substring_200(mRecord, prev_pos, prev_pos + 64)<<endl; 
                cout<<pend_wid<<" before skip remaining pairs "<<substring_200(mRecord, pend_wid, pend_wid + 200)<<endl;
                cout<<pend_wid1<<" after skip remaining pairs "<<substring_200(mRecord, pend_wid1, pend_wid1 + 200)<<endl;
                cout<<pos<<" char "<<mRecord[pos]<<"type "<<getElementType(pos)<<" expected type "<<element_type<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
            }*/
            /// cout<<"get the target element "<<element_type<<" "<<substring_200(mRecord, pos, pos + 64)<<endl;
                switch (element_type) {
                    case OBJECT:
                        prev_pos = pos;
                        object(pos, bm);
                    // cout<<"after skip remaining pairs "<<substring_200(mRecord, pos, pos + 64)<<endl;
                        break;
                    case ARRAY: {
                    /// cout<<"going to array "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 100)<<endl;
                        array(pos, bm);;
                    }
                } 
            }
        /// cout<<"before check hasMoreElement "<<qa.mCurState<<" "<<substring_200(mRecord, pos, pos + 64)<<endl; 
        }
    }
    qa.popStack();
    /// cout<<"end array "<<qa.mCurState<<endl; 
}

char StreamProcessor::getNextNonEmptyCharacter(long& pos) {
    char ch = mRecord[pos];
    while (mRecord[pos] == ' ') ++pos;
    return mRecord[pos];
}

long StreamProcessor::getNumOfOutputs() {
    return mOutputSize;
}

string StreamProcessor::run() {
    long cur_pos = 0;
    char ch = getNextNonEmptyCharacter(cur_pos);
    bitmap bm;
    if (ch == '{')
        object(cur_pos, bm);
    else if(ch == '[')
        array(cur_pos, bm);
///    cout<<"output size "<<mOutputSize<<endl;
    return mOutput;
}
